<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[VS Code使用基础]]></title>
    <url>%2FVS-Code%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[工欲善其事, 必先利其器. 作为一个前端程序猿打造一个好看好用的编辑器, 对于工作效率的提高有很大的帮助.主题字体字体选用的FiraCode, 下载安装然后参见VS Code Instructions相关设置. 其它好看的字体还有Source Code Pro等.颜色主题和文件图标主题颜色主题选用的是One Dark Pro. 编辑器内置了几款颜色主题, 如果没有喜欢的就在扩展主题里找找.文件图标主题配置同颜色主题配置.用户设置Commonly Used控制字段控制内容files.autoSave自动保存editor.tabSize制表符的空格数editor.renderWhitespace空白字符显示方式editor.wordWrap换行方式files.exclude配置排除的文件和文件夹的 glob 模式. 不需要关心的文件或文件夹在此排除.files.associations配置语言的文件关联. eg:&quot;**.jsp&quot;: &quot;javascript&quot;files.trimTrailingWhitespace启用后，将在保存文件时剪裁尾随空格workbench.editor.labelFormat控制编辑器标签的格式window.openFilesInNewWindow控制是否在新窗口中打开文件terminal.integrated.shell.osx终端在 macOS 上使用的 Shell 的路径breadcrumbs.enabled启用/禁用导航路径(面包屑)emmet.includeLanguages在默认不支持 Emmet 的语言中启用 Emmet 缩写功能. eg:&quot;vue-html&quot;: &quot;html&quot;, &quot;javascript&quot;: &quot;javascriptreact&quot;编辑器控制字段控制内容editor.formatOnType控制编辑器在键入一行后是否自动格式化该行editor.minimap.enabled是否显示小地图editor.mouseWheelZoom按住 Ctrl 键并滚动鼠标滚轮时对编辑器字体大小进行缩放editor.parameterHints.enabled在输入时显示含有参数文档和类型信息的小面板files.exclude配置排除的文件和文件夹的 glob 模式. 不需要关心的文件或文件夹在此排除.files.associations配置语言的文件关联. eg:`”.jsp”: “javascript”`*快捷键关键字快捷键删除行cmd + D合并行ctrl + J光标后退ctrl + _光标前进ctrl + shift + _向下面插入行cmd + enter向上面插入行cmd + shift + enter转到文件cmd + P显示所有命令cmd + shift + P文件查找cmd + F全局搜索cmd + shift + F切换行注释cmd + /切换块注释shift + alt + A撤销cmd + Z恢复撤销cmd + shift + Z缩进tab缩进shift + tab移动到行尾cmd + right移动到行首cmd + left向上移动行cmd + up向下移动行cmd + down保持打开状态cmd + K enter打开集成终端ctrl + `集成终端清屏cmd + K格式化文件shift + alt + F常见操作窗口code命令VS Code快速打开文件夹或文件,可以将其直接拖至VS Code图标上. 或cmd + shift + P打开命令面板, 向Path添加code, 用code命令操作.文件对比工作区可以将其它项目与当前项目置于同一工作区, 在同一个窗口查看编辑.自定义终端在Mac终端改造里, 已经打造好了个性化的终端了. 在VS Code里只需要换个路径即可.在用户设置里用以下配置覆盖.1"terminal.integrated.shell.osx": "/bin/zsh",添加自定义snippetVS Code内置了自定义snippet功能, 用户可以根据自己的需求去添加自己想要的代码段, 灵活且方便, 这样就完全没有必要去安装类似的插件了. 细节可参考[VS Code]跟我一起在Visual Studio Code 添加自定义snippet（代码段），附详细配置.插件Chinese (Simplified) Language Pack for VS Code此中文（简体）语言包为 VS Code 提供本地化界面.Bookmarks在代码中做标记, 可以在不同的标记中快速便捷的切换.Auto Rename Tag修改HTML/XML标签时, 首尾标签会自动同步更改.ESLint一个开源的 JavaScript 代码检查插件, 可以在编写或保存文件时对文件进行检测. 根据规则配置文件对文件进行检测提示, 并可以自动修复部分不符合规则的部分.&quot;eslint.options&quot;: { &quot;configFile&quot;: &quot;**/**/**&quot; } : 本地的配置文件地址路径.eslint.validate: 可被识别的文件类型.eslint.autoFixOnSave: 保存时自动修复.Debugger for Chrome在代码里断点, 就是相对地知道文件在哪里吧, Chrome里打断点还是挺好用地. Debugger for Chrome 配置可参见官网例子.插件什么的真的不见得能提高多少效率, 讲真, 颜值才是正义, 颜值才是王道🤔.]]></content>
      <categories>
        <category>善事利器</category>
      </categories>
      <tags>
        <tag>编辑器</tag>
        <tag>Visual Studio Code</tag>
        <tag>VS Code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[观察者模式再次进阶]]></title>
    <url>%2F%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E5%86%8D%E6%AC%A1%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[发布/订阅者模式发布/订阅模式概念说起观察者模式, 往往会牵扯到发布/订阅模式. 两者存在着很多的相似之处, 它们都是维护着一个列表, 然后都可以对列表的对象进行增删和通知. 不同的地方可能就在于处理添加和通知的方式上吧.发布/订阅模式使用了一个主题/事件通道, 这个通道介于希望接到通知的对象(订阅者)和激活事件的对象(发布者)之间. 该事件系统允许代码定义应用程序的特定事件, 这些事件可以传达自定义参数, 自定义参数包含订阅者所需的值. 其目的是避免订阅者和发布者之间产生依赖关系. ———《设计模式: 可复用面向对象软件基础》戏说发布/订阅模式模式以下所有代码参见publish/subscribe.既然和观察者模式类似, 那么在从观察者模式说起提到的小故事, 就可以接着往下续了.subject1带着那么一拨人回去复命, 经过一段时间的磨合实践, 效果也是很明显. 附近的公司听到风声后, 也纷纷组织派遣员工前来学习. 人多了, 需求也变多了, 这么多人肯定不能再呆在一起学习了. 原来只是一个公司的人呆在一间屋子里学习, 得到命令后大家开始各司其职. 现在, 各个公司的学习内容不同, 它们理应独立开来. 因为各个公司动作可以不同步, 但公司内部一定要同步起来. 为了区别对待, 每个公司都有能和别人区分的令牌, 有了令牌同一个公司的人就可以进入与令牌相对应的房间了(当然一个人也可以有很多令牌, 商业间谍吧😂).1234567// 我是Pubsub, 我负责管理这拨人.class Pubsub &#123; constructor() &#123; // 维护事件列表, 这里将以对象的形式出现, key: value, key: 令牌, value: 同一公司员工列表. this. handles = &#123;&#125; &#125;&#125;现在, 不同公司的人前来学习的时候, 需要告诉Pubsub他们公司的令牌号, 进而引领到令牌对应的房间.12345678910class Pubsub &#123; // 省略 // 注册事件. 如果是公司第一次派人过来, 那就新开一间. subscribe(type, handle) &#123; if (!this.handles[type]) &#123; this.handles[type] = [] &#125; this.handles[type].push(handle) &#125;&#125;如果某个房间的某个人, 或整个房间的人都不打算来了, 也需要Pubsub将其注销.12345678910111213class Pubsub &#123; // 省略 // 注销事件. 公司个人或整体注销. unsubscribe(type, handle) &#123; let pos = this.handles[type].indexOf(handle) if (!handle) &#123; // 不传handle, 则默认注销所有和type事件相关的事件处理函数. this.handles.length = 0 &#125; else &#123; ~pos &amp;&amp; this.handles[type].splice(pos, 1) &#125; &#125;&#125;不同的团体做出了区分, 算是万事具备. 想要哪个房间里的人动起来, 有了令牌号, 只要对着吼一嗓子即可.123456789101112class Pubsub &#123; // 省略 // 通知事件 publish() &#123; // 执行所有和type事件相关的处理函数. let type = Array.prototype.shift.call(arguments) this.handles[type].forEach(handle =&gt; &#123; // 箭头函数不绑定Arguments对象 handle.apply(this, arguments) &#125;) &#125;&#125;让我们看看效果如何.12345678910111213141516171819202122232425let handle1 = (...rest) =&gt; &#123;document.write('handle1', JSON.stringify(rest), '&lt;br/&gt;')&#125;let handle2 = (...rest) =&gt; &#123;document.write('handle2', JSON.stringify(rest))&#125;let ps = new Pubsub()ps.subscribe('notify-1', handle1)ps.subscribe('notify-1', handle2)ps.subscribe('notify-2', handle2)ps.unsubscribe('notify-1', handle2)ps.publish('notify-1', 'hahaha', 'heiheihei', [], &#123;&#125;)ps.publish('notify-2', 'hehehehehe')// 结果:handle1["hahaha","heiheihei",[],&#123;&#125;]handle2["hehehehehe"]不难发现, 我们的Pubsub老师只认令牌😅.]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>观察者模式</tag>
        <tag>发布/订阅模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac终端改造]]></title>
    <url>%2FMac%E7%BB%88%E7%AB%AF%E6%94%B9%E9%80%A0%2F</url>
    <content type="text"><![CDATA[平时Mac使用的shell使bash, 它虽然能满足我们的需要, 但是使用起来不是很方便. zsh可配置性强, 用户可以自定义配置, 个性化强.更换shell查看当前使用的shellecho $SHELL1/bin/bash查看系统当前内置的shellcat /etc/shells123456/bin/bash/bin/csh/bin/ksh/bin/sh/bin/tcsh/bin/zsh如果没有发现/bin/zsh, 就需要手动安装Zsh.更换shellchsh -s /bin/zsh12Changing shell for yuchen.Password for yexiaochen: your password重启echo $SHELL1/bin/zsh替换成功!安装oh-my-zshoh-my-zsh用来管理Zsh配置的.安装sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;.1234567891011121314Looking for an existing zsh config...Using the Oh My Zsh template file and adding it to ~/.zshrc __ ______ / /_ ____ ___ __ __ ____ _____/ /_ / __ \/ __ \ / __ `__ \/ / / / /_ / / ___/ __ \/ /_/ / / / / / / / / / / /_/ / / /_(__ ) / / /\____/_/ /_/ /_/ /_/ /_/\__, / /___/____/_/ /_/ /____/ ....is now installed!Please look over the ~/.zshrc file to select plugins, themes, and options.p.s. Follow us at https://twitter.com/ohmyzsh.p.p.s. Get stickers and t-shirts at https://shop.planetargon.com.更改配置vim ~/.zshrc12345678910111213141516171819202122232425# Set name of the theme to load --- if set to "random", it will# load a random theme each time oh-my-zsh is loaded, in which case,# to know which specific one was loaded, run: echo $RANDOM_THEME# See https://github.com/robbyrussell/oh-my-zsh/wiki/ThemesZSH_THEME="robbyrussell"# Uncomment the following line to disable bi-weekly auto-update checks.# DISABLE_AUTO_UPDATE="true"# Uncomment the following line to enable command auto-correction.ENABLE_CORRECTION="true"# Uncomment the following line to display red dots whilst waiting for completion.COMPLETION_WAITING_DOTS="true"# Which plugins would you like to load?# Standard plugins can be found in ~/.oh-my-zsh/plugins/*# Custom plugins may be added to ~/.oh-my-zsh/custom/plugins/# Example format: plugins=(rails git textmate ruby lighthouse)# Add wisely, as too many plugins slow down shell startup.plugins=(git)source $ZSH/oh-my-zsh.sh以上是部分配置, 需将#删除才能生效. 键入i进入编辑模式, 修改后esc退出编辑模式, 键入:wq保存退出. oh-my-zsh有支持的主题和插件, 可以自由配置.插件推荐zsh-syntax-highlighting安装git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting修改配置.vim ~/.zshrc123plugins=( git zsh-syntax-highlighting)让修改生效.source ~/.zshrczsh-autosuggestions安装.git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions修改配置.vim ~/.zshrc123plugins=( git zsh-autosuggestions zsh-syntax-highlighting)让修改生效.source ~/.zshrc好了, 打完收工!]]></content>
      <categories>
        <category>善事利器</category>
      </categories>
      <tags>
        <tag>Mac终端</tag>
        <tag>oh-my-zsh</tag>
        <tag>zsh</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进击的观察者模式]]></title>
    <url>%2F%E8%BF%9B%E5%87%BB%E7%9A%84%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[商品信息改变带来的烦恼Talk is cheap. Show me the code. (译: 屁话少说, 放码过来)以下所有代码参见Design pattern transformation.12345678910111213141516171819202122232425// 商品的信息: 价格 &amp; 折扣const data = &#123; price: 100, discount: 0.8&#125;// 顾客信息: 是否威会员 &amp; 购买数量 &amp; 总消费 &amp; 购买时间戳const customer = &#123; "VIP": true, "quantity": 10, "total": 0,&#125;// 总消费计算方式total = (info) =&gt; &#123; if(!info.VIP) &#123; info.total = data.price * info.quantity; &#125; else &#123; info.total = data.price * data.discount * info.quantity; &#125;&#125;total(customer);console.log('customer', customer);// customer &#123; VIP: true, quantity: 10, total: 800 &#125;从代码中很容易看得出来, 我们就是想实现一个简单的计费功能. 可现实中, 商品的价格可能并不是一成不变的.data.price = 200价格变动后, 我们需要及时地获取总消费, 那么就必须重新调用下 total计费.123total(customer);console.log('customer', customer);// customer &#123; VIP: true, quantity: 10, total: 1600 &#125;这是一个大数据时代, 任何数据都有价值. 现在, 我们还想要每次购买时的时间点.12345678910 const customer = &#123; "VIP": true, "quantity": 10, "total": 0,+ "timeStamp": 0 &#125; // 获取购买时间 purchaseTime = (info) =&gt; &#123; info.timeStamp = Date.now(); &#125;于是, 我们需要执行的函数就多了一个.1234total(customer)purchaseTime(customer)console.log('customer', customer)// &#123; VIP: true, quantity: 10, total: 1600, timeStamp: 1542293676297 &#125;如果我们的需求还有很多, 而且不知一个customer呢. 那么, 每次价格变化我们需要执行很多步骤, 每次啊, 麻烦得很.1234567891011121314151617181920+ const customer1 = &#123;+ "VIP": false,+ "quantity": 8,+ "total": 0,+ "timeStamp": 0+ &#125; total(customer) purchaseTime(customer) func(customer) ... funcN(customer1) total(customer1) purchaseTime(customer1) func(customer1) ... funcN(customer) ... funcN(customerN)现在我们就对上面的代码进行观察者模式改造.用观察者模式改造从上面的例子中🌰🀄️不难看出, 每次价格变化时, 我们都需要重复调用满足需求的方法. 不妨想想, 如果我们把这些方法存储起来, 等到价格变化时再去统一调用, 岂不是很方便. 那么问题来了, 这和之前所说的观察者模式(从观察者模式说起)有什么区别呢? 在此, 我们试着用观察者模式改造下.首先观察者模式都是一个套路. 先一个类维护一个列表, 对列表有增删和通知更新功能. 另一个类则是提供了更新接口.123456789101112131415161718192021// 观察目标类class Subject &#123; constructor() &#123; this.observerList = [] &#125; addObserver(observer) &#123; this.observerList.push(observer) &#125; notify(params) &#123; this.observerList.forEach(observer =&gt; &#123; observer.update(params) &#125;) &#125;&#125;// 观察者类class Observer &#123; constructor(fn) &#123; this.update = fn &#125;&#125;接着, 把我们想要调用的方法包装一下, 存储起来.12345678// 将要重复使用的包装一下observer1 = new Observer(total)observer2 = new Observer(purchaseTime)// 存起来let subject = new Subject()subject.addObserver(observer1)subject.addObserver(observer2)每次价格改变时, 只需要通知一下即可.1234// 调整商品价格data.price = 100subject.notify(customer)subject.notify(customer1)改造结束. 初看起来, 可能变得繁琐了. 但是, 遇到复杂的情况, 这不失是一个好办法. 接下来, 我们看看结合Objec.defineProperty会有什么惊喜.与Objec.defineProperty结合支付宝的花呗都可以自己还钱了🤣, 我们为什么还要别人管着😏. 大家都知道经过Objec.defineProperty处理的对象, 在设置和获取对象属性的时候, 会自动触发响应set和get方法. 利用这一点, 我们就可以做到生活自理了. 熟悉的配方, 熟悉的味道. 熟悉的套路我们不妨再走一遍.123456789101112131415161718192021// 观察目标类class Dependency &#123; constructor() &#123; this.watcherList = [] &#125; addObserver(observer) &#123; this.watcherList.push(observer) &#125; notify(params) &#123; this.watcherList.forEach(watcher =&gt; &#123; watcher.update(params) &#125;) &#125;&#125;// 观察类class Watcher &#123; constructor(fn) &#123; this.update = fn &#125;&#125;我们此行的目的, 是要在data.price 或data.discount改变时, 程序能够自动触发, 得到我们想要的结果. 换句话说, 通知更新的时机是在设置data.price或data.discount的时候.12345678910111213 Object.keys(data).forEach(key =&gt; &#123; let value = data[key] const dep = new Dependency() Object.defineProperty(data, key, &#123; set(newVal) &#123; value = newVal dep.notify() &#125;, get() &#123; return value &#125; &#125;)&#125;)对象的每个属性都给了一个依赖实例, 管理自己的依赖. 考虑到customer有很多个, 需要通知到位. 另外, 添加依赖和管理依赖, 前者是因, 后者是果. 在管理之前我们需要想好怎么添加依赖. 回头看一看.123456789101112 // 总消费计算方式 total = (info) =&gt; &#123; if(!info.VIP) &#123; info.total = data.price * info.quantity; &#125; else &#123; info.total = data.price * data.discount * info.quantity; &#125; &#125; // 获取购买时间purchaseTime = (info) =&gt; &#123; info.timeStamp = Date.now();&#125;我们发现, total函数依赖于data.price或data.discount的. 如果我们在获取属性时去添加依赖倒是一个好时机.1234567891011121314151617181920212223242526272829303132333435 class Dependency &#123; // 省略 &#125;+ Dependency.targey = null;class Watcher &#123; constructor(fn, key) &#123; this.update = fn+ this.key = key+ this.value = this.getter() &#125;+ getter() &#123;+ Dependency.targey = this;+ // 出发下面的get()+ this.value = data[this.key];+ Dependency.targey = null;+ &#125;&#125;Object.keys(data).forEach(key =&gt; &#123; let value = data[key] const dep = new Dependency() Object.defineProperty(data, key, &#123; set(newVal) &#123; value = newVal dep.notify() &#125;, get() &#123;+ if (Dependency.targey) &#123;+ dep.addObserver(Dependency.targey)+ &#125; return value &#125; &#125;)&#125;)然而purchaseTime方法里并没有data.price或data.discount可以设置. 所以这个方法行不通. 那么, 干脆紧接着依赖实例去添加依赖吧. 同时考虑到多个customer, 我们封装下.1234567891011121314151617181920212223// 与defineProperty结合function defineReactive(data, watcherList, funcList) &#123; Object.keys(data).forEach(key =&gt; &#123; let value = data[key] const dep = new Dependency() funcList.forEach(func =&gt; &#123; dep.addObserver(new Watcher(func)) &#125;) Object.defineProperty(data, key, &#123; set(newVal) &#123; value = newVal watcherList.forEach(watcher =&gt; &#123; dep.notify(watcher) &#125;) &#125;, get() &#123; return value &#125; &#125;) &#125;)&#125;defineReactive(data, [customer, customer1], [total, purchaseTime])大功告成, 价格变动时, 我们就会自动获取到想要的结果了. 我都能自理了, 你花呗为嘛还不能自己还钱呢😒]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>观察者模式</tag>
        <tag>Object.defineProperty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从观察者模式说起]]></title>
    <url>%2F%E4%BB%8E%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E8%AF%B4%E8%B5%B7%2F</url>
    <content type="text"><![CDATA[观察者模式观察者模式的定义Observer(观察者)是一种设计模式, 其中, 一个对象(称为 subject) 维持一系列依赖于它的观察者对象, 将有关状态的任何变更自动通知给观察者.当一个目标(subject)需要告诉观察者发生了什么有趣的事情, 它会向观察者广播一个通知. 当我们不再希望某个特定的观察者获得其注册目标(subject)发出的改变通知时, 该目标可以将它从观察者列表中删除.“一个或多个观察者对目标的状态感兴趣, 它们通过将自己依附在目标对象上以便注册所感兴趣的内容. 目标状态发生改变并且观察者可能对这些改变感兴趣, 就会发送一个通知消息, 调用每个观察者的更新方法. 当观察者不再对目标状态感兴趣时, 它们可以简单地将自己从中分离.” ———《设计模式: 可复用面向对象软件基础》观察者模式的理解从观察者模式的定义中可以对观察者模式有个大体的了解. 观察者模式中有两类, 一类被称为目标(Subject), 一类被称为观察者(Observer). Subject的工作是维护一系列的Observer, 可以对它们进行添加、删除和通知的操作. Observer的工作则是为Subject状态发生变化需要获得通知的对象提供更新接口.戏说观察者模式先不管观察者模式是什么, 我们可以试着想想如何从观察者模式的定义去实现这些功能. 下面我们从一个小故事说起.从前有个人. 凭着天资聪颖再加上闯荡江湖多年, 无论从事什么行业都能称为行业翘楚, 算是有名气的人物.1class Subject &#123;&#125; // 我是有个人. Subject是江湖送我的绰号.有一天, 有一个初创公司慕名前来拜访, 探讨如何在现在这个激烈的竞争环境下赢得一席之地.1class Observer &#123;&#125; // 我是一家初创公司, Observer是我公司的名字.两人见面直奔主题.‘你可以派些人来, 我给他们做培训. ’, Subject如此说道. Observer点头同意.‘可是我如何才能让他们服从并执行呢?’, Subject问到. ‘我们可以向你提供统一的对接方式’, Observer回答到.‘行, 谁要有兴趣谁就过来吧’12345678/* update是我们的对接方式, fn是我们的职能.只需要走update这个流程, 我们会各司其职.下面这是个我们的模子, 每个走出去的人都大体这样.*/class Observer &#123; constructor(fn) &#123; this.update = fn &#125;&#125;为了后续的开展, 夜曉宸也做了准备. 为随后要来的人腾出了空间, 并想好了如何接待每个人.12345678class Subject &#123; constructor() &#123; this.observesList = []; // 这里是为参与者腾出的空间. &#125; addObserver(observer) &#123; this.observerList.push(observer); // 招待每一个参与者, 就是引导参与者进入腾出的空间. &#125;&#125;不日, Observer派人带着各自本职职务过来了.123const observer1 = new Observer(() =&gt; &#123;document.write(`$&#123;order&#125;: 我是财务, 我要开始算绩效发工资了&lt;br/&gt;`));const observer2 = new Observer(() =&gt; &#123;document.write(`$&#123;order&#125;: 我是后勤客服, 有什么事情需要帮助的?&lt;br/&gt;`));const observer3 = new Observer(() =&gt; &#123;document.write(`$&#123;order&#125;: 我是人事, 我要招人了&lt;br/&gt;`));既然人来了, 那就接待.1234const subject = new Subject(); // 事务繁忙, 派了一个影分身.subject.addObserver(observer1); // 引导observer1进入房间.subject.addObserver(observer2); // 引导observer2进入房间.subject.addObserver(observer3); // // 引导observer3进入房间.‘既然来到了这个房间, 就要明确一点, 那就是你们得听我指令, 到时我会使用你们公司统一的对接方式’1234567class Subject &#123; // 省略 notify(context) &#123; // 由公司提供的统一对接方式，向在场的每一个Observer传达并让其执行. this.observerList.forEach(observer =&gt; observer.update(context)); &#125;&#125;‘如果你们不想呆下去了, 可以和我说, 我可以引导你们出去’12345678class Subject &#123; // 省略 removeObserver(observer) &#123; // 对于不再感兴趣的Observer，可以将其剔除，其不会再收到任何来自Subject的通知. let pos = this.observerList.indexOf(observer); this.observerList.splice(pos, 1); &#125;&#125;‘现在, 要下达指令了!’12// 省略subject.notify('描述下各自的职能');‘好了, 这些就是我们培训的内容, 就是这么简单’‘就这么简单?!?, 既然这样, 就送我出去吧, 我不想再呆下去了 ’, observer2说到.12// 省略subject.removeObserver(observer2);到此故事告一段落了, Observer模式在线Demo.再看观察者模式我们从几段对话中, 稀里糊涂的完成了本文开头观察者模式所定义的那样. 有负责管理一系列依赖的对象, 有提供更新接口的对象. 我们可以看到, 当subject1发出通知时, 每个observe都能去执行. observer们的行为依赖于subject1的. 为什么能够做到这一点, 那是因为observe们的行为作为自身的一部分寄存在了subject1, subject1就可以在需要的时候去自己腾出的小屋子里通知observer们执行.如果subject1 带着这么一波参加过培训的observer们回去交差, 肯定会被笑话. subject1和observer们的这种协作方式, 被称做观察者模式. 这不过是一个模式, 何时存储何种东西, 何时又去执行存储的东西那才是关键. 如果放到上面的小故事里, 那就是何时需要何种人, 何时开始去做事, 这都需要审时度势. 只有这样公司才能在激烈的竞争环境中赢得一席之地. 只有这样, 观察者模式才能发挥它最大的作用.]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>观察者模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Array实例之迭代方法]]></title>
    <url>%2FArray%E5%AE%9E%E4%BE%8B%E4%B9%8B%E8%BF%AD%E4%BB%A3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[ArrayArray对象是用于构造数组的全局对象.概述数组对象是一个有序的数据(原始类型或对象类型)集合, 是一种类列表对象,它的原型提供了数组操作的方法.数组只能用整数作为数组元素的索引,而不是字符串,且从0开始,第一个元素的索引为0.使用非整数并通过[]或.来访问数组或设置数组元素时,所操作的并不是数组列表的元素,而是数组对象属性集合上的变量.数组对象的属性和数组元素列表是分开存储的,并且数组的遍历和修改操作也不能作用于这些命名属性.123456var arr = [];arr['zero'] = 'zero';arr[0] = 0;arr.forEach(item =&gt; console.log(item))// 0实例方法迭代方法Array.prototype.forEach()语法array.forEach(callback(currentValue[, index[, array]]){ // do something }[, thisArg])callback : 数组中每个元素都会执行的回调函数.currentValue : 数组中正在被处理的当前元素.index : 数组中正在被处理的当前元素的索引.array : 调用该方法的数组.thisArg : 执行回调函数时this对应的对象. 如果省略了 thisArg 参数, 或者赋值为 null 或 undefined, 则 this 指向全局对象.返回值123456789101112let obj = &#123;name: 'obj'&#125;;let arr0 = [3, 2, 1];let arr00 = arr0.forEach(function(currentValue, index, array)&#123; console.log('arr0:', arr0,'currentValue:', currentValue, 'index:', index, 'array:', array, 'thisArg:', this);&#125;, obj);console.log('arr00:', arr00);// arr0: [ 3, 2, 1 ] currentValue: 3 index: 0 array: [ 3, 2, 1 ] thisArg: &#123;name: 'obj' &#125;;// arr0: [ 3, 2, 1 ] currentValue: 2 index: 1 array: [ 3, 2, 1 ] thisArg: &#123;name: 'obj' &#125;;// arr0: [ 3, 2, 1 ] currentValue: 1 index: 2 array: [ 3, 2, 1 ] thisArg: &#123;name: 'obj' &#125;;// arr00: undefined;Array.prototype.map()语法array.map(callback(currentValue[, index[, array]]){ // do something }[, thisArg])callback : 数组中每个元素都会执行的回调函数.currentValue : 数组中正在被处理的当前元素.index : 数组中正在被处理的当前元素的索引.array : 调用该方法的数组.thisArg : 执行回调函数时this对应的对象. 如果省略了 thisArg 参数, 或者赋值为 null 或 undefined, 则 this 指向全局对象.返回值 : 由每个数组元素调用callback后的返回值组成的新数组.1234567891011121314let obj = &#123;name: 'obj'&#125;;let arr0 = [3, 2, 1];let arr00 = arr0.map(function(currentValue, index, array)&#123; let newVal = currentValue * 2; console.log('arr0:', arr0, 'currentValue:', currentValue, 'index:', index, 'array:', array, 'newVal:', newVal, 'thisArg:', this); return newVal;&#125;, obj);console.log('arr00:', arr00);// arr0: [ 3, 2, 1 ] currentValue: 3 index: 0 array: [ 3, 2, 1 ] newVal: 6 thisArg: &#123; name: 'obj' &#125;;// arr0: [ 3, 2, 1 ] currentValue: 2 index: 1 array: [ 3, 2, 1 ] newVal: 4 thisArg: &#123; name: 'obj' &#125;;// arr0: [ 3, 2, 1 ] currentValue: 1 index: 2 array: [ 3, 2, 1 ] newVal: 2 thisArg: &#123; name: 'obj' &#125;;// arr00: [ 6, 4, 2 ]Array.prototype.every()语法array.every(callback(currentValue[, index[, array]]){ // do something }[, thisArg])callback : 数组中每个元素都会执行的回调函数.currentValue : 数组中正在被处理的当前元素.index : 数组中正在被处理的当前元素的索引.array : 调用该方法的数组.thisArg : 执行回调函数时this对应的对象. 如果省略了 thisArg 参数, 或者赋值为 null 或 undefined, 则 this 指向全局对象.返回值 : 布尔值. 由数组中每个元素调用callback后, 当所有的元素都符合条件(真值)才返回true. 否则, 返回false. 另外, 对于放在空数组上的任何条件, 此方法返回 true.1234567891011121314151617181920212223242526272829303132let obj = &#123; name: 'obj'&#125;let arr0 = [3, 2, 1];let arr00 = arr0.every(function(currentValue, index, array)&#123; let newVal = currentValue * 3; console.log('arr0:', arr0, 'currentValue:', currentValue, 'index:', index, 'array:', array, 'newVal:', newVal, 'thisArg:', this); return newVal &gt; 2;&#125;, obj)console.log('arr00:', arr00);// arr0: [ 3, 2, 1 ] currentValue: 3 index: 0 array: [ 3, 2, 1 ] newVal: 9 thisArg: &#123; name: 'obj' &#125;// arr0: [ 3, 2, 1 ] currentValue: 2 index: 1 array: [ 3, 2, 1 ] newVal: 6 thisArg: &#123; name: 'obj' &#125;// arr0: [ 3, 2, 1 ] currentValue: 1 index: 2 array: [ 3, 2, 1 ] newVal: 3 thisArg: &#123; name: 'obj' &#125;// arr00: true;let obj = &#123; name: 'obj'&#125;let arr0 = [3, 2, 1];let arr00 = arr0.every(function(currentValue, index, array)&#123; let newVal = currentValue * 3; console.log('arr0:', arr0, 'currentValue:', currentValue, 'index:', index, 'array:', array, 'newVal:', newVal, 'thisArg:', this); return newVal &gt; 6;&#125;, obj)console.log('arr00:', arr00);// arr0: [ 3, 2, 1 ] currentValue: 3 index: 0 array: [ 3, 2, 1 ] newVal: 9 thisArg: &#123; name: 'obj' &#125;;// arr0: [ 3, 2, 1 ] currentValue: 2 index: 1 array: [ 3, 2, 1 ] newVal: 6 thisArg: &#123; name: 'obj' &#125;;// arr00: false;Array.prototype.some()语法array.some(callback(currentValue[, index[, array]]){ // do something }[, thisArg])callback : 数组中每个元素都会执行的回调函数.currentValue : 数组中正在被处理的当前元素.index : 数组中正在被处理的当前元素的索引.array : 调用该方法的数组.返回值 : 布尔值. 由数组中每个元素调用callback后, 当有元素符合条件(真值)就返回true. 否则, 返回false. 另外, 对于放在空数组上的任何条件, 此方法返回 false.12345678910111213141516171819202122232425262728293031let obj = &#123; name: 'obj'&#125;let arr0 = [3, 2, 1];let arr00 = arr0.some(function(currentValue, index, array)&#123; let newVal = currentValue * 3; console.log('arr0:', arr0, 'currentValue:', currentValue, 'index:', index, 'array:', array, 'newVal:', newVal, 'thisArg:', this); return newVal &gt; 6;&#125;, obj)console.log('arr00:', arr00);// arr0: [ 3, 2, 1 ] currentValue: 3 index: 0 array: [ 3, 2, 1 ] newVal: 9 thisArg: &#123; name: 'obj' &#125;;// arr00: true;let obj = &#123; name: 'obj'&#125;let arr0 = [3, 2, 1];let arr00 = arr0.some(function(currentValue, index, array)&#123; let newVal = currentValue * 3; console.log('arr0:', arr0, 'currentValue:', currentValue, 'index:', index, 'array:', array, 'newVal:', newVal, 'thisArg:', this); return newVal &gt; 9;&#125;, obj)console.log('arr00:', arr00);// arr0: [ 3, 2, 1 ] currentValue: 3 index: 0 array: [ 3, 2, 1 ] newVal: 9 thisArg: &#123; name: 'obj' &#125;;// arr0: [ 3, 2, 1 ] currentValue: 2 index: 1 array: [ 3, 2, 1 ] newVal: 6 thisArg: &#123; name: 'obj' &#125;;// arr0: [ 3, 2, 1 ] currentValue: 1 index: 2 array: [ 3, 2, 1 ] newVal: 3 thisArg: &#123; name: 'obj' &#125;;// arr00: false;Array.prototype.filter()语法arr.filter(callback(currentValue[, index[, array]])[, thisArg])callback : 数组中每个元素都会执行的回调函数.currentValue : 数组中正在被处理的当前元素.index : 数组中正在被处理的当前元素的索引.array : 调用该方法的数组.返回值 : 数组中每个元素调用callback后, 由符合条件的数组元素组成的新数组.如果没有符合条件的元素, 则返回空数组.12345678910111213141516let obj = &#123; name: 'obj'&#125;let arr0 = [3, 2, 1];let arr00 = arr0.filter(function(currentValue, index, array)&#123; let boolean = currentValue &gt; 1 ? true : false; console.log('arr0:', arr0, 'currentValue:', currentValue, 'index:', index, 'array:', array, 'thisArg:', this); return boolean;&#125;, obj)console.log('arr00:', arr00);// arr0: [ 3, 2, 1 ] currentValue: 3 index: 0 array: [ 3, 2, 1 ] thisArg: &#123; name: 'obj' &#125;// arr0: [ 3, 2, 1 ] currentValue: 2 index: 1 array: [ 3, 2, 1 ] thisArg: &#123; name: 'obj' &#125;//arr0: [ 3, 2, 1 ] currentValue: 1 index: 2 array: [ 3, 2, 1 ] thisArg: &#123; name: 'obj' &#125;// arr00: [ 3, 2 ];Array.prototype.find()语法arr.find(callback(currentValue[, index[, array]])[, thisArg])callback : 数组中每个元素都会执行的回调函数.currentValue : 数组中正在被处理的当前元素.index : 数组中正在被处理的当前元素的索引.array : 调用该方法的数组.返回值 : 数组中每个元素调用callback后, 返回第一个符合条件的元素. 否则返回 undefined.1234567891011121314let obj = &#123; name: 'obj'&#125;let arr0 = [3, 2, 1];let arr00 = arr0.find(function(currentValue, index, array)&#123; let boolean = currentValue &gt; 1 ? true : false; console.log('arr0:', arr0, 'currentValue:', currentValue, 'index:', index, 'array:', array, 'thisArg:', this); return boolean;&#125;, obj)console.log('arr00:', arr00);// arr0: [ 3, 2, 1 ] currentValue: 3 index: 0 array: [ 3, 2, 1 ] thisArg: &#123; name: 'obj' &#125;;// arr00: 3;Array.prototype.findIndex()语法arr.findIndex(callback(currentValue[, index[, array]])[, thisArg])callback : 数组中每个元素都会执行的回调函数.currentValue : 数组中正在被处理的当前元素.index : 数组中正在被处理的当前元素的索引.array : 调用该方法的数组.返回值 : 数组中每个元素调用callback后, 返回第一个符合条件的元素索引. 否则返回 -1.1234567891011121314let obj = &#123; name: 'obj'&#125;let arr0 = [3, 2, 1];let arr00 = arr0.findIndex(function(currentValue, index, array)&#123; let boolean = currentValue &gt; 1 ? true : false; console.log('arr0:', arr0, 'currentValue:', currentValue, 'index:', index, 'array:', array, 'thisArg:', this); return boolean;&#125;, obj)console.log('arr00:', arr00);// arr0: [ 3, 2, 1 ] currentValue: 3 index: 0 array: [ 3, 2, 1 ] thisArg: &#123; name: 'obj' &#125;;// arr00: 0;Array.prototype.reduce()语法arr.reduce(callback(accumulator[, currentValue[, index[, array]]])[, initialValue])callback : 数组中每个元素都会执行的回调函数.accumulator : 上一个元素调用回调函数后的返回值. 回调函数第一次执行时, 若提供了initialValue,则accumulator取值为initialValue. 若没有提供initialValue, 则accumulator取值为数组中第一个元素.currentValue : 数组中正在被处理的当前元素. 回调函数第一次执行时, 若提供了initialValue, 则currentValue取值为数组中第一个元素. 若没有提供initialValue, 则currentValue取值为数组中第二值.index : 数组中正在被处理的当前元素的索引.array : 调用该方法的数组.返回值 : 数组中每个元素调用callback后, 将上一次回调函数执行结果作为下一次回调函数参数, 并最终返回单个结果值.1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253let arr0 = [3, 2, 1];let arr00 = arr0.reduce(function(accumulator, currentValue, index, array) &#123; console.log('arr0', arr0, 'accumulator:', accumulator, 'currentValue:', currentValue, 'index:', index, 'array:', array); return accumulator + currentValue;&#125;, 0);console.log('arr00:', arr00);// arr0 [ 3, 2, 1 ] accumulator: 0 currentValue: 3 index: 0 array: [ 3, 2, 1 ];// arr0 [ 3, 2, 1 ] accumulator: 3 currentValue: 2 index: 1 array: [ 3, 2, 1 ];// arr0 [ 3, 2, 1 ] accumulator: 5 currentValue: 1 index: 2 array: [ 3, 2, 1 ];// arr00: 6;let arr0 = [3, 2, 1];let arr00 = arr0.reduce(function(accumulator, currentValue, index, array) &#123; console.log('arr0', arr0, 'accumulator:', accumulator, 'currentValue:', currentValue, 'index:', index, 'array:', array); return accumulator + currentValue;&#125;);console.log('arr00:', arr00);// arr0 [ 3, 2, 1 ] accumulator: 3 currentValue: 2 index: 1 array: [ 3, 2, 1 ];// arr0 [ 3, 2, 1 ] accumulator: 5 currentValue: 1 index: 2 array: [ 3, 2, 1 ];// arr00: 6;let arr0 = [1, 2, 3, 44, 5, 3, 2, 53, 1, 2, 3, 5, 44, 53, 55];const reducer = (accumulator, currentValue) =&gt; &#123; console.log('arr0', arr0, 'accumulator', accumulator, 'currentValue', currentValue); if (accumulator.length === 0 || accumulator[accumulator.length - 1] !== currentValue) &#123; accumulator.push(currentValue); &#125; return accumulator;&#125;;let arr00 = arr0.sort((a, b) =&gt; &#123;return a - b&#125;).reduce(reducer, []);console.log('arr00:', arr00);// arr0 [ 1, 1, 2, 2, 2, 3, 3, 3, 5, 5, 44, 44, 53, 53, 55 ] accumulator [] currentValue 1;// arr0 [ 1, 1, 2, 2, 2, 3, 3, 3, 5, 5, 44, 44, 53, 53, 55 ] accumulator [ 1 ] currentValue 1;// arr0 [ 1, 1, 2, 2, 2, 3, 3, 3, 5, 5, 44, 44, 53, 53, 55 ] accumulator [ 1 ] currentValue 2;// arr0 [ 1, 1, 2, 2, 2, 3, 3, 3, 5, 5, 44, 44, 53, 53, 55 ] accumulator [ 1, 2 ] currentValue 2;// arr0 [ 1, 1, 2, 2, 2, 3, 3, 3, 5, 5, 44, 44, 53, 53, 55 ] accumulator [ 1, 2 ] currentValue 2;// arr0 [ 1, 1, 2, 2, 2, 3, 3, 3, 5, 5, 44, 44, 53, 53, 55 ] accumulator [ 1, 2 ] currentValue 3;// arr0 [ 1, 1, 2, 2, 2, 3, 3, 3, 5, 5, 44, 44, 53, 53, 55 ] accumulator [ 1, 2, 3 ] currentValue 3;// arr0 [ 1, 1, 2, 2, 2, 3, 3, 3, 5, 5, 44, 44, 53, 53, 55 ] accumulator [ 1, 2, 3 ] currentValue 3;// arr0 [ 1, 1, 2, 2, 2, 3, 3, 3, 5, 5, 44, 44, 53, 53, 55 ] accumulator [ 1, 2, 3 ] currentValue 5;// arr0 [ 1, 1, 2, 2, 2, 3, 3, 3, 5, 5, 44, 44, 53, 53, 55 ] accumulator [ 1, 2, 3, 5 ] currentValue 5;// arr0 [ 1, 1, 2, 2, 2, 3, 3, 3, 5, 5, 44, 44, 53, 53, 55 ] accumulator [ 1, 2, 3, 5 ] currentValue 44;// arr0 [ 1, 1, 2, 2, 2, 3, 3, 3, 5, 5, 44, 44, 53, 53, 55 ] accumulator [ 1, 2, 3, 5, 44 ] currentValue 44;// arr0 [ 1, 1, 2, 2, 2, 3, 3, 3, 5, 5, 44, 44, 53, 53, 55 ] accumulator [ 1, 2, 3, 5, 44 ] currentValue 53;// arr0 [ 1, 1, 2, 2, 2, 3, 3, 3, 5, 5, 44, 44, 53, 53, 55 ] accumulator [ 1, 2, 3, 5, 44, 53 ] currentValue 53;// arr0 [ 1, 1, 2, 2, 2, 3, 3, 3, 5, 5, 44, 44, 53, 53, 55 ] accumulator [ 1, 2, 3, 5, 44, 53 ] currentValue 55;// arr00: [ 1, 2, 3, 5, 44, 53, 55 ];Array.prototype.reduceRight()语法(从右向左遍历,见reduce)arr.reduceRight(callback(accumulator[, currentValue[, index[, array]]])[, initialValue])Array.prototype.entries()语法arr.entries()返回值 : 一个新的包含数组中每个索引的键/值对的Array Iterator对象.1234567891011121314151617181920212223242526272829303132333435let arr0 = [3, 2, 1];let arr00 = arr0.entries();let arr000 = arr00.next();let arr0000 = arr000.value;console.log('arr00:', arr00);console.log('arr000:', arr000);console.log('arr0000:', arr0000);// arr00;// Array Iterator &#123;&#125;// __proto__: Array Iterator// next: ƒ next()// Symbol(Symbol.toStringTag): "Array Iterator"// arr000;// &#123;value: Array(2), done: false&#125;j;// arr0000;// [0, 3];let arr0 = [3, 2, 1];let arr00 = arr0.entries();for(let item of arr00) &#123; console.log(item);&#125;// [ 0, 3 ];// [ 1, 2 ];// [ 2, 1 ];let arr0 = [3, 2, 1];let arr00 = [...arr0.entries()];console.log('arr00:', arr00);// arr00: [ [ 0, 3 ], [ 1, 2 ], [ 2, 1 ] ]Array.prototype.keys()语法arr.keys()返回值 : 一个新的包含数组中每个索引键的Array Iterator对象.123456789101112131415let arr0 = [3, 2, 1];let arr00 = arr0.keys();for(let item of arr00) &#123; console.log(item);&#125;// 0// 1// 2let arr0 = [3, 2, 1];let arr00 = [...arr0.keys()];console.log('arr00:', arr00);// arr00: [ 0, 1, 2 ];Array.prototype.values()语法arr.values()返回值 : 一个新的包含数组每个索引对应值的 Array Iterator 对象.1234567891011121314let arr0 = [3, 2, 1];let arr00 = arr0.keys();for(let item of arr00) &#123; console.log(item);&#125;// 0// 1// 2let arr0 = [3, 2, 1];let arr00 = [...arr0.keys()];console.log('arr00:', arr00);// arr00: [ 0, 1, 2 ];]]></content>
      <categories>
        <category>数组总结</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>数组实例</tag>
        <tag>迭代方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Array实例之非变异方法]]></title>
    <url>%2FArray%E5%AE%9E%E4%BE%8B%E4%B9%8B%E9%9D%9E%E5%8F%98%E5%BC%82%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[ArrayArray对象是用于构造数组的全局对象.概述数组对象是一个有序的数据(原始类型或对象类型)集合, 是一种类列表对象,它的原型提供了数组操作的方法.数组只能用整数作为数组元素的索引,而不是字符串,且从0开始,第一个元素的索引为0.使用非整数并通过[]或.来访问数组或设置数组元素时,所操作的并不是数组列表的元素,而是数组对象属性集合上的变量.数组对象的属性和数组元素列表是分开存储的,并且数组的遍历和修改操作也不能作用于这些命名属性.123456var arr = [];arr['zero'] = 'zero';arr[0] = 0;arr.forEach(item =&gt; console.log(item))// 0实例方法非变异方法Array.prototype.slice()描述浅拷贝数组指定区域的元素.语法arr.slice(begin[, end])begin(可选) : 起始索引, 默认值为0. 如果是负数, 则开始索引会被自动计算成为 this.length + start.end : 终止索引, 默认值 this.length. 不包括end位置. 如果是负数时, 规则如上.返回值 : 返回截取的新数组(浅复制).1234567891011let arr0 = [3, 2, 1];let arr00 = arr0.slice();console.log('arr0:', arr0, 'arr00:', arr00);// arr0: [ 3, 2, 1 ] arr00: [ 3, 2, 1 ]let arr1 = [5, 4, 3, 2, 1];let arr11 = arr1.slice(2, 3);console.log('arr1:', arr1, 'arr11:', arr11);// arr1: [ 5, 4, 3, 2, 1 ] arr11: [ 3 ].Array.prototype.concat()描述合并多个值或数组.语法array.concat(element0[, element1[, ...[, elementN]]])elementN : 将要连接的值或数组.返回值12345678910111213let arr0 = [6, 5, 4];let arr1 = [3, 2, 1];let arr = arr0.concat(arr1);console.log('arr0:', arr0, 'arr1:', arr1, 'arr:', arr);// arr0: [ 6, 5, 4 ] arr1: [ 3, 2, 1 ] arr: [ 6, 5, 4, 3, 2, 1 ]let arr2 = [6, 5, 4];let arr3 = [2, 1];let arr = arr2.concat(3, arr3);console.log('arr2: ', arr2, 'arr3: ', arr3, 'arr', arr);// arr2: [ 6, 5, 4 ] arr3: [ 2, 1 ] arr [ 6, 5, 4, 3, 2, 1 ]Array.prototype.join()描述将数组众元素用指定字符连接成字符串.语法arr.join(connector)connector : 指定一个字符链接数组中的每个元素, 默认逗号连接.返回值 : 用指定连接符将数组中元素连接起来的字符串.1234567let arr0 = [3, 2, 1];let str1 = arr0.join();let str2 = arr0.join('');let str3 = arr0.join('-');console.log('arr0:', arr0, 'str1:', str1, 'str2:', str2, 'str3:', str3);// arr0: [ 3, 2, 1 ] str1: 3,2,1 str2: 321 str3: 3-2-1;Array.prototype.toString()描述用字符串形式表示数组元素.语法arr.toString()返回值 : 逗号连接数组元素组成的字符串. 当数组元素为数组时, 自动调用其toString()方法.123456let arr0 = [3, 2, 1];let arr00 = arr0.toString();let arr1 = [[6, [5, 4]], 3, 2, 1].toString();console.log('arr0:', arr0, 'arr00:', arr00, 'arr1:', arr1);// arr0: [ 3, 2, 1 ] arr00: 3,2,1 arr1: 6,5,4,3,2,1;Array.prototype.includes()描述判断数组中是否指定值.语法arr.includes(searchElement[, fromIndex])searchElement : 需要查询的值.fromIndex : 起始索引, 默认值为0. 如果是负数时, 规则如上.返回值 : 布尔值.123456let arr0 = [3, 2, 1];let a = arr0.includes(3);let b = arr0.includes(3, 1);console.log('arr0', arr0, 'a:', a, 'b:', b);// arr0 [ 3, 2, 1 ] a: true b: false;Array.prototype.indexOf()描述查询指定元素在数组中首次出现的索引位置.语法arr.indexOf(searchElement[, fromIndex])searchElement : 需要查询的值.fromIndex : 起始索引, 默认值为0. 如果是负数时, 规则如上.返回值 : 首次被找到的元素在数组中的索引位置; 若没有找到则返回 -1.123456let arr0 = [3, 2, 1];let a = arr0.indexOf(1);let b = arr0.indexOf(3, 1);console.log('arr0:', arr0, 'a:', a, 'b:', b);// arr0: [ 3, 2, 1 ] a: 2 b: -1;Array.prototype.lastIndexOf()描述从数组的后面向前查找, 查询指定元素在数组中首次出现的索引位置.语法arr.lastIndexOf(searchElement[, fromIndex = arr.length - 1])searchElement : 需要查询的值.fromIndex : 逆向查找起始索引, 默认值 this.length - 1.返回值 : 逆向首次被找到的元素在数组中的索引位置.123456let arr0 = [3, 2, 1];let a = arr0.lastIndexOf(1);let b = arr0.lastIndexOf(3, 1);console.log('arr0:', arr0, 'a:', a, 'b:', b);// arr0: [ 3, 2, 1 ] a: 2 b: 0;]]></content>
      <categories>
        <category>数组总结</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>数组实例</tag>
        <tag>非变异方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Array实例之变异方法]]></title>
    <url>%2FArray%E5%AE%9E%E4%BE%8B%E4%B9%8B%E5%8F%98%E5%BC%82%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[ArrayArray对象是用于构造数组的全局对象.概述数组对象是一个有序的数据(原始类型或对象类型)集合, 是一种类列表对象,它的原型提供了数组操作的方法.数组只能用整数作为数组元素的索引,而不是字符串,且从0开始,第一个元素的索引为0.使用非整数并通过[]或.来访问数组或设置数组元素时,所操作的并不是数组列表的元素,而是数组对象属性集合上的变量.数组对象的属性和数组元素列表是分开存储的,并且数组的遍历和修改操作也不能作用于这些命名属性.123456var arr = [];arr['zero'] = 'zero';arr[0] = 0;arr.forEach(item =&gt; console.log(item))// 0实例方法变异方法Array.prototype.push()描述在数组末尾添加一个或多个元素.语法arr.push(element0 ..., elementN)elementN : 将要添加到数组末尾的元素.返回值 : 被改动后的原数组的length值, 且原数组被改变.12345let arr0 = [3, 2, 1];let arr0Len = arr0.push('Array');console.log('arr0:', arr0, 'arr0Len:', arr0Len);// arr0: [3, 2, 1, 'Array'] arr0Len: 4;Array.prototype.unshift()描述在数组开头添加一个或多个元素.语法arr.unshift(element1, ..., elementN)elementN : 将要添加到数组开头的元素.返回值 : 被改动后的原数组的length值, 且原数组被改变.12345let arr0 = [3, 2, 1];let arr0Len = arr0.unshift('Array');console.log('arr0:', arr0, 'arr0Len:', arr0Len);// arr0: ['Array', 3, 2, 1] arr0Len: 4;Array.prototype.pop()描述从数组中删除最后一个元素.语法arr.pop()返回值 : 被删除的数组元素(空属组调用, 则返回undefined), 且原数组被改变.12345let arr0 = [3, 2, 1];let ele = arr0.pop();console.log('arr0:', arr0, 'ele:', ele);// arr0: [3, 2] ele: 1;Array.prototype.shift()描述从数组中删除第一个元素.语法arr.shift()返回值 : 被删除的数组元素(空属组调用, 则返回undefined), 且原数组被改变.12345let arr0 = [3, 2, 1];let ele = arr0.shift();console.log('arr0:', arr0, 'ele:', ele);// arr0: [2, 1] ele: 3;Array.prototype.splice()描述从数组中删除指定数量的元素并添加向数组添加元素.语法array.splice(start[, deleteCount[, element1[, ...[, elementN]]]])start : 指定修改位置(从0计数).deleteCount 要移除的数组元素个数. 默认值为 this.length - start.elementN : 要添加的数组元素.返回值 : 由被删除的元素组成的数组, 且原数组被改变.1234567891011121314151617181920212223let arr0 = [3, 2, 1];let arr00 = arr0.splice(2, 0, 4, 5, 6);console.log('arr0:', arr0, 'arr00:', arr00);// arr0: [3, 2, 4, 5, 6, 1] arr00: [];let arr1 = [3, 2, 1];let arr11 = arr1.splice(2, 1, 4, 5, 6);console.log('arr1:', arr1, 'arr11:', arr11);// arr1: [3, 2, 4, 5, 6] arr11: [1];let arr3 = [3, 2, 1];let arr33 = arr3.splice(1, 2);console.log('arr3:', arr3, 'arr33:', arr33);// arr3: [3] arr33: [2, 1];let arr4 = [3, 2, 1];let arr44 = arr4.splice(3, 0 , 4, 5, 6);console.log('arr4:', arr4, 'arr44:', arr44);// arr4: [3, 2, 1, 4, 5, 6] arr44: [];Array.prototype.sort()描述用原地算法对数组的元素进行排序.语法arr.sort([compareFunction])compareFunction : 用来指定按某种顺序进行排列的函数. 如果省略, 元素按照转换为的字符串的各个字符的Unicode位点进行排序. 指明了 compareFunction, 那么数组会按照调用该函数的返回值排序. a 和 b 是两个将要被比较的元素:compareFunction(a, b) 小于 0, 那么 a 会被排列到 b 之前;compareFunction(a, b) 等于 0, a 和 b 的相对位置不变;compareFunction(a, b) 大于 0, b 会被排列到 a 之前;返回值 : 排序后的数组.12345let arr0 = [3, 4, 2, 5, 1];let arr00 = arr0.sort((a, b) =&gt; a-b);console.log('arr0:', arr0, 'arr00:', arr00);// arr0:, [1, 2, 3, 4, 5] arr00: [1, 2, 3, 4, 5];Array.prototype.reverse()描述将数组中元素的位置颠倒.语法arr.reverse()返回值 : 位置颠倒后的数组.12345let arr0 = [3, 2, 1];let arr00 = arr0.reverse();console.log('arr0:', arr0, 'arr00:', arr00);// arr0: [1, 2, 3] arr00: [1, 2, 3];Array.prototype.copyWithin()描述将数组的某一部分浅复制到指定位置.语法arr.copyWithin(target[, start[, end]])target : 索引起始为0. 被复制的内容将要替换的位置. 如果是负数, target将从 this.length + target开始计算.start : 起始索引, 默认值为0. 被复制内容的起始位置, 包括start位置的元素. 如果是负数, 则开始索引会被自动计算成为 this.length + start.end : 终止索引, 默认值为this .length, 索引起始为0. 被复制内容的结束位置, 但不包括end位置的元素. 如果是负数. 则终止索引会被自动计算成为 this.length + end.返回值 : 被改动后的原数组. 数组内容变化, 长度不变.1234567891011121314151617let arr0 = [3, 2, 1];let arr00 = arr0.copyWithin(2, 0);console.log('arr0:', arr0, 'arr00:', arr00);//arr0: [3, 2, 3] arr00: [3, 2, 3];let arr1 = [3, 2, 1];let arr11 = arr1.copyWithin(2, 1, 2);console.log('arr1:', arr1, 'arr11:', arr11);// arr1: [3, 2, 2] arr11: [3, 2, 2];let arr2 = [3, 2, 1];let arr22 = arr2.copyWithin(-1, -2, -1);console.log('arr2', arr2, 'arr22', arr22);// arr1: [3, 2, 2] arr11: [3, 2, 2];Array.prototype.fill()描述将数组的某一区域的全部元素用指定值替换.语法arr.fill(value[, start[, end]])value : 填充数组的参数值.start : 起始索引, 默认值为 0. 如果是负数时, 规则如上.end : 终止索引, 默认值为 this.length. 不包括end位置. 如果是负数时, 规则如上.返回值 : 被改动后的原数组.1234567891011let arr0 = [3, 2, 1];let arr00 = arr0.fill(3);console.log('arr0:', arr0, 'arr00:', arr00);// arr0: [3, 3, 3] arr00: [3, 3, 3];let arr1 = [3, 2, 1];let arr11 = arr1.fill(3, 1);console.log('arr1:', arr1, 'arr11:', arr11);// arr1: [3, 3, 3] arr11: [3, 3, 3]]]></content>
      <categories>
        <category>数组总结</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>数组实例</tag>
        <tag>变异方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Array构造函数]]></title>
    <url>%2FArray%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[ArrayArray对象是用于构造数组的全局对象.概述数组对象是一个有序的数据(原始类型或对象类型)集合, 是一种类列表对象,它的原型提供了数组操作的方法.数组只能用整数作为数组元素的索引,而不是字符串,且从0开始,第一个元素的索引为0.使用非整数并通过[]或.来访问数组或设置数组元素时,所操作的并不是数组列表的元素,而是数组对象属性集合上的变量.数组对象的属性和数组元素列表是分开存储的,并且数组的遍历和修改操作也不能作用于这些命名属性.123456var arr = [];arr['zero'] = 'zero';arr[0] = 0;arr.forEach(item =&gt; console.log(item))// 0构造函数属性Array.length构造函数的length属性,该属性为静态属性(详见Function.length),不是数组实例的length属性,其值为1.123console.log(Array.length);// 1Array.prototype构造函数的原型对象,所有的数组实例都会从Array.prototype继承属性和方法.通过扩展Array原型上的属性和方法进而为所有的数组实例增加属性和方法.123456789101112Array.prototype.type = "Array";Array.prototype.first = function() &#123; return this[0];&#125;;var arr = [3, 2, 1];arr.type;// Array;arr.first();// 3;构造函数方法Array.from()描述从一个类似数组或可迭代对象中创建一个新的数组实例.语法Array.from(arrayLike[, mapFn[, thisArg]])ArrrayLike : 伪数组对象(拥有length属性和若干索引属性) 和 可迭代对象.mapFn : 返回的新数组都会执行的回调函数.thisArg : 执行回调函数时this对应的对象.返回值 : 新的数组实例.123456789101112131415161718Array.from('Array');// ["A", "r", "r", "a", "y"];(function () &#123; return Array.from(arguments);&#125;)(3, 2, 1)// [3, 2, 1];let s = new Set(['array', Array]);Array.from(s);// ["array", function];Array.from([3, 2, 1], x =&gt; x.toString());// ["3", "2", "1"];Array.isArray()描述判断待验证的参数是否为Array.语法Array.isArray(obj)obj : 待验证参数.返回值 : 若待验证参数为数组时,则为true; 否则false.123456789101112131415161718Array.isArray([]);// true;Array.isArray(&#123;&#125;);// false;Array.isArray(Array.prototype);// true;// Polyfillif (!Array.isArray) &#123; Array.isArray = function(arg) &#123; return Object.prototype.toString.call(arg) === '[object Array]'; &#125;;&#125;;Array.of()描述创建一个由传入参数组成的新数组实例, 而不考虑参数的数量或类型.语法Array.of(element0[, element1[, ...[, elementN]]])elementN : 任意个参数,将顺序得成为数组的元素.返回值 : 新的数组实例.123456789101112131415161718Array.of(3);// [3];Array.of(3, 2, 1);// [3, 2, 1];Array.of('Array', Array);// ["Array", function];// Polyfillif (!Array.of) &#123; Array.of = function() &#123; return Array.prototype.slice.call(arguments); &#125;;&#125;]]></content>
      <categories>
        <category>数组总结</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>构造函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器缓存机制]]></title>
    <url>%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[浏览器缓存强缓存释义: 客户端第一次问服务器要某个资源时，服务器丢还给客户端所请求的这个资源同时，告诉客户端将这个资源保存在本地，并且在未来的某个时点之前如果还需要这个资源，直接从本地获取就行了，不用向服务器请求.这种方式缓存下来的资源称为强缓存.Expires &amp; Cache-Control:max-ageExpires:该字段是http1.0时的规范，值为一个绝对时间的GMT格式的时间字符串，代表缓存资源的过期时间，在这个时点之前，即命中缓存.Cache-Control:该字段是http1.0时的规范，值为一个绝对时间的GMT格式的时间字符串，代表缓存资源的过期时间，在这个时点之前，即命中缓存.参数:no-cache: 如果请求头部包含no-cache指令，表示客户端不接收缓存过的响应.中间缓存服务器必须将请求转发给给源服务器. 浏览器强制刷新(window下ctrl+F5)就是这个原理，所以的请求都设置no-cacheno-store: 暗示请求和响应包含机密信息，不能进行缓存.区分: no-store才是真正的不缓存max-age: 该指令用来标识缓存资源的最大有效期. 如果max-age=0，就会向源服务器发送请求进行缓存资源新鲜度的验证.浏览器普通刷新F5“Cache-Control”:” cache-directive”*作为请求首部时，cache-directive 的可选值有:“Cache-Control”:” cache-directive”*作为响应首部时，cache-directive 的可选值有:在请求头中max-age=0与no-cache的区别？返回的状态来看：no-cache都是200，而max-age可能是304（如果浏览器有缓存）. 请求参数：max-age请求头一般会携带If-Modified-Since或If-None-Match字段进行新鲜度验证，而no-cache不会携带. F5刷新是max-age=0来实现，而强制刷新(Ctrl+F5)是通过no-cache实现. 异同: Expires是HTTP 1.0+的首部，用来指定一个绝对的过期日期，依赖客户端时间设置的准确性,缓存时间是相对服务器上的时间而言的.而max-age是HTTP/1.1的Cache-Control的一个字段，用来指定文档的最大使用时间.协商缓存释义: 客户端第一次问服务器要某个资源时，服务器丢还给客户端所请求的这个资源同时，将该资源的一些信息（文件摘要、或者最后修改时间）也返回给客户端，告诉客户端将这个资源缓存在本地.当客户端下一次需要这个资源时，将请求以及相关信息（文件摘要、或者最后修改时间）一并发送给服务器，由服务器来判断客户端缓存的资源是否需要更新：如不需要更新，就直接告诉客户端获取本地缓存资源；如需要更新，则将最新的资源连同相应的信息一并返回给客户端.Last-Modified &amp; If-Modified-Since &amp; Etag &amp; If-None-MatchLast-Modidied &amp; If-Modified-Since:Last-Modified: 为实体首部字段，值为资源最后更新时间，随服务器response返回.If-Modified-Since: 为请求首部字段，通过比较两个时间来判断资源在两次请求期间是否有过修改，如果没有修改，则命中协商缓存，浏览器从缓存中获取资源；如果有过修改，则服务器返回资源，同时返回新的Last-Modified时间.Etag &amp; If-None-Match:Etag: 为相应头部字段，表示资源内容的唯一标识，随服务器response返回.If-None-Match: 为请求头部字段，服务器通过比较请求头部的If-None-Match与当前资源的ETag是否一致来判断资源是否在两次请求之间有过修改，如果没有修改，则命中协商缓存，浏览器从缓存中获取资源；如果有过修改，则服务器返回资源，同时返回新的ETag.不能缓存的请求HTTP信息头中包含Cache-Control:no-cache，pragma:no-cache（HTTP1.0），或Cache-Control:max-age=0等告诉浏览器不用缓存的请求. Cache-Control: no-cache：这个很容易让人产生误解，使人误以为是响应不被缓存.实际上Cache-Control: no-cache是会被缓存的，只不过每次在向客户端（浏览器）提供响应数据时，缓存都要向服务器评估缓存响应的有效性需要根据Cookie，认证信息等决定输入内容的动态请求是不能被缓存的经过HTTPS安全加密的请求（有人也经过测试发现，ie其实在头部加入Cache-Control：max-age信息，firefox在头部加入Cache-Control:Public之后，能够对HTTPS的资源进行缓存，参考《HTTPS的七个误解》）POST请求无法被缓存HTTP响应头中不包含Last-Modified/Etag，也不包含Cache-Control/Expires的请求无法被缓存浏览器缓存机制示意图]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github+Hexo+Next博客搭建之Hexo,Next及部署]]></title>
    <url>%2FGithub-Hexo-Next%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%B9%8BHexo-Next%E5%8F%8A%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[博客已经搭建好了,自然可以趁热打铁写一些博客搭建的经验.一是方便自己以后查看,免得忘记.二是如果有人想了解博客搭建的过程,也正好有个参考.(如果SEO做的好,就有可能看到这篇文章).本文仅记录怎么去搭建博客,而不会解释每一步原理,有些东西我自己都没有搞的太清楚.毕竟我只是想借助博客这个平台记录平时工作的经验而已,细究相关方面知识并不是我的最终目的现在回头看博客的搭建过程,可以总结归纳以下几点. markdown,git和GitHub,github和coding部署, Hexo和Next了解, SEO等Hexo,Next,部署,SEO该博客的搭建用的是Hexo博客框架,详细的说明官方文档都有提到.在主题的选择上用的是Next,对应的也有相关的官方文档.接下来就搭建过程中遇到的简单介绍一下Hexo中基本指令npm install -g hexo-cli // npm安装Hexo, 非Hexo中命令 hexo init &lt;folder&gt; // 指定文件夹下初始化Hexo,若没有设置folder, Hexo默认在目前的文件夹建立网站 cd &lt;folder&gt; // 进入指定文件夹, 非Hexo中命令 npm install // 安装配置文件packge.json中的依赖, 非Hexo中命令 hexo new [layout] &lt;title&gt; // 新建一篇文章.layout默认default_layout参数,标题有空格,需使用引号括起来 hexo generate // 生成静态文件. -d, --deploy 文件生成后立即部署网站.可简写为 hexo g hexo server // 启动服务器.默认情况下网址为:http://loalhost:4000/. -p, --port 重设端口 hexo deploy // 部署网站. -g, --generate 部署之前预先生成静态文件.可简写为 hexo d hexo clean // 清除缓存文件和已生成的静态文件 Hexo部署地址配置打开站点配置文件_config.yml,找到deploy字段,配置如下deploy: - type: git // 以下是我的git地址 repo: git@github.com:yexiaochen/yexiaochen.github.io.git branch: master - type: git // 以下是我的coding地址 repo: git@git.coding.net:yexiaochen/yexiaochen.coding.me.git branch: master 安装Next主题定位到Hexo站点目录下,执行一下命令即可git clone https://github.com/iissnan/hexo-theme-next themes/next 克隆完成后,打开站点配置文件_config.yml,找到theme字段,并将其值更改为next设置菜单页面Next主题有默认的菜单项,部分菜单项需要自己添加.添加菜单项页面新建标签页面在根目录下新建标签页面hexo new page tags 在新建的页面编辑一下内容123456---title: All tagsdate: 2018-03-24 18:02:30type: &quot;tags&quot;comments: false---在主题配置文件_config.yml内, 找到menu字段,添加如下内容123456789menu:home: / || home# about: /about/ || usertags: /tags/ || tagscategories: /categories/ || tharchives: /archives/ || archive# schedule: /schedule/ || calendar# sitemap: /sitemap.xml || sitemap# commonweal: /404/ || heartbeat在菜单项里添加分类项操作同上添加gitment评论 添加gitalk评论远程仓库新建一个repository,名字随意,待会儿会用到添加OAuth Apps.登陆GitHub,通过Settings =&gt; Developer settings =&gt; OAuth Apps,点击New OAuth App.添加后会生成Client ID和Client Secretgitalk和gitment是差不多的产品, 在我们更换评论系统时, 可以在其基础上修改. 在主题配置文件_config.yml内, 找到gitment字段,添加如下内容.12345678910111213gitment: enable: true mint: true # RECOMMEND, A mint on Gitment, to support count, language and proxy_gateway count: true # Show comments count in post meta area lazy: true # Comments lazy loading with a button cleanly: true # Hide &apos;Powered by ...&apos; on footer, and more language: # Force language, or auto switch by theme github_user: yexiaochen # MUST HAVE, Your Github ID 18507780 github_repo: blog-gitment # MUST HAVE, The repo you use to store Gitment comments client_id: your_client_id # MUST HAVE, Github client id for the Gitment client_secret: your_client_secret # EITHER this or proxy_gateway, Github access secret token for the Gitment proxy_gateway: # Address of api proxy, See: https://github.com/aimingoo/intersect redirect_protocol: # Protocol of redirect_uri with force_redirect_protocol when mint enabled在themes/next/layout/_third-party/comments/gitment.swig文件中, 按照gitalk文档里的配置进行修改.123456789const gitalk = new Gitalk(&#123;clientID: 'GitHub Application Client ID',clientSecret: 'GitHub Application Client Secret',repo: 'GitHub repo',owner: 'GitHub repo owner',admin: ['GitHub repo owner and collaborators, only these guys can initialize github issues'],id: location.pathname, // Ensure uniqueness and length less than 50distractionFreeMode: false // Facebook-like distraction free mode&#125;)注意: gitalk 需要GitHub账号登陆才可以创建初始化.部署coding部署到coding和部署到GitHub类似,也是要添加SSH的.新建的项目名称也是要求按照一定的规范来,细节可参考Coding Pages.在Pages服务的设置可参考下图DNS解析设置购买域名后,要对其进行解析设置.因为国外墙的原因,故博客在部署时也选在了不同的平台上.不同的解析路线对应不同的项目URL博客的搭建到此就结束了,其中还是有许多细节没有提到,时间久了已经忘了大部分了]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
        <tag>coding</tag>
        <tag>部署</tag>
        <tag>DNS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github+Hexo+Next博客搭建之git和GitHub]]></title>
    <url>%2FGithub-Hexo-Next%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%B9%8Bgit%E5%92%8C%08GitHub%2F</url>
    <content type="text"><![CDATA[博客已经搭建好了,自然可以趁热打铁写一些博客搭建的经验.一是方便自己以后查看,免得忘记.二是如果有人想了解博客搭建的过程,也正好有个参考.(如果SEO做的好,就有可能看到这篇文章).本文仅记录怎么去搭建博客,而不会解释每一步原理,有些东西我自己都没有搞的太清楚.毕竟我只是想借助博客这个平台记录平时工作的经验而已,细究相关方面知识并不是我的最终目的.现在回头看博客的搭建过程,可以总结归纳以下几点. markdown,git和GitHub,github和coding部署, Hexo和Next了解, SEO等git和GitHub接下来会按一下流程展开,本地git配置 =&gt; 关联远程仓库 =&gt; 初始化仓库.由于博主使用的Mac,执行命令时会和window下cmd有所区别.git配置完成git 的安装后,在使用之前需要配置一些全局参数, 如username和email.因为GitHub每次commit都会记录它们.git config --global user.name &quot;username&quot; git config --global user.email &quot;email&quot; 除了username和email外,还有许多自定义配置,示例:git config --global color.ui true // git输出显示不同颜色 git config --global ignorecase true // git对仓库中的文件大小写敏感 git config --global alias.st status // git提供alias的功能,git status缩写为git st git config --global apply.whitespace nowarn // git忽略空白的变化 查看所有已经做出的配置:git config -l 或 git config --list 添加远程仓库首先在github官网有自己的账号,之后就可以创建仓库了.添加SSH Key由于你的本地Git仓库和github仓库之间的传输是通过SSH加密的,所以需执行以下步骤:本地创建ssh key.$ ssh-keygen -t rsa -C &quot;your_email@youremail.com&quot; 后面的your_email@youremail.com改为你在github上注册的邮箱,之后会要求确认路径和输入密码,我们默认一路回车就行.成功的话会在~/下生成.ssh文件夹,进去打开id_rsa.pub,复制里面的key.ls -al ~/.ssh // 查看是否存在id_rsa.pub,若存在,执行下一步; cd ~/.ssh // 进入.ssh目录 cat id_rsa.pub // 查看复制id_rsa.pub 在GitHub里添加复制的id_rsa.pub. Settings =&gt; SSH and GPG keys =&gt;New SSH key.操作之后,如图示:Title任意填写,Key填入之前复制的id_rsa.pub.点击Add SSH key,添加已经完成.验证是否成功,输入下列命令:ssh -T git@github.com 如果是第一次的会提示是否continue,输入yes就会看到:You’ve successfully authenticated,but GitHub does not provide shell access.这就表示已成功连上github.创建GitHub项目并添加远程仓库登陆github账户后,点击New repository, 会有Create a new repository页面,填写相关信息,点击Create repository,可以根据官网提供的方式添加远程仓库.如下:…or create a new repository on the command lineecho &quot;# something&quot; &gt;&gt; README.md // 生成readme.md git init // 初始化本地仓库 git add README.md // 将文件添加到暂存区 git commit -m &quot;first commit&quot; // 将暂存区文件提交到仓库中 git remote add origin git@github.com:your-repository // 添加你的远程仓库 git push -u origin master // 将本地仓库推送到远程仓库 …or push an existing repository from the command linegit remote add origin git@github.com:your-repository git push -u origin master 以上步骤完成了本地仓库到远程仓库的连接,接下来总结git的一些常用的命令深入了解可参考 git中文git的常用命令状态和工作区域三种状态已提交: 表示数据已经安全得保存在本地数据库中.已修改: 表示修改了文件,但还没保存到数据库中.已暂存: 表示对一个已修改文件的当前版本做了标记,使之包含在下次提交的快照中.三种工作区域Git仓库目录: 是Git用来保存项目的元数据和对象数据库的地方.这是Git中最重要的部分,从其他计算机克隆仓库时,拷贝的就是这里的数据.工作目录: 对项目的某个版本独立提取出来的内容.这些从Git仓库的压缩数据库中提取出来的文件,放在磁盘上供你使用或修改.暂存区: 是一个文件,保存了下次将提交的文件列表信息,一般在Git仓库目录中.有时也被称作’索引’.工作目录下的两种状态已跟踪: 指被纳入了版本控制的文件,在上一次快照中有它们的记录,在工作一段时间后,它们的状态可能处于为修改,已修改或已暂存.未跟踪: 工作目录中除了已跟踪文件以外的所有其它文件都属于未跟踪文件,它们既不存在与上次快照中,也没有放入暂存区.初次克隆某个仓库的时候,工作目录中的所有文件都属于已跟踪文件,并处于未修改状态.Git工作流程基本的 Git 工作流程如下：在工作目录中修改文件.暂存文件,将文件的快照放入暂存区域.提交更新,找到暂存区域的文件,将快照永久性存储到 Git 仓库目录.如果 Git 目录中保存着的特定版本文件,就属于已提交状态. 如果作了修改并已放入暂存区域，就属于已暂存状态.如果自上次取出后,作了修改但还没有放到暂存区域,就是已修改状态.基础操作初始化Git仓库git init 该命令将创建一个名为.git的子目录,这个子目录含有初始化的Git仓库中所有的必须文件添加文件到暂存区git add &lt;file&gt; // 添加单个文件到暂存区 git add . // &apos;.&apos; 表示所有文件、文件夹和子文件夹 添加文件到仓库git commit // 将暂存区的文件提交到仓库中 git commit -m &apos;提交信息&apos; // -m 带提交信息,说明本次提交内容或修改等 git commit -am // -a Git会自动把所有已经跟踪过的文件暂存一并提交,从而跳过git add步骤 查看文件状态git status // 查看哪些文件处于什么状态 git status -s // git status -short 输出简介显示 ?? filename-1 // 新添加未跟踪文件前面有??标记 A filename-2 // 新添加到暂存区文件前有A标记 M filename-3 // 出现在左边的M表示,该文件被修改了并放入了暂存区 M filename-4 // 出现在右边的M表示该文件被修改了但没放入暂存取 MM filename-5 // 同时出现表示在工作区被修改并提交到暂存区由于在工作区中被修改了,所以说暂存区和工作区都有该文件的修改记录 查看文件具体修改git diff // 该命令查看未暂存的文件更新了哪些部分,用于比较工作目录中当前文件和暂存区域快照之间的差异 git diff --cached // 该命令用于查看已暂存的将要添加到下次提交里的内容 (Git 1.6.1 及更高版本还允许使用 git diff --staged，效果是相同的) 查看提交历史git log // 按提交时间列出所有的更新,最新的更新排在最上面 git log -p -(n) // -p 用来显示每次提交的内容差异. -(n) 仅显示最近n次提交 git log --stat // 每次的简略的统计信息 git log --pretty=oneline // 该选项指定使用不同于默认格式的方式展示提交历史. 可用选项包括oneline,short,full,fuller和format(后跟指定格式) git log --shortstat // 只显示--stat中最后的行数修改添加移除统计 git log --name-only // 仅在提交信息后显示已修改的文件清单 git log --name-status // 显示新增、修改、删除的文件清单 git log --graph // 显示ASCLL图形表示的分支合并历史 git relog // 引用日志,记录了HEAD和分支引用所指向的历史,只存在在于本地仓库 撤销操作git reset HEAD &lt;file&gt; // 丢弃已经进入暂存取的修改 git checkout -- &lt;file&gt; // 丢弃工作区中文件的修改 git checkout -- . // 丢弃当前目录下所有工作区中的修改 退回到某个提交版本git reset --hard HEAD^ // 回退到上一个提交 git reset --hard HEAD^^ // 回退到上上一个提交 git reset --hard &lt;commit_id&gt; // 回退到指定id的提交版本 删除操作在文件未添加到暂存取之前,可以直接物理删除想要删除的文件.或通过git checkout -- &lt;file&gt; 来丢弃修改.如果文件已经被提交,则需要git rm删除git rm &lt;file&gt; // 删除被提交的文件 远程仓库查看远程仓库git remote // 查看已配置的远程仓库服务器 git remote -v // 显示需要读写远程仓库使用的Git保存的简写与对应的URL git remote show &lt;remote-name&gt; // 查看某一个远程仓库的更多信息 添加远程仓库git remote add &lt;remote-name&gt; &lt;url&gt; // 添加地址为URL,名为remote-name的引用 从远程仓库中拉取与推送git fetch &lt;remote-name&gt; // 该命令将数据拉取到本地仓库,并不会自动合并或修改当前的工作 git pull &lt;remote-name&gt; // 改命令自动抓取然后合并远程分支到当前分支 git push &lt;remote-name&gt; &lt;branch-name&gt; // 将branch-name分支推送到remote-name服务器上 git push -u &lt;remote-name&gt; &lt;branch-name&gt; // 第一次使用带上-u参数,在将本地的 master 分支推送到远程新的 master 分支的同时,还会把本地的 master 分支和远程的 master 分支关联起来 远程仓库的移除与重命名git remote rm &lt;remote-name&gt; // 移除远程仓库 git remote rename &lt;old-name&gt; &lt;new-name&gt; // 重命名远程仓库 修改本地仓库对应的远程仓库git remote set-url &lt;remote-name&gt; &lt;url&gt; // 当远程的仓库地址发生变化时,需要修改本地仓库对应的远程仓库地址 分支管理git branch // 查看本地分支信息, 输出内容中,标记*,表示当前所在分支 git branch -v // 查看详细的本地分支信息 git branch &lt;branch-name&gt; // 新建一个branch-name分支 git checkout &lt;branch-name&gt; // 新建完branch-name分支后,并通过该命令切到branch-name分支 git checkout master git merge &lt;branch-name&gt; // 切换回master分支,并将branch-name分支的修改合并到master分支 git branch -d &lt;branch-name&gt; // 删除branch-name分支]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github+Hexo+Next博客搭建之Markdown]]></title>
    <url>%2FGithub-Hexo-Next%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%B9%8BMarkdown%2F</url>
    <content type="text"><![CDATA[博客已经搭建好了,自然可以趁热打铁写一些博客搭建的经验.一是方便自己以后查看,免得忘记.二是如果有人想了解博客搭建的过程,也正好有个参考.(如果SEO做的好,就有可能看到这篇文章).本文仅记录怎么去搭建博客,而不会解释每一步原理,有些东西我自己都没有搞的太清楚.毕竟我只是想借助博客这个平台记录平时工作的经验而已,细究相关方面知识并不是我的最终目的.现在回头看博客的搭建过程,可以总结归纳以下几点. markdown,git和GitHub, github和coding部署, Hexo和Next了解, SEO等Markdown工欲善其事,必先利其器.作为程序员,平时的编辑语言首选是markdown,markdown的使用其实很简单.之前除了整理一下文档外,平时倒是用的不多,在此整理一下段落和换行一个Markdown段落前后要有一个以上空行,普通段落不该用空行或制表符来缩进.段落内强迫换行可在插入处键入两个以上空格然后回车.标题markdown支持两种标题,类Setext和Atx形式.类Atx形式是在行首插入1到6个#,分别对应1到6级标题,示例:123# 一级标题## 二级标题### 三级标题区块引用Markdown中建立区块引用,需在行首最前面加上&gt;:1&gt; 这是一个区块引用效果展示:这是一个区块引用区块引用可以嵌套,只要根据层次加上不同数量的&gt;:123&gt; 这是顶层的&gt;&gt; 这是二级引用&gt;&gt;&gt; 这是三级引用效果展示:这是顶层的这是二级引用这是三级引用引用区块内可以使用其他Markdown语法,包括标题、列表、代码区块等:1234567&gt; 列表&gt; 1. item1&gt; 2. item2&gt;&gt; 代码区块&gt;&gt; 这是一个代码区块效果展示:列表item1item2代码区块这是一个代码区块列表Markdown支持有序列表和无序列表.列表项目标记通常放在最左边,也可以缩进,最多3个空格,项目标记后面一定要接着至少一个空格或制表符.列表项目可以包含多个段落,每个项目下的段落都必须缩进四个空格或是一个制表符:123456* 这是第一段落(空行)(四个空格一个制表符)这是第二段落或* 这是第一段落(两个空格)(四个空格一个制表符)这是第二段落效果展示:这是第一段落.这是第二段落这是第一段落这是第二段落列表项目内放进引用,引用需缩进四个空格或一个制表符:12* 列表项目内放进引用(四个空格或一个制表符)&gt; 这是引用一效果展示:列表项目内放进引用这是引用一列表项目内放进代码区块,该区块需缩进两次,八个空格或两个制表符:123* 列表项目内放进代码区块(空行)(八个空格或两个制表符)这是一个代码区块效果展示:列表项目内放进代码区块这是一个代码区块 无序列表无序列表使用星号(*)、加号(+)、减号(-)作为列表标记:123* item + item - item* item + item - item* item + item - item效果展示:itemitemitem有序列表有序列表则是数字接着英文句点( 数字 + . ):1231. item2. item3. item效果展示:item1item2item3代码区块Markdown中建立代码区块,需缩进四个空格或一个制表符:123这是一个普通段落:(空行)(八个空格或两个制表符)这是一个代码区块效果展示:这是一个普通段落:这是一个代码区块 分割线Markdown中的分隔线需三个以上的星号(*)、减号(-)、底线(_).也可以在星号或减号或底线中间插入空格,不影响效果.1234****-----_______**** ***** **********效果展示:链接Markdown支持两种形式的链接语法: 行内式和参考式.链接文字都是用[]标记.行内式行内式链接:1这是一个行内式链接[链接文字](链接URL &quot;链接标题&quot;)效果展示:这是一个行内式链接链接文字参考式1234参考式链接:这是一个参考式链接[链接文字][链接辨别标签](空行)[链接辨别标签]: 链接URL &quot;链接标题&quot;效果展示:这是一个参考式链接链接文字链接内容定义形式:方括号(前面可以选择性加上至多三个空格缩进),里面输入链接文字接着一个冒号接着一个以上的空格或制表符接着链接的网址, 可以用尖括号包起来选择性接着title内容,可以是单引号、双引号或括号,可以放到下一行,也可以加一些缩进链接辨别标签不区分大小写.隐式链接标记隐式链接标记可以省略制定链接标记,此时链接标记等同于链接文字:123这是一个隐式链接标记功能[隐式链接][][隐式链接]: 链接URL &quot;隐式链接标题&quot;效果展示:这是一个隐式链接标记功能隐式链接强调Markdown中标记强调字词需使用星号(*)或底线(_),被单个*或_包围的字词会被&lt;em&gt;标签包围,用两个*或_包起来,则会被转成&lt;strong&gt;,示例:123*强调* **强调** __强调__效果展示:强调强调强调如果*或_两边都有空白,它们就只会被当成普通的符号.代码Markdown标记一小段行内代码,需用反引号包起来(`),支持语法高亮,包括:Apache, Bash, CoffeeScript, C++, C#, CSS, HTTP, Java, JavaScript, JSON, Markdown, Nginx, Objective-C, Perl, PHP, Properties, Python, Ruby, Shell Session, SQL, HTML, XML等.示例:1这是一个`行内代码标记`效果展示:这是一个行内代码标记图片Markdown中插入图片,有两种样式: 行内式和参考式.行内式1![图片替代文字](图片链接URL &quot;图片描述&quot;)一个感叹号!接着方括号[],里面是图片的替代文字接着括号,里面是图片的URL,最后还可以选择性加上文字描述.参考式12![图片替代文字][图片参考标记][图片参考标记]: 图片链接URL &quot;图片描述&quot;如果需对图片进行宽高,位置调整,可以使用普通的&lt;img&gt;标签自动链接Markdown支持比较短的自动链接形式来处理网址和电子信箱,需用尖括号&lt;&gt;1&lt;网址的URL&gt;表格Markdown中支持表格,:代表对其方式,:和|之间不能有空格,否则对其会有不兼容.示例:123456789(空格)|左侧|中间|右侧||:---:|:---:|:---:||描述一|描述二|描述三|或(空格)左侧|中间|右侧:---:|:---:|:---:描述一|描述二|描述三效果展示:左侧中间右侧描述一描述二描述三小结Markdown的简单应用到这也差不多写完了,当然还有好多的高级技巧可以自行百度或Google.语法本来就很简单,虽不说十分钟包教包会,但是只要尝试着在键盘上敲两下,看看效果,学会它还是挺容易的.]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[序言]]></title>
    <url>%2F%E5%BA%8F%E8%A8%80%2F</url>
    <content type="text"><![CDATA[忙活了好多天终于把博客搭建好了.平时上班的比较忙,利用零零散散的时间看了好多关于搭建博客的文章,消化之后,发现博客的搭建并不是想象那样麻烦.以前一直有搭建博客的想法,可是每每在搭建的过程中就放弃了.原因有很多,一部分是因为从没有接触过类似博客搭建的知识,也有部分原因是也没有搭建博客的需求.为什么写做任何事都是有原因的.有搭博客写博客的想法也是一直都是存在的.在大学的那会儿,一直觉得做程序员是一类高大上的人物,所以一直对这个行业心怀憧憬.平时看些技术型文章时,一般都是来自大牛的博客,写的文章或在第三方平台,或在自己搭建的博客上.就在那个时候,心中就有了能够拥有属于自己博客的想法.于是呢,自己也是有过尝试,但是对于毫无基础的菜鸟来说,那是一种折磨.挑战新的事物的确有意思,但是突然接触到好多不懂的概念,也是一种酸爽.不过随着经历和经验的积累,也慢慢发现,学习任何新的事物,都要有个循循渐进的过程,储备的足够了自然会从量变转为质变.当然这也是后来话了.在这个阶段搭建博客想法无非就是觉得新鲜,满足一下小虚荣.结局呢,可想而知,没有足够的动力,是不能完成有些许挑战性的任务的.毕竟动物趋于安逸,生性懒惰,没有压力,哪来的奔波.人,也是动物.毕业之后,就开始步入社会,这时候就要考虑如何谋生了.所幸的是,自己从一开始就选择了前端这个行业.从一个毕业就是失业的专业跳到了一个陌生的领域,除了曾经那一丝丝的憧憬让人有所安慰外,剩下的就是彷徨不安.在自学了一段时间的前端基础后,迫于对自身学习成果的不满和外在压力,硬着头皮投递了各家招聘网站的公司.白天参加面试,晚上还要学习巩固白天面试官提的问题.人的潜力或效率有时候还真是逼出来的.在面试期间的确学到了好多东西,也大概的知道了,这类行业到底需要什么样的人.人知道的越多,也就越知道不知道的太多.那时候自己就迫切希望能够稳定下来夯实一下自己的基础.经过一段时间的东奔西跑,找到了人生的第一份正式的工作.准确的说,是被找上了.不是说我的技术有多厉害,而是这份工作压根不需要什么技术.本来我是想拒绝的,也坦言了自己的状况.毕竟我是抱着学技术的心态出来的.可是经过一轮轮的面试,我也是知道,技术的重要性,再加上人家知道情况后还是要留人,那我也就留着呗.留在公司后,就是用cms搭个网站,申请个微信公众号做微信运营什么的.那时候真的什么都不知道,各种百度啊什么的.不过最终还是让我捣鼓出来了.之后日子也就安逸了,不过每天也是提心吊胆的,生怕哪一天老板又整出什么幺蛾子.时间空出来了,搭建博客的想法也是突然又重现在脑海中.趁着机会可以建站搭博客.所以,回家后又开始忙活起如何建站.可想法是好的,现实却偏偏作对.公司一直筹划着一些活动,微信上的一些活动也要同步得做起来,我又开始了各种网站收集资源.所以,搭博客的想法又泡汤了,而且学的前端基础在这段时间也丢了不少.换了工作后,接触的到了具体实在的项目,积累的相关经验也就多了起来,一些笔记类的应用也用了起来.在开发过程中会遇到许多问题,自己也就更加主动去接受新的知识.可是虽然看到了好的文章,也收藏了起来,但是同样也犯了好多人犯的毛病.收藏夹里的记录一天天增加,却从来没有再次看过.而且,平时看的东西太过零散,无法形成自己的一套知识体系. 动力有了,搭建博客的想法也最终可以落实了.怎么去写个人平时不善言辞,尤其平时做工作汇报时,最是尴尬,忙得要死结果几句话就给总结了.这突然让我想起了学生时代写作文的时候,我是如何凑足字数的.由于自身随心随性,不喜欢约束,只要有个大的目标就行了.个人觉得,约束后的自己不再是自己.有规划更要有自己的想法.我向来不喜欢照搬别人的做法.即使权威,也是不行.模具可以快速生产出许多成品,却无法产出一件精品.写东西也是要看状态的,尤其在写总结性的东西,需要把自己的想法加进去.状态在了,有时候看待问题会更加彻底.至于偏向于技术类型的东西,那就随便了,起码在我看来,那都是套路.无非就是要记录一下问题的解决方案.写什么虽然搭博客的起因更多的来源于总结自己的工作经验.但是这个世界不只有眼前的苟且,还有诗与远方对于洒脱成性的我,看待生活时,总会时不时得冒出自己的想法和感悟.虽说不是写诗,但是凝练文采,沉淀底蕴,未尝不可.小结终于到了小结了,本以为自己言语匮乏.没想到也已经写了这么多.万一哪天灵感来了,估计会写出一部中篇小说.万事开头难,本来想是直接进入主题,写经验总结的.但唯恐坚持不下去,就写了这篇序言,以增加仪式感,希望自己能够坚持下去.]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>序言</tag>
        <tag>博客</tag>
      </tags>
  </entry>
</search>
