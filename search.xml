<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[白话MVC/MVP/MVVM]]></title>
    <url>%2F%E7%99%BD%E8%AF%9DMVC-MVP-MVVM%2F</url>
    <content type="text"><![CDATA[一切皆为数据（0，1），一切皆可量化不管承不承认，页面的展示都是数据的可视化。HTML 是数据，CSS 是数据，JS也是数据。只是这些数据的组合最终变成了我们想要的效果。最为直观的是，我们在开发者工具 Console 控制台中，输入任何形式的数据并点击 Enter 时，最终会在下方显示出来（前提是输入正确的数据类型和格式）。又或者，我们用某些参数从服务请求一个 JSON 文件，浏览器上就会展示文件内容。数据 =&gt; 视图，就是这么简单直接。MV然而，实际上的情况远远比这复杂。为了更好的视觉享受和用户体验，浏览器上的页面效果越来越炫，交互逻辑也越来越复杂。我们拿到的第一手数据（或来自用户，或来自服务）已经不能直接用来展示了，而是要经过相应的逻辑处理（在这里我们称第一手数据为源数据，经过逻辑处理后的数据称为目标数据）。视图上的数据就是目标数据的映射。而处理后的数据又该如何展示呢？是基于 DOM 做操作，还是基于目标数据重新渲染呢？两者都可，前者是以 jQuery 为代表，后者则是以 Vue 等新框架为主。举个例子🌰，对于某个 DOM 元素的显隐。1234567891011&lt;!-- jQuery --&gt;&lt;div id='jquery'&gt;&lt;/div&gt;$('#jquery').hide;&lt;!-- Vue --&gt;&lt;div id='jquery' v-show=&#123;id[jquery]&#125;&gt;&lt;/div&gt;data: &#123; id: &#123; jquery: fasle &#125;&#125;基于 DOM 操作， 如果我们需要对这个 DOM 随时改变显隐，就需要不断操作 DOM 来更改样式。 如果基于数据操作，我们只需要更改 jQuery 的值即可。我们再回到刚才的话题，对于复杂的交互页面，数据 =&gt; 视图 的关系已经不再像之前那么纯净了。为了应付复杂的场景，数据 和 视图 不再是狭义上的数据和视图。数据包括了数据和数据相关的操作，视图包括了视图和对视图相关的一些操作。MV*模式借用其他领域 MV* 框架模式，这里的 数据 和 视图 对应着 Model 和 View. 简单点的页面，Model - View 完全能够应付过来。但是复杂的场景，Model 和 View 会分担太多的逻辑而显得臃肿，甚至可能包含了不在自己职责范围内的逻辑。此时我们就要借助第三者来协调 Model 和 View 之间的关系。如何合作，其实也早有了相应的解决方案。比如 MVC、MVP、MVVM。因为重点始终在于协调 Model和 View，所以它们统称为 MV*。MVC (Model(模型)-View(视图)-Controller(控制器)), MVP (Model(模型)-View(视图)-Presenter(中介者)) 以及 MVVM (Model(模型)-View(视图)-ViewModel(视图模型))，是种模式也是种抽象的概念。每一种模式在实践中可能存在着不同的变体，但这不妨碍它们属于同一个模式。每一种模式的不同变体都是为了解决不同问题而产生的，所以它们没有什么优劣之分。现在我们就把三种模式拟人化来阐述不同模式的运作方式。由四节电池驱动的J-20模型:MVC公司：飞机模型制造商 =&gt; 生产的飞机模型可以自主塑形。模式：MVC飞机模型 V：由模型数据生产出的模型。职责有：由模型数据自主塑形、将收集用户反馈并转发。工程师 M：负责将客服的需求参数转换成最终的模型数据。职责有：对数据的操作、通知飞机模型更新。工程师 C：协调 M 和 V。负责响应用户、调用工程师M生成目标数据。首先我们要知道，客户提出了想要一个 60cm * 60cm 的飞机模型，这个需求到了制造商那里肯定不是给出个 60cm * 60cm 的小方块，而是根据需求计算处理生产真正的飞机模型（比如什么样的造型设计才能最大减少阻力），工程师M的工作之一就是根据原始数据并结合特定的逻辑规则给出最终的模型数据。现在，用户手里有一飞机模型V，不过这个飞机模型的飞机双翼和用户想象的不一样。于是用户根据飞机模型上提供的方式反馈了问题（比如飞机模型提供了留言功能，用来收集用户反馈）。工程师C收到了反馈后，把工程师M拉过来对数据进行处理并生成新的模型数据，并让工程师M通知到共享相同数据的飞机模型去更新数据自主调整。插一句，说到调整，我们有两种方式。一个是，我们可以针对用户不满意的地方（飞机双翼）进行调整。一个是，我们飞机模型格式化按照最新的数据模型重新初始化一下。前者可以认为就是基于 DOM 操作的方式，后者就是基于数据的处理方式。在 MVC 中，Model 和 View 之间耦合，视图的更新需要 Model 去直接通知。Model 内因为有 View 的引用才能让视图更新。MVP如果 Model 只想做数据相关的操作，把通知 View 的逻辑挪到了 Control 里，这时 Control 摇身一变称为了 Presenter。因为解耦了 Model 和 View，也使得它们的职责划分更加清晰。公司：飞机模型制造商 =&gt; 生产的飞机模型可以自主塑形。模式：MVP飞机模型 V：由模型数据生产出的模型。职责有：由模型数据自主塑形、将收集用户反馈并转发。工程师 M：负责将客服的需求参数转换成最终的模型数据。职责有：对数据的操作。工程师 P：协调 M 和 V。负责响应用户、调用工程师M生成目标数据、更新视图。在 MVP 模式中，工程师M的工作专注于数据，通知的活甩给了工程师P。和 MVC 同样的场景，工程师P接到反馈后，把工程师M拉过来处理了数据，然后又让飞机模型依据已经处理后的数据自主调整。每次数据的变化都要主动去通知视图更新。MVVM如果数据变化能够自主触发视图更新，对 Presenter 来说也会轻松不少。于是 Presenter 再次摇身一变 称为了 ViewModel。公司：飞机模型制造商 =&gt; 生产的飞机模型可以自主塑形。模式：MVVM飞机模型 V：由模型数据生产出的模型。职责有：由模型数据自主塑形、将收集用户反馈并转发。工程师 M：负责将客服的需求参数转换成最终的模型数据。职责有：对数据的操作。工程师 VM：协调 M 和 V。负责响应用户、调用工程师M生成目标数据并更新视图。在 MVVM 中，View 和 Model 的变化似乎不大。为了在数据变化后能够自动更新视图，ViewModel 进行了所谓的数据绑定。ViewModel 将 目标数据 和视图进行了绑定，在最终生成目标数据时，会触发视图的更新。在这里我们可以想象有两份数据，一份是源数据，一份是目标数据。绑定视图的是目标数据，这样，我们直接修改目标数据时会触发视图更新。如果是源数据经处理后赋给目标数据，目标数据也会改变，也会触发试图更新。总之，在 MVVM 中，视图是目标数据的可视化，通过改变视图里的数据也就等于改变了目标数据。和 MVC、MVP 同样的场景，不过科技发达了，工程师VM有个自动化处理程序。用户反馈了问题，工程师VM的这个自动处理程序接到反馈自动处理并将结果发给飞机模型让其自主调整。以下是Vue的MVVM示意图：MVC、MVP和MVVM大致就是如此，根据三种模式以及不同场景，最终演变出了不同的变体。但是，不同的变体是针对不同问题的解决方案，指不定后来还会有 MVA、MVB…, 谁知道呢]]></content>
      <categories>
        <category>这个想法不一定对</category>
      </categories>
      <tags>
        <tag>MVC</tag>
        <tag>MVP</tag>
        <tag>MVVM</tag>
        <tag>MV*</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在JavaScript中尝试组合模式]]></title>
    <url>%2F%E5%9C%A8JavaScript%E4%B8%AD%E5%B0%9D%E8%AF%95%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[组合模式就是用小的子对象来构建更大的对象, 将对象组合成树形结构, 以表示 “部分-整体” 的层次结构. 位于底层最小的对象, 我们在这里称为叶对象, 由叶对象组成的组合对象我们称为分支对象, 位于最顶层的根对象在这里我们也称为分支对象. 不过它们只是结构上呈现出父子关系. 组合模式最大的好处可以一致性地对待分支对象和叶对象, 这也就要求了它们有着相同的接口.在咬文嚼字说策略中, 我们对员工进行考核, 划分了甲乙丙三个等级. 现在, 公司决定结合等级以资鼓励.以下所有代码参见compositeMode.开销的占比现有考核人员:考核项目\考核人等级月薪person_1甲6kperson_2乙9kperson_3乙4kperson_4乙5kperson_5丙6kperson_6丙5kperson_7丙6kperson_8丙4kperson_9甲8k123456789101112const persons = [ &#123;scale:'甲', salary: 6000, company: 'JavaScript'&#125;, &#123;scale:'乙', salary: 9000, company: 'JavaScript'&#125;, &#123;scale:'乙', salary: 4000, company: 'JavaScript'&#125;, &#123;scale:'乙', salary: 5000, company: 'JavaScript'&#125;, &#123;scale:'丙', salary: 6000, company: 'JavaScript'&#125;, &#123;scale:'丙', salary: 5000, company: 'JavaScript'&#125;, &#123;scale:'丙', salary: 6000, company: 'JavaScript'&#125;, &#123;scale:'丙', salary: 4000, company: 'JavaScript'&#125;, &#123;scale:'丙', salary: 9000, company: 'JavaScript'&#125;, &#123;scale:'甲', salary: 6000, company: 'JavaScript'&#125;,]等级与月薪相关, 分别为3倍月薪、2倍月薪、1倍月薪.等级甲乙丙月薪倍率32112345const scaleMap = &#123; '甲': 3, '乙': 2, '丙': 1&#125;到底需要拿出多少钱奖励呢? 甲乙丙三组人分别占比多少呢? 针对这样的需求, 我们尝试着用组合模式计算一下.叶对象与分支对象上面也提到了, 组合模式中有两类对象. 一个是分支对象, 一个是叶对象. 分支对象是叶对象的集合, 保存着叶对象的引用, 可以操作叶对象(比如添加, 执行). 而叶对象只要暴露接口即可.现在我们从简单的开始, 造一个生产叶对象的函数.12345678const leaf = params =&gt; &#123; return &#123; ...params, expense() &#123; return scaleMap[params.scale]*params.salary &#125; &#125;&#125;;分支对象就稍微麻烦些了, 因为需要管理叶对象.1234567891011121314const branch = params =&gt; &#123; return &#123; ...params, members: [], add(item) &#123; this.members.push(item) &#125;, expense() &#123; return this.members.reduce((sum, item) =&gt; &#123; return sum + item.expense() &#125;, 0) &#125; &#125;&#125;;expense() 的方法不论是在分支对象还是叶对象上, 或者说不清楚是分支对象还是叶对象, 我们都可以得到相应的结果. 在分支对象里, 保存着叶对象的引用, 我们可以对叶对象进行任何操作.从JSON数据到树形结构组合模式就是这么简单, 剩下的就是如何 JSON 数据转换成层次分明的结构了.123456789101112131415161718192021222324const convertData = array =&gt; &#123; const branchList = []; const branchObjs = []; array.forEach(item =&gt; &#123; let leafObj = leaf(item); if (!branchList.includes(item.scale))&#123; let params = &#123; scale: item.scale &#125; let branchObj = branch(params) branchObjs.push(branchObj) branchList.push(item.scale) &#125; branchObjs.filter(obj =&gt; obj.scale == item.scale)[0].add(leafObj); &#125;) return branchObjs;&#125;console.log('branchObjs', convertData(persons))const scaleA = convertData(persons)[0];const scaleB = convertData(persons)[1];const scaleC = convertData(persons)[2];console.log('甲', scaleA.expense())console.log('乙', scaleB.expense())console.log('丙', scaleC.expense())最终结果展示如果我们想知道公司的总支出, 也可以把 scaleA, scaleB, scaleC 组合在一起作为公司的一子集.12345const company = branch();company.add(scaleA);company.add(scaleB);company.add(scaleC);company.expense()不难发现, 我们可以随意组装对象而不会影响到其它节点, 任何一个集合或个体都能够单独运行. 我们也可以根据需要去组合更复杂的结构. 但是, 如果通过组合模式创建了太多的对象, 那么这些对象可能会让系统负担不起.小结组合模式对象形式上至少有两种, 分支对象和叶对象.分支对象和叶对象拥有相同的接口, 且对一组叶对象操作具有同步一致性.组合模式是 HAS-A (聚合)关系, 不是 IS-A.]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>组合模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[咬文嚼字说策略]]></title>
    <url>%2F%E5%92%AC%E6%96%87%E5%9A%BC%E5%AD%97%E8%AF%B4%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[设计模式是: 在面向对象软件过程中针对特定问题的简洁而优雅的解决方案. 通过对封装、继承、多态、组合等技术的反复利用, 提炼出可重复使用面向对象的设计技巧.JavaScript 可以模拟实现传统面向对象语言的设计模式. 然而仅仅是生搬硬套, 未免会失去 JavaScript 的灵活性. 不如溯本求源, 看看这些设计模式到底在传达什么, 然后遵循此点.策略模式定义策略模式: 定义一系列的算法, 把它们一个个封装起来, 并且使它们可以相互替换.字面意思, 就是定义封装多种算法, 且各个算法相互独立. 当然, 也不仅仅是算法. 只要定义一些规则, 经处理后输出我们想要的结果就成. 在此我们称单个封装后的算法为一个策略. 一系列封装后的算法称为一组策略.一个基于策略模式的程序至少由两部分组成. 第一部分是一组策略类, 策略类封装了具体的算法, 并负责具体的计算过程. 第二部分是环境类 Context, Context 接受客户的请求, 随后把请求委托给某一个策略类.这是面向传统面向对象语言中的说法. 在面向对象思想中, 通过对组合, 多态等技术的使用来实现一个策略模式. 在 JavaScript 中, 对于一个简单的需求来说, 这么做就有点大材小用了.所以, 上面的那句话, 我们换种说法就是, 策略模式需要至少两部分, 一部分是保存着一组策略. 另一部分则是如何分配这些策略, 即如何把请求委托给某个/些策略. 其实这也是策略模式的目的, 将算法的使用与算法的实现分离.评级快到年底了, 公司打算制定一个标准用来给员工评级发福利.考核项目\等级甲乙丙A100&gt;a&gt;=9090&gt;a&gt;=8080&gt;a&gt;=70B100&gt;b&gt;=9090&gt;b&gt;=8080&gt;b&gt;=70以A、B考核项目来评定甲乙丙等级.现有考核人员:考核项目\考核人person_1person_2person_3A809392B85709012345const persons = [ &#123;A: 80, B: 85&#125;, &#123;A: 93, B: 70&#125;, &#123;A: 92, B: 90&#125;]在策略模式中一部分, 我们提到的分配策略. 要想分配策略, 首先就要知道所有的策略, 只有这样我们才能针对性的委托给某个/些策略. 这, 也是策略模式的一个缺点.常规操作甲乙丙等级对 A、B 的分值要求是不一样的. 所以我们可以这么做:1234567891011121314151617181920function rating(person) &#123; let a = person.A; let b = person.B; if (a &gt;= 90 &amp;&amp; b &gt;= 90) &#123; return '甲'; &#125; else if (a &gt;= 80 &amp;&amp; b &gt;= 80) &#123; return '乙'; &#125; else if (a &gt;= 70 &amp;&amp; b &gt;= 70) &#123; return '丙' &#125; else &#123; console.log('凭啥级, 还不赶紧卷铺走人'); &#125;&#125;persons.forEach(person =&gt; &#123; person.rate = rating(person);&#125;)// &gt; persons// [ &#123; A: 80, B: 85, rate: '乙' &#125;,// &#123; A: 93, B: 70, rate: '丙' &#125;,// &#123; A: 92, B: 90, rate: '甲' &#125; ]策略模式下的评级如果换成策略模式, 第一部分就是保存一组策略. 现在我们以甲乙丙三种定级标准来制定三种策略, 用对象来存贮策略. 考虑到以后可能有 D、E、F 等考核项目的存在, 我们稍微改一下:1234567891011121314151617181920const strategies = &#123; '甲': (person, items) =&gt; &#123; const boolean = items.every(item =&gt; &#123; return person[item] &gt;= 90; &#125;); if (boolean) return '甲'; &#125;, '乙': (person, items) =&gt; &#123; const boolean = items.every(item =&gt; &#123; return person[item] &gt;= 80; &#125;); if (boolean) return '乙'; &#125;, '丙': (person, items) =&gt; &#123; const boolean = items.every(item =&gt; &#123; return person[item] &gt;= 70; &#125;); if (boolean) return '丙'; &#125;&#125;策略就制定好了. 对象的键对应着策略的名称, 对象的值对应着策略的实现. 然而, 我们发现, 任何一个策略都不能单独完成等级的评定. 可是, 我们有说一组策略只能选择其中一个么? 为了达成某个目的, 策略组封装了一组相互独立平等替换的策略. 一个策略不行, 那就组合呗. 这也是策略模式另一部分存在的意义, 即如何分配策略.123456789101112function rating(person, items) &#123; return strategies['甲'](person, items) || strategies['乙'](person, items) || strategies['丙'](person, items)&#125;persons.forEach(person =&gt; &#123; person.rate = rating(person, ['A', 'B'])&#125;)// &gt; persons// [ &#123; A: 80, B: 85, rate: '乙' &#125;,// &#123; A: 93, B: 70, rate: '丙' &#125;,// &#123; A: 92, B: 90, rate: '甲' &#125; ]逻辑的转移所有的设计模式都遵循一条原则. 即 “找出程序中变化的地方, 并将变化封装起来”.将不变的隔离开来, 变化的封装起来. 策略模式中, 策略组对应着程序中不变的地方. 将策略组制定好存贮起来, 然后想着如何去分配使用策略.当然, 如何制定策略和如何分配策略之间的关系十分紧密, 可以说两者相互影响.再次看看制定的策略, “找出程序中变化的地方, 并将变化封装起来”, 我们可以再次改造一下.1234567891011121314151617181920212223242526const strategies = &#123;'甲': 90,'乙': 80,'丙': 70,&#125;function rating(person, items)&#123; const level = value =&gt; &#123; return (person, items) =&gt; &#123; const boolean = items.every(item =&gt; &#123; return person[item] &gt;= strategies[value]; &#125;); if (boolean) return value; &#125; &#125; return level('甲')(person, items) || level('乙')(person, items) || level('丙')(person, items)&#125;persons.forEach(person =&gt; &#123; person.rate = rating(person, ['A', 'B'])&#125;)// &gt; persons// [ &#123; A: 80, B: 85, rate: '乙' &#125;,// &#123; A: 93, B: 70, rate: '丙' &#125;,// &#123; A: 92, B: 90, rate: '甲' &#125; ]在上面的这种做法中, 我们把制定策略的逻辑挪到了分配策略里了. 所以说, 如何制定策略和如何分配策略, 依情况而定.不过回头在看一看这段代码, 是不是和平时用对象映射的做法很相似.当然, 策略模式的用法还有很多, 最常见的是规则校验.小结总结一下:策略模式至少包括两部分, 制定策略和分配策略.策略模式的目的在于, 将策略制定和策略分配隔离开来.策略制定和策略分配关系密切, 相互影响.]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>策略模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初始化空对象数组]]></title>
    <url>%2F%E5%88%9D%E5%A7%8B%E5%8C%96%E7%A9%BA%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[初始化空对象数组在给对象设置属性时, 如果对象不存在很容易报错.有些场景, 在对对象数组处理时, 设置对象属性前判断对象是否存在. 与其这样, 还不如直接初始化为空对象数组.9个考生就来了6个考试时, 每个考生都有自己位置. 考生对照着可以很容易在考场里找到自己的座位. 秉着公平、公正、公开的原则, 考生被稀疏地散布在考场的各个角落. 假设考场 3*3 排列, 考生的信息:123456[&#123;"row":1,"col":1,"name":"Ada"&#125;, &#123;"row":3,"col":3,"name":"Aaron"&#125;, &#123;"row":1,"col":2,"name":"Aditi"&#125;, &#123;"row":3,"col":2,"name":"Aditi"&#125;, &#123;"row":1,"col":3,"name":"Aditi"&#125;, &#123;"row":3,"col":1,"name":"Abbott"&#125;]将考场位置做成一个表格, 对考生位置按排统计, 来标注考生出勤情况.123[&#123;"row":1,"col_1":"Ada","col_2":"Aditi","col_3":"Aditi"&#125;, &#123;&#125;, &#123;"row":3,"col_3":"Aaron","col_2":"Aditi","col_1":"Abbott"&#125;](为嘛没有第二排? 自知考不过, 缺考了呗🙁)开发中, 对原始数据进行处理是一件很平常的事. so, 这个数据的处理应该很简单…吧😅Array(3).fill({}) 试一波如何初始化空对象数组?原始数据是以学生个体的信息存储展示的, 现在则按排为单位对数据进行处理. 理所当然的会想到先初始化三个空对象数组.123let studentRow = Array(3).fill(&#123;&#125;)// &gt; studentRow// [ &#123;&#125;, &#123;&#125;, &#123;&#125; ]动作很快姿势很帅. 不过, 这样真的可以么? 长得倒是像那么一回事, 可实际上完全行不通. Array.prototype.fill() 的用法是, 指定某个值来填充数组.也就是说, {} 在 studentRow 里复制了三次. 如果是简单类型值倒也罢了, 但是换做复杂类型值, 修改每一个 {} , 都会影响其它的 {}. 因为它们都是对同一个对象的引用.1234567891011121314151617let studentRow = Array(3).fill(&#123;&#125;);studentRow[0].name = 'tony';// &gt; studentRow// [ &#123; name: 'tony' &#125;,// &#123; name: 'tony' &#125;,// &#123; name: 'tony' &#125; ]// 等同于let obj = &#123;&#125;;let studentRow = Array(3).fill(obj);// &gt; studentRow// &#123;obj, obj, obj&#125;studentRow[0].name = 'tony';// &gt; studentRow// [ &#123; name: 'tony' &#125;,// &#123; name: 'tony' &#125;,// &#123; name: 'tony' &#125; ]知识点:将一个值赋予变量时, 解析器必须确定这个值是基本类型值还是复杂类型值.当是复杂类型值时, 变量里保存的是该复杂类型值在堆中的一个指针. 复制的是变量的指针, 操作的却是实际的对象.Array(3) 和 map(() =&gt; {}) 结合有问题Array(3).fill({}) 行不通. 那么, Array(3).map(() =&gt; {})?如果说 Array(3).fill({}) 不可行, 是因为三个空对象是对同一个对象的引用. 那么我们就设法返回三个不同的空对象.123let studentRow = Array(3).map(() =&gt; &#123;&#125;);// &gt; studentRow// [ &lt;3 empty items&gt; ]结果很失望, 这个表达式就干了两件事, Array(3) 和 map(() =&gt; {}). 所以问题很好排查.123let arr = Array(3);// &gt; arr// [ &lt;3 empty items&gt; ]对于数组中并不存在的单元, map() 也是束手无策.我说: 肚里要有货🙏肚里没货, 我们就造一些. Array.prototype.fill() 又有出头之日了.123let studentRow = Array(3).fill(undefined);// &gt; studentRow// [ undefined, undefined, undefined ]警告:如若一个数组没有任何单元, 但它的 length 属性中却显示有单元数量, 这样奇特的数据结构会导致一些怪异的行为. 我们将包含至少一个 “空单元” 的数组称之为 “稀疏数组”. undefined 单元非 “空单元”.永远不要创建和使用空单元数组.箭头函数中的 return你以为 Array(3).fill(undefined).map(() =&gt; {}) 就完事了? 图样图森破 👼123let studentRow = Array(3).fill(undefined).map(() =&gt; &#123;&#125;);// &gt; studentRow// [ undefined, undefined, undefined ]哦, 我知道了, 你没有 return 啊额, 这和 return 没有关系. 不信你可以加一个试试😏其实, {} 在这里被视作语法块了, 没有任何意义. 可恨就可恨在, 它和空对象长得一摸一样.既然这样, 那我们就不用字面量定义一个空对象了.1234let studentRow = Array(3).fill(undefined).map(() =&gt; Object.create(null));studentRow[0].name = 'tony';// &gt; studentRow// [ &#123; name: 'tony' &#125;, &#123;&#125;, &#123;&#125; ]这样就达到初始化对象数组的目的了. 可是, Array(3).fill(undefined).map(() =&gt; {}) 为什么行不通, 如何补救?规避问题在某种意义上不等于解决问题.{...} 里面的代码会被解析为一系列语句. {} 也因此不能达到我们预期的结果. 所以, 我们可以用 (...) 将 {} 包装成表达式, 即 ({}).1234let studentRow = Array(3).fill(undefined).map(() =&gt; (&#123;&#125;));studentRow[0].name = 'tony';// &gt; studentRow// [ &#123; name: 'tony' &#125;, &#123;&#125;, &#123;&#125; ]知识点:若函数体的表达式个数多于一个, 或者函数题包含非表达式语句的时候才需要用 {...} 包裹.如果只有一个表达式, 并且省略了 {...} 的话, 则附加一个隐式 return. 若在块体内需要指定返回值, 则需要明确的 return.箭头函数提供了简练的语法, 但不是普通函数的替代品. 箭头函数的主要设计目的是改变 this 的行为. 普通函数内的 this 是动态绑定, this 指向谁取决于调用者. 而箭头函数里的 this 是基于作用域的, 是可预测的.(可参考从游戏角度说作用域).令人绝望的Array.prototype.fill()你以为结束了, 其实才刚刚开始这是真正的开始, 没看错, 是的, 我们之前所做的可能都是无用功.是的, IE 是魔鬼. 费尽了周折, 才发现一切都是徒劳.难道就这么放弃了?‘放弃’能吃么? 能吃就吃了它, 啥? 不能吃?!? 提它作甚!!!Array.prototype.fill() 方便之处就是能够简便填充数组. 此法不行, 另寻他法.Function.prototype.apply() 了解一下Function.prototype.apply() 入参有两个. 第一个参数是 函数方法 的调用者, 第二个参数是 函数方法 的入参(要区分入参和入参的不同). 函数方法 的入参可以是数组也可以是类数组. 我们的目的就是填充数组, 所以我们要在类数组上做文章. 就拿 console.log 做例子🌰. (直接复制我之前的博客内容😌).1234567891011121314151617function log_1(arg) &#123;console.log(arg)&#125;log_1(1);log_1(1,2,3);// 1// 1// 改造下function log_2() &#123; const log = console.log; log.apply(null, arguments)&#125;log_2(1);log_2(1, 2, 3)// 1// 1 2 3这是 Function.prototype.apply() 使用的方法. 如果我们把 log_2 里的 arguments 换成 {length: 3},123456function log_2() &#123; const log = console.log; log.apply(null, &#123;length: 3&#125;)&#125;log_2()// undefined undefined undefined{length: 3} 和 [undefined, undefined, undefined] 在传入 apply(null;...) 后, 在参数的处理上, 最后的结果是一样的.那么, Array(3).fill(undefined).map(() =&gt; ({})) 可改造成,1234let studentRow = Array.apply(null, &#123;length: 3&#125;).map(() =&gt; (&#123;&#125;));studentRow[0].name = 'tony';// &gt; studentRow// [ &#123; name: 'tony' &#125;, &#123;&#125;, &#123;&#125; ]在这里 Array 作为普通函数调用, 以上等同于123let studentRow = Array(undefined, undefined, undefined);// &gt; studentRow// [ undefined, undefined, undefined ]收尾只是初始化一个空对象数组, 结果整出这么多幺蛾子.处理数据其实就那么几行代码. 大致长这模样,12345678function handleData(params) &#123; const studentRow = Array.apply(null, &#123;length: 3&#125;).map(() =&gt; (&#123;&#125;)); params.forEach(item =&gt; &#123; studentRow[item.row-1][`row`] = item.row; studentRow[item.row-1][`col_$&#123;item.col&#125;`] = item.name; &#125;) return studentRow;&#125;]]></content>
      <categories>
        <category>天坑也填坑</category>
      </categories>
      <tags>
        <tag>空对象数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从游戏角度说作用域]]></title>
    <url>%2F%E4%BB%8E%E6%B8%B8%E6%88%8F%E8%A7%92%E5%BA%A6%E8%AF%B4%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[作用域作用域是 JavaScript 里的一个非常重要和基础的概念. 很多人认为自己理解了作用域, 但是在遇到闭包时却说不出个所以然, 甚至不能识别出来.闭包也是个非常重要, 且经常被误解的概念. 然而闭包就是基于作用域书写代码时所产生的自然结果. 倘若抛开作用域讲闭包, 那都是耍流氓. 闭包可以说在平时的代码里随处可见, 但真正让闭包发挥积极作用的做法是隔离作用域、模块函数等.作用域机制是不能直接查看的, 我们首先模拟一个场景来尽可能的说明作用域这套规则, 然后通过代码片段和开发者工具进行验证.游戏存档想必大家都有玩过游戏的经验. 刚开始的时候, 也就是第一关, 难度比较简单. 到了第二关的时候, 就在第一关的基础上加些难缠的角色, 难度相应地加大了. 关卡越是往后, 难缠的角色也就会越来越多.可在游戏的时候, 由于各种原因, 往往我们不可能一下子通过所有的关卡, 所以游戏提供了存档的功能. 下次再玩的时候可以从存档里续上. 如果不想这样, 完全可以从头玩起.为什么我们能从存档里直接跳到上次的关卡, 很显然, 这里是有记录存储的. 比如第一关有个场景食人花和海王, 第二关又多了个邪恶人等等. 每个关卡都会记录该关卡新增的角色或场景同时也会存储之前关卡的记录. 这样就保证了不同的存档的独立性, 无论在哪个关卡存档, 下次也定会续上之前的地方. 当然了, 我们也可以回到上一个关卡.(海王之雄风&amp;敌人之邪恶)几个知识点结合上面的场景, 我们再回头看看以下几个知识点.标识符: 变量、函数、属性的名字, 或者函数的参数.每个函数都有自己的执行环境. 当执行流进入一个函数时, 函数的环境就会被推入一个环境栈中. 而在函数执行后, 栈将其环境弹出, 把控制权返回之前的执行环境.执行环境定义了变量或函数有权访问的其它数据. 每个执行环境都有一个与之关联的变量对象, 环境中定义的所有变量和函数都保存在这个对象中. 某个执行环境中的所有代码执行完毕后, 该环境被销毁, 保存在其中的所有变量和函数定义也随之销毁.当代码在一个环境中执行时, 会创建变量对象的一个作用域链.作用域链是保证对执行环境有权访问的所有变量和函数的有序访问. 作用域的前端始终都是当前执行的代码所在的变量对象. 如果这个环境是函数, 则将其活动对象作为变量对象. 活动对象在最开始只包含一个变量, 即 arguments 对象. 作用域链中的下一个变量对象来自包含(外部)环境. 全局执行环境的变量对象始终都是作用域链的最后一个对象.当某个环境中为了读取或写入而引入一个标识符时, 必须通过搜索来确定该标识符来确定该标识符实际代表什么. 搜索过程从作用域链的前端开始, 向上逐级查询与给定名字匹配的标识符. 如果在局部环境中找到了该标识符, 搜索过程停止, 变量就绪. 如果在局部环境中没有找到该变量名, 则继续沿作用域链向上搜索. 搜索过程将一直追溯到全局环境的变量对象. 如果在全局环境中也没有找到这个标识符, 则意味着该变量尚未声明.作用域链本质上时一个指向变量对象的指针列表, 它只引用但实际不包含变量对象.如果我们把以上的几个知识点串起来, 这就是所谓的作用域链规则了. 上图解释一波.(arguments 应该加到变量对象里的, 图中没体现, 疏忽)现在我们从最后两行说起,12var outer = outerFn(10);var inner = outer(10);执行 outer = outerFn(10) 后, outer 拥有了返回函数的引用. outer(10) 在执行的时候它会创建 属于它自己 的作用域链, 这里包含函数所处外部环境的变量对象.在读取 initial 变量时, 在 Inner 变量对象中没有检索到, 它会沿着作用域链向上搜索, 在 outer 变量对象里找到了该标识符, 搜索过程停止, 变量就绪.函数在定义的时候就已经决定了之后执行时, 作用域里将包含什么. 这也解释了, 即使我们把定义在函数内部的函数扔在外边执行也能访问到函数内部的变量. 这和内部函数在哪执行没有半毛钱关系.为什么强调 属于它自己 的呢?12345678910111213function outer() &#123; var num = 0; return function inner() &#123; return num++; &#125;&#125;let innerFn_1 = outer();let a_1 = innerFn_1()let innerFn_2 = outer();let a_2 = innerFn_2();let a_1_1 = innerFn_1();let a_2_2 = innerFn_2();innerFn_1 和 innerFn_2 都属于自己的作用域链, 而 a_1 和 a_2 则分别在 innerFn_1 和 innerFn_2 上创建了属于自己的作用域链. 所以它们函数里的 num 是属于不同作用域链里的变量. 但对于 a_1 和 a_1_1 来说它们都是基于 innerFn_1, 拥有同一 outer 变量对象, num 自然也是同一个, 所以会累加. 同理 a_2 和 a_2_2.如果理解了这个, 那么面试常考的一题就小菜一碟了.12345for(var i = 1; i &lt;= 5; i++) &#123; setTimeout(function timer() &#123; console.log(i); &#125;, i*1000)&#125;重点是执行的时候才会创建变量对象的一个作用域链.闭包是什么?如果理解了以上的概念, 就会觉得闭包是作用域埋的一个彩蛋, 用的好就是惊喜, 用的不好就成惊吓了.当函数可以记住并访问所在的作用域, 即使函数是在当前作用域之外执行, 这时就产生了闭包. 这就和之前提到的游戏存档差不多.好了, 扔几个闭包出来巩固一下.12345678910function outer_1() &#123; var a = 'hello world'; function inner() &#123; console.log(a) &#125; outer_2(inner)&#125;function outer_2(fn) &#123; fn()&#125;这里也有闭包.12345678var a = new array(99999999);function b() &#123; console.log(b)&#125;b()body.addEventListener('click', function() &#123; console.log('hello world')&#125;)还有开头所说的可以结合开发者工具直观地看一下, 一张动态图解释一切.内存泄漏闭包之所以能成为闭包, 是因为它记录了函数所在的作用域. 现主流的自动垃圾收集机制正因为闭包的这个特点而不能释放内存. 闭包的滥用会导致导致内存能分配的空间变少, 最终崩溃.正常来说, 函数在执行的过程中, 局部变量会被分配相应的内存空间, 以便存储它们的值, 直至函数执行结束. 此时局部变量占有的空间会被释放以供将来使用.常说的回收机制之一, 标记清除, 它的工作原理是, 当变量进入执行环境时, 储存在内存中的所有变量都会被加上标记(至于什么标记我们不关心), 然后找到 环境中的变量 以及 被环境中引用的变量, 把它们之前加的标记给去掉. 而剩下的被标记的变量将被视为 准备 删除的变量. 最后, 垃圾收集器找出不再继续使用的变量, 释放其占用的内存. 所以, 一旦数据不再被需要, 应解除引用, 将其值设置为null.12outer = null;inner = null;内部函数的执行环境会保存着外部环境活动对象的引用, 内部函数被扔出去后, 就意味着外部环境不能被销毁了.this执行环境里记录的不只是这些, 它也记录了函数调用栈、函数调用方式等. this 和作用域有关系, 但不是你们想象的那种关系. 每个函数在被调用时都会自动取得两个特殊变量: this 和 arguments. 内部函数在搜索这两个变量时, 只会搜索到其活动对象为止(即当前变量对象). 因此永远不可能直接访问到外部函数中的这两个变量. 除非我们把外部作用域中的 this 对象保存在一个闭包能够访问到的变量里.123456789// 很常见是不是😂let obj = &#123; a: function() &#123; var self = this; return function() &#123; console.log(self) &#125; &#125;&#125;函数内部的 this 在函数执行时才正式被赋予相应的值, 所以说函数的调用位置很关键. 可以这么说, 谁 直接 调用了这个函数, this 就指向了谁. 如果不是对象在直接调用这个函数, 我们可统统认为是 undefined, 非严格模式浏览器环境下就是 window. 如果真想知道为什么, 可以直接看规范(神烦).1234567891011121314151617181920'use strict'function a() &#123; console.log(this)&#125;var b = &#123; a: function() &#123; console.log(this); &#125;, b: function() &#123; return a; &#125;&#125;let b_a = b.a;a(); //1. undefined;b_a(); //2. undefined;b.a(); //3. &#123;a: f, b: f&#125;;b.b()(); //4. undefined;(true &amp;&amp; b.a)() //5. undefined;new a(); //6. &#123;&#125;b.call(b); //7. &#123;a: f, b: f&#125;;从 1~6, 我们看看哪个对象直接调用了该函数. 第 1 个没找到调用对象, 就是个普通函数调用. 第 2 个经过 b_a = b.a 赋值操作后, 返回的就是那个普通函数, 就是一普通的函数调用. 第 3 个很直接, 就是 b 这个对象了. 第 4 个是个闭包, 首先 this 只在当前活动对象里找 this 对象, 不知道是哪个对象, 但肯定不会是 b. 第 5 个和第 2 个是一个道理. 第 6 个吧, 貌似不算是函数调用了吧, 不过我们知道, this 是指向新创建的空对象. 第 7个就更直接了, 人家都指名道姓就差喊出来了.this 绑定对象的几条准则貌似在我这里就只剩一条了😌.]]></content>
      <categories>
        <category>很难么</category>
      </categories>
      <tags>
        <tag>作用域</tag>
        <tag>闭包</tag>
        <tag>this</tag>
        <tag>内存泄漏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Object原型方法]]></title>
    <url>%2FObject%E5%8E%9F%E5%9E%8B%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[ObjectObject 构造函数用来包装成对象.概述Object 构造函数为给定值创建一个对象包装器. 如果给定值是 null 或 undefined, 将会创建并返回一个空对象. 否则, 将返回一个与给定值对应类型的对象.当以非构造函数形式被调用时, Object 等同于 new Object().原型方法Object.prototype.hasOwnProperty()描述 : 判断自身属性中是否有指定的属性.语法 :target.prototype.hasOwnProperty(prop)target : 目标对象.prop : 要检测的属性.123456789101112function Person(name) &#123; this.name = name&#125;Person.prototype.age = 18let person = new Person('yexiaochen')let boolean_1 = person.hasOwnProperty('name')let boolean_2 = person.hasOwnProperty('age')// &gt; boolean_1// true// &gt; boolean_2// falseObject.prototype.isPrototypeOf()描述 : 判断一个对象是否在另一个对象的原型链上.语法 :prototypeObject.isPrototypeOf(obj)obj : 提供原型链的对象.prototypeObject : 待检测的对象.123456789101112function Person() &#123;&#125;function Man()&#123;&#125;Man.prototype = Object.create(Person.prototype)let man = new Man()let boolean_1 = Person.prototype.isPrototypeOf(man)let boolean_2 = Man.prototype.isPrototypeOf(man)// &gt; boolean_1// true// &gt; boolean_2// trueObject.prototype.propertyIsEnumerable()描述 : 判断对象的指定属性是否可枚举. 原型链上继承来的属性除外. 如果对象没有指定的属性，则此方法返回false语法 :target.propertyIsEnumerable(prop)target : 目标对象.sources : 待检测的属性.123456789101112function Person(name) &#123; this.name = name&#125;Person.prototype.age = 18let person = new Person('yexiaochen')let boolean_1 = person.propertyIsEnumerable('name')let boolean_2 = person.propertyIsEnumerable('age')// &gt; boolean_1// true// &gt; boolean_2// falseObject.prototype.toString()描述 : 一个表示该对象的字符串语法 :target.toString()target : 目标对象.1234567891011function Person() &#123;&#125;let person = new Person()let str_1 = person.toString();let str_2 = Object.prototype.toString.call(person)let str_3 = Object.prototype.toString.call(Person)// &gt; str_1// '[object Object]'// &gt; str_2// '[object Object]'// &gt; str_3// '[object Function]'Object.prototype.valueOf()描述 : 对象转换为原始值. 如果对象没有原始值, 返回对象本身.语法 :target.valueOf()target : 目标对象.123456789101112131415161718192021222324let str = new String('hello world')let num = new Number(0)let boolean = new Boolean(true)let arr = [1,2,3]let func = function a()&#123;&#125;let obj = &#123;a: 'hello'&#125;str.valueOf()num.valueOf()boolean.valueOf()arr.valueOf()func.valueOf()obj.valueOf()// &gt; str.valueOf()// 'hello world'// &gt; num.valueOf()// 0// &gt; boolean.valueOf()// true// &gt; arr.valueOf()// [ 1, 2, 3 ]// &gt; func.valueOf()// [Function: a]// &gt; obj.valueOf()// &#123; a: 'hello' &#125;]]></content>
      <categories>
        <category>对象总结</category>
      </categories>
      <tags>
        <tag>Object</tag>
        <tag>对象原型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对象属性的属性]]></title>
    <url>%2F%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E7%9A%84%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[引子vue 的大行其道, 使得 Object.defineProperty 被更多人所认识. vue 利用 Object.defineProperty 提供的特性实现了数据绑定. 我们也可以据此动手实现一个简单的数据绑定(可参照进击的观察者模式).难道 Object.defineProperty 能做的只有这些么? 很显然不是.属性描述符The Property Descriptor type is used to explain the manipulation and reification of Object property attributes.属性描述符到底是什么? 说白了就是对象属性的属性解释与具化, 就是对象属性本身具有哪些属性.平时我们创建一个对象并为对象添加属性时, 可以这样12let obj = new Object()obj.a = 'hello world'有了对象字面量后, 想要达到同样的效果就更加省事了. 现在也都提倡使用字面量来创建对象.123let obj = &#123; a: 'hello world'&#125;所以说程序员都是懒人嘛, 怎么简单怎么来. 通过 Object.defineProperty 为对象添加属性的方式也就淡出人们的视野.同样是为对象添加属性, 它们有什么区别呢?程序员身体可以懒, 但脑子要勤快, 要始终保持一颗好奇心.其实不论是通过赋值, 还是通过字面量, 还是通过 Object.defineProperty, 最终还是殊途同归.讲真, 平时的开发中, 使用对象字面量创建对象并添加属性时,压根就不会考虑到对象属性非个人意愿的改变了. 在我们看来, 对象就是存储着键值、键值映射用的. 我们可以任意添加, 删除, 更改对象属性, 我们认为这是理所当然的. 现实也的确如此, 你有对它为所欲为的权利.添加属性的差异可是为什么呢?🧐😠你哪来的那么多为什么? 你为什么为什么呢!!!😠如果你稍微对 Object.defineProperty 有点了解, 应该知道通过这种方式定义的繁琐. 你也应该知道对象属性的操作也是有限制的. 想要放开权限, 我们需要这样做1234567let obj = &#123;&#125;Object.defineProperty(obj, 'a', &#123; value: 'hello world', configurable: true, enumerable: true, writable: true&#125;)对象字面量添加属性只是默认都为 true. 所以我们才可以为所欲为. 不相信么? 我们可以通过 Object.getOwnPropertyDescriptor 验证一下12345678let obj = &#123;&#125;obj.a = 'hello world'let property = Object.getOwnPropertyDescriptor(obj, 'a')// &gt; property// &#123; value: 'hello world',// writable: true,// enumerable: true,// configurable: true &#125;通过 Object.getOwnPropertyDescriptor 添加的属性, 可以自由灵活地设置属性描述符. 如果我不想配置的话, 它也有自己的默认值. 需要注意的是, 这里的默认值和对象字面量添加属性与赋值属性不同, 默认值为 false.12345678910let obj = &#123;&#125;Object.defineProperty(obj, 'a', &#123; value: 'hello world'&#125;)let property = Object.getOwnPropertyDescriptor(obj, 'a')// &gt; property// &#123; value: 'hello world',// writable: false,// enumerable: false,// configurable: false &#125;属性描述符等位数据描述符和访问描述符. 以上说的都是数据描述符.传闻中的Vue优化方案道理我都懂, 那你这句话是啥个意思?压根就不会考虑到对象属性非个人意愿的改变了.在 Vue 的 data 选项中，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 中的访问描述符 get/set 访问描述符重新定义一遍. 再结合观察者模式, 每次属性变化时都会收到通知, 从而达到数据绑定的效果. 显然并不是所有的属性都需要被转换监听.对于展示型的数据, 就没有必要也不会出现数据内部属性的变化, 所以没必要做以上的处理. Object.freeze (用法可见Object构造函数)处理后的对象, 就可以使得对象属性添加、修改等操作失效. 这样不去转换也不用去监听, 性能自然也就提高了.属性描述符键值枯燥的描述开始…数据描述符和访问描述符同事具有的键值configurable : 若为 false, 不能删除该属性, 不能切换属性描述符(数据描述符切到访问描述符,或访问描述符切到数据描述符), 不能更改该属性的属性(对于数据描述符来说, value 属性除外, Writable 属性从 true 置为 false 除外). 说白了就是属性描述符的开关, 管理着该属性的属性.123456789101112131415161718192021222324252627282930313233let obj = &#123;&#125;Object.defineProperty(obj, 'a', &#123; value: 'hello world', configurable: false, enumerable: true, writable: true&#125;)Object.defineProperty(obj, 'a', &#123; value: 'hi world',&#125;)let property_1 = Object.getOwnPropertyDescriptor(obj, 'a')Object.defineProperty(obj, 'a', &#123; value: 'hi world', writable: false&#125;)let property_2 = Object.getOwnPropertyDescriptor(obj, 'a')// &gt; property_1// &#123; value: 'hi world',// writable: true,// enumerable: true,// configurable: false &#125;// &gt; property_2// &#123; value: 'hi world',// writable: false,// enumerable: true,// configurable: false &#125;Object.defineProperty(obj, 'a', &#123; value: 'hi world', configurable: false, enumerable: false&#125;)// TypeErrorenumerable : 若为 true, 则在 for…in 枚举中可被枚举到.1234567891011let obj = &#123; a: 'hello world', b: 'hi world'&#125;Object.defineProperty(obj, 'c', &#123; value: 'hey world', enumerable: false&#125;)let propertyArray = Object.keys(obj)// &gt; propertyArray// [ 'a', 'b' ]仅数据描述符具有的键值value : 对象的该属性对应的值. 可以为任何有效的 JavaScript 值.writable : 若为false, 更改 value 将会失败.12345678910111213141516171819202122let obj = &#123;&#125;Object.defineProperty(obj, 'a', &#123; value: 'hello world', writable: false, configurable: true&#125;)obj.a = 'hi world'let property_1 = Object.getOwnPropertyDescriptor(obj, 'a')Object.defineProperty(obj, 'a', &#123; value: 'hey world'&#125;)let property_2 = Object.getOwnPropertyDescriptor(obj, 'a')// &gt; property_1// &#123; value: 'hello world',// writable: false,// enumerable: false,// configurable: true &#125;// &gt; property_2// &#123; value: 'hey world',// writable: false,// enumerable: false,// configurable: true &#125;从运行结果可以看出, 通过赋值更改属性值时, 会更改无效.但是通过 Object.defineProperty 更改时, 将会成功更改属性值. 对此, 规范有提到, 当可配置不可写时更改属性值,会有 Writable 置为 true, =&gt; 设置 value =&gt; Writable 置为 false.Step 8.b allows any field of Desc to be different from the corresponding field of current if current’s [[Configurable]] field is true. This even permits changing the [[Value]] of a property whose [[Writable]] attribute is false. This is allowed because a true [[Configurable]] attribute would permit an equivalent sequence of calls where [[Writable]] is first set to true, a new [[Value]] is set, and then [[Writable]] is set to false.通过赋值和 Object.defineProperty 方式修改 value, 可以看出它们内部操作还是存在着差异.仅访问描述符具有的键值get : 访问该属性时, 该方法都会被执行.set : 修改该属性时, 该方法都会被执行.vue 就是利用了访问描述符的这些特性, 实现了数据绑定.12345678910111213141516171819202122let obj = &#123;&#125;let valObject.defineProperty(obj, 'a', &#123; set(value) &#123; val = value console.log('set =&gt; value', val) &#125;, get() &#123; console.log('get =&gt; value', val) return val &#125;, configurable: true, enumerable: true&#125;)// &gt; obj// &#123; a: [Getter/Setter] &#125;// &gt; obj.a = 'hello world'// set =&gt; value hello world// 'hello world'// &gt; obj.a// get =&gt; value hello world// 'hello world']]></content>
      <categories>
        <category>属性描述符总结</category>
      </categories>
      <tags>
        <tag>属性描述符</tag>
        <tag>Object.defineProperty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Object构造函数]]></title>
    <url>%2FObject%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[ObjectObject 构造函数用来包装成对象.概述Object 构造函数为给定值创建一个对象包装器. 如果给定值是 null 或 *undefined, 将会创建并返回一个空对象. 否则, 将返回一个与给定值对应类型的对象.当以非构造函数形式被调用时, Object 等同于 new Object().构造函数方法Object.keys()描述 :获取给定对象自身可枚举属性(字符串)组成的数组.Object.keys(target)target : 目标对象.12345678910111213141516171819let obj = &#123; a: 'hello'&#125;Object.defineProperty(obj, 'b', &#123;value: 'world'&#125;)let property_1 = Object.getOwnPropertyDescriptor(obj, 'a')let property_2 = Object.getOwnPropertyDescriptor(obj, 'b')let propertyArray = Object.keys(obj);// &gt; property_1// &#123; value: 'hello',// writable: true,// enumerable: true,// configurable: true &#125;// &gt; property_2// &#123; value: 'world',// writable: false,// enumerable: false,// configurable: false &#125;// &gt; propertyArray// [ 'a' ]Object.values()描述 :获取给定对象自身可枚举属性值组成的数组.Object.values(target)target : 目标对象.12345678910111213141516171819202122let obj = &#123; a: 'hello', b: () =&gt; &#123; console.log('hello') &#125;&#125;Object.defineProperty(obj, 'c', &#123;value: 'world'&#125;)let property_1 = Object.getOwnPropertyDescriptor(obj, 'a')let property_2 = Object.getOwnPropertyDescriptor(obj, 'c')let valuesArray = Object.values(obj);// &gt; property_1// &#123; value: 'hello',// writable: true,// enumerable: true,// configurable: true &#125;// &gt; property_2// &#123; value: 'world',// writable: false,// enumerable: false,// configurable: false &#125;// &gt; valuesArray// [ 'hello', [Function: b] ]Object.entries()描述 :由给定对象自身可枚举属性的键值对数组组成的数组. 属性的顺序与通过 for...in 循环对象的属性值所给出的顺序相同.语法 :Object.entries(target)target : 目标对象.1234567891011let obj_1 = &#123; a: 'hello', b: 'word'&#125;let obj_2 = Object.entries(obj_1)// &gt; obj_2// [ [ 'a', 'hello' ], [ 'b', 'word' ] ]let map = new Map(obj_2)// &gt; map// Map &#123; 'a' =&gt; 'hello', 'b' =&gt; 'word' &#125;Object.create()描述 :创建一个新对象, 并将内部属性 [[Prototype]] 指向源对象.语法 :Object.create(sources[, Properties])sources : 提供原型的源对象.Properties : 为新对象添加属性, 规则如同 Object.defineProperties(obj, Prototype).1234567let obj_1 = &#123; a: 'hello', b: 'word'&#125;let obj_2 = Object.create(obj_1, &#123;name: &#123;value: 'obj_2'&#125;&#125;)&gt;obj_2// &#123;name: 'obj_2', _proto_: &#123;a: 'hello', b: 'word'&#125;&#125;Object.assign()描述 :将源目标(一个或多个)对象中的所有可枚举属性值复制到目标对象中. 如果目标对象和源对象中存在相同的属性(键), 后者的属性将覆盖前者的属性. 最终返回目标对象.语法 :Object.assign(target, ..sources)target : 目标对象.sources : 源对象.1234567891011121314151617181920212223let obj_1 = &#123; a: 'hello', b: 'word'&#125;let copy = Object.assign(&#123;&#125;, obj)// &gt; copy// &#123; a: 'hello', b: 'word' &#125;// &gt; obj_1// &#123; a: 'hello', b: 'word' &#125;// &gt; copy === obj_1// falselet obj_2 = &#123; a: 'hi', b: 'world'&#125;let obj_3 = &#123; a: 'hello', b: 'world'&#125;Object.assign(obj_2, obj_3)// &gt; obj_2// &#123; a: 'hello', b: 'world' &#125;Object.defineProperty()描述 :为对象定义一个新属性或修改现有属性.语法 :Object.defineProperty(target, prop, descriptor)target : 要在其上定义或修改属性的目标对象.prop : 要定义或修改的属性属性名称.descriptor : 将被定义或修改的属性描述符.123456789101112131415let obj = &#123;&#125;Object.defineProperty(obj, 'a', &#123; value: 'hello world', configurable: false, enumerable: true, writable: true&#125;)let property = Object.getOwnPropertyDescriptor(obj, 'a')// &gt; obj// &#123; a: 'hello world' &#125;// &gt; property// &#123; value: 'hello world',// writable: true,// enumerable: true,// configurable: false &#125;Object.defineProperties()描述 :为对象定义一个新属性或修改现有属性.语法 :Object.defineProperties(target, propsDescriptor)target : 要在其上定义或修改属性的目标对象.propsDescriptor : 将被定义或修改的属性描述符对象.1234567891011121314151617181920212223242526272829let obj = &#123;&#125;Object.defineProperties(obj, &#123; 'a': &#123; value: 'hello world', configurable: false, enumerable: true, writable: true &#125;, 'b': &#123; value: 'hi world', configurable: false, enumerable: true, writable: true &#125;&#125;)let property_a = Object.getOwnPropertyDescriptor(obj, 'a')let property_b = Object.getOwnPropertyDescriptor(obj, 'b')// &gt; obj// &#123; a: 'hello world', b: 'hi world' &#125;// &gt; property_a// &#123; value: 'hello world',// writable: true,// enumerable: true,// configurable: false &#125;// &gt; property_b// &#123; value: 'hi world',// writable: true,// enumerable: true,// configurable: false &#125;Object.getOwnPropertyDescriptor()描述 :获取指定对象上某个自有属性对应的属性描述符.(自有属性即直接赋予该对象的属性, 非原型链继上查找到的属性)语法 :Object.getOwnPropertyDescriptor(target, prop)target : 目标对象.prop : 目标对象的属性名称.123456789101112131415161718192021let obj_1 = &#123; a: 'hello', b: &#123; c: 'world' &#125;, get c() &#123; return 'c' &#125;&#125;let obj_2 = Object.getOwnPropertyDescriptor(obj_1, 'a')let obj_3 = Object.getOwnPropertyDescriptor(obj_1, 'c')// &gt; obj_2// &#123; value: 'hello',// writable: true,// enumerable: true,// configurable: true &#125;// &gt; obj_3// &#123; get: [Function: get c],// set: undefined,// enumerable: true,// configurable: true &#125;Object.getOwnPropertyNames()描述 :获取指定对象的所有自有属性的属性名(包括不可枚举属性但不包括 Symbol 值作为名称的属性)组成的数组.语法 :Object.getOwnPropertyNames(target)target : 目标对象.prop : 目标对象的属性名称.123456789101112let obj_1 = &#123; a: 'hello', b: &#123; c: 'world' &#125;, get c() &#123; return 'c' &#125;&#125;let arr = Object.getOwnPropertyNames(obj_1)// &gt; arr// [ 'a', 'b', 'c' ]Object.getOwnPropertySymbols()描述 :获取给定对象所有的 Symbol 属性的数组.语法 :Object.getOwnPropertyNames(target)target : 目标对象.123456let obj = &#123;&#125;let a = Symbol('a')obj[a] = 'hello'var arr = Object.getOwnPropertySymbols(obj)// &gt; arr// [ Symbol(a) ]Object.preventExtensions()描述 :使得对象变得不可扩展. 即设置对象内部 [[Extensible]] 值为 false.Object.preventExtensions(target)target : 目标对象.12345678910111213141516171819202122232425let obj_1 = &#123; a: 'hello', b: &#123; c: 'world' &#125;&#125;let property_1 = Object.getOwnPropertyDescriptor(obj_1, 'a')let boolean_1 = Object.isExtensible(obj_1)Object.preventExtensions(obj_1)let property_2 = Object.getOwnPropertyDescriptor(obj_1, 'a')let boolean_2 = Object.isExtensible(obj_1)// &gt; property_1// &#123; value: 'hello',// writable: true,// enumerable: true,// configurable: true &#125;// &gt; property_2// &#123; value: 'hello',// writable: true,// enumerable: true,// configurable: true &#125;// &gt; boolean_1// true// &gt; boolean_2// falseObject.seal()描述 :使得对象变得不可扩展. 即设置对象内部 [[Extensible]] 值为 false. 对象属性的 [[Configurable]] 为 false.Object.seal(target)target : 目标对象.12345678910111213141516171819202122232425let obj_1 = &#123; a: 'hello', b: &#123; c: 'world' &#125;&#125;let property_1 = Object.getOwnPropertyDescriptor(obj_1, 'a')let boolean_1 = Object.isExtensible(obj_1)Object.seal(obj_1)let property_2 = Object.getOwnPropertyDescriptor(obj_1, 'a')let boolean_2 = Object.isExtensible(obj_1)// &gt; property_1// &#123; value: 'hello',// writable: true,// enumerable: true,// configurable: true &#125;// &gt; property_2// &#123; value: 'hello',// writable: true,// enumerable: true,// configurable: false &#125;// &gt; boolean_1// true// &gt; boolean_2// falseObject.freeze()描述 :冻结一个对象, 将不能向该对象添加新的属性, 不能修改、删除已有属性, 以及不能修改已有属性的可枚举性、可配置性、可写性. 如果属性是对象, 除非被冻结, 否则也是可以修改的. 数组作为对象, 被冻结后, 元素不可被修改. [[Extensible]] 内部属性为 false. 对象属性的 [[Configurable]] 为 false. 若是对象属性描述符为数据描述符, 则对象属性的 [[Writable]] 为 false.语法 :Object.freeze(target)target : 目标对象.1234567891011121314151617181920212223242526272829let obj_1 = &#123; a: 'hello', b: &#123; c: 'world' &#125;&#125;let property_1 = Object.getOwnPropertyDescriptor(obj_1, 'a')let boolean_1 = Object.isExtensible(obj_1)Object.freeze(obj_1)let property_2 = Object.getOwnPropertyDescriptor(obj_1, 'a')let boolean_2 = Objct.isExtensible(obj_1)obj_1.a = 'hi'obj_1.b.c = '世界'// &gt; obj_1// &#123; a: 'hello', b: &#123; c: '世界' &#125; &#125;// &gt; property_1// &#123; value: 'hello',// writable: true,// enumerable: true,// configurable: true &#125;// &gt; property_2// &#123; value: 'hello',// writable: false,// enumerable: true,// configurable: false &#125;// &gt; boolean_2// true// &gt; boolean_2// falseObject.isExtensible()描述 :判断一个对象是否可扩展的. 即是否可添加新的属性. 新对象 [[Extensible]] 默认为 true . Object.preventExtensions(target), Object.seal(target) 或 Object.freeze(target) 可将目标对象内部属性 [[Extensible]] 置为 false.语法 :Object.isExtensible(target)target : 目标对象.12345678let obj = &#123;&#125;let boolean_1 = Object.isExtensible(obj)Object.freeze(obj)let boolean_2 = Object.isExtensible(obj)// &gt; boolean_1// true// &gt; boolean_2// falseOObject.isSealed()描述 :判断一个对象是否被密封. 若对象的内部属性 [[Extensible]] 为 false, 返回 true. 若对象属性的 [[Configurable]] 为 true, 返回 false. 否则, 返回 false.语法 :Object.isSealed(target)target : 目标对象.123456789101112let obj = &#123;&#125;let boolean_1 = Object.isFrozen(obj)Object.defineProperty(obj, 'a', &#123;configurable: false&#125;)let boolean_2 = Object.isFrozen(obj)Object.preventExtensions(obj)let boolean_3 = Object.isFrozen(obj)// &gt; boolean_1// false// &gt; boolean_2// false// &gt; boolean_3// trueObject.isFrozen()描述 :判断一个对象是否被冻结. 若对象的内部属性 [[Extensible]] 为 false, 返回 true. 若对象属性的 [[Configurable]] 为 true, 返回 false. 若是对象属性描述符为数据描述符, 对象属性的 [[Writable]] 为 true, 返回 false. 否则, 返回 false.语法 :Object.isFrozen(target)target : 目标对象.12345678910111213141516171819202122232425let obj = &#123;&#125;let boolean_1 = Object.isFrozen(obj)Object.freeze(obj)let boolean_2 = Object.isFrozen(obj)// &gt; boolean_1// true// &gt; boolean_2// falselet obj = &#123;&#125;let boolean_1 = Object.isFrozen(obj)Object.defineProperty(obj, 'a', &#123;writable: false&#125;)let boolean_2 = Object.isFrozen(obj)Object.defineProperty(obj, 'a', &#123;configurable: false&#125;)let boolean_3 = Object.isFrozen(obj)Object.preventExtensions(obj)let boolean_4 = Object.isFrozen(obj)// &gt; boolean_1// false// &gt; boolean_2// false// &gt; boolean_3// false// &gt; boolean_4// trueObject.setPrototypeOf()描述 :使得对象变得不可扩展. 即设置对象内部 [[Extensible]] 值为 false. 对象属性的 [[Configurable]] 为 false.Object.setPrototypeOf(target, prototype)target : 目标对象.prototype : 原型对象(对象或 null).123456let obj_1 = &#123;a: 1&#125;let obj_2 = &#123;b: 2&#125;Object.setPrototypeOf(obj_2, obj_1)let proto_1 = Object.getPrototypeOf(obj_2)// &gt; proto_1// &#123; a: 1 &#125;Object.getPrototypeOf()描述 :获取给定对象的原型(内部 [[Prototype]] 属性的值). 若没有即成属性, 则返回 null.语法 :Object.getOwnPropertyNames(target)target : 目标对象.12345678910111213function Person() &#123;&#125;let person = new Person()let a = Object.getPrototypeOf(person)// &gt; a// Person &#123;&#125;let obj = &#123;&#125;let obj_1 = Object.create(obj)let obj_2 = Object.getPrototypeOf(obj_1)// &gt; obj_2// &#123;&#125;// &gt; obj_2 === obj// trueObject.is()描述 :判断两个值是否相等. 规则和抽象相等、严格相等不一样.语法 :Object.is(target1, target2)target : 需要比较的两个值.1234567Object.is(undefined, undefined) // trueObject.is(null, null) // trueObject.is(true, true) // trueObject.is(false, false) // trueObject.is(+0, +0) // trueObject.is(NaN, NaN) // true *Object.is(-0, -0) //true]]></content>
      <categories>
        <category>对象总结</category>
      </categories>
      <tags>
        <tag>构造函数</tag>
        <tag>Object</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记不住的继承方式]]></title>
    <url>%2F%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[记不住的继承方式都说程序员是这个世界上最懒的人, 能躺着绝不坐着, 全干着复制黏贴的活.‘什么, 你说这套逻辑之前写过?!?! 速速把代码呈上来!!!’.最懒的人往往信奉着‘拿来主义’. 若只是简单的复制黏贴, 就会显得没有逼格.在 JavaScript 中, 重复用到的逻辑我们会用函数包装起来, 在合适且需要的情况下, 调用该函数即可. 而 apply, call, new 等方法也拓宽了函数的使用场景.除了这种借来的, 我们还有继承来的. 这就是常说的原型继承. 当对象本身没有要查询的属性或方法时, 它会沿着原型链查找, 找到了就会拿来使用. 这种’无’中生有的事, 不妨了解一下.预备知识默认情况下, 所有的原型对象都会自动获得一个 constructor (构造函数)属性, 这个属性是一个指向 prototype 属性所在函数的指针. 构造函数的原型 prototype 上 constructor 的初始值是构造函数本身. 即,1Function.prototype.constructor === Function // true由构造函数构造出来的实例本身没有 constructor 属性, 不过可以通过原型链继承这个属性.1234567// 以下person的constructor属性继承自Person.prototypefunction Person() &#123;&#125;Person.prototype.constructor === Person // truelet person = new Person();person.constructor === Person // trueperson.hasOwnProperty('constructor') === false // trueperson_1.constructor === Person.prototype.constructor // true简单数据类型和复杂数据类型赋值传参的区别.JavaScript 中变量不可能成为只想另一个变量的引用. 引用指向的是值. 复杂数据类型的引用指向的都是同一个值.它们相互之间没有引用/指向关系. 一旦值发生变化, 指向该值的多个引用将共享这个变化.new, apply, call 的函数调用模式.三者的共同点都是都是指定调用函数的 this 值. 这使得同一个函数可以在不同的语境下正确执行. new 更为复杂一些. 可大致模拟为,12345function new(constructor, arguments) &#123; let instance = Object.create(constructor.prototype) // 姑且称之为 new 的特性一 constructor.apply(instance, arguments) // 姑且称之为 new 的特性二 return instance&#125;很明显, new 的操作中包涵了 apply, call 要做的事. 在此大胆猜测一下, 在实现继承的过程中, 一旦同时出现 new 和 apply 或 call, 就会有重复交集的可能, 这时就需要想想是否有可以改进的地方.不着痕迹的拿来主义‘各单位请注意, 下面到我表演地时候了’‘上道具!’12345function Animal(name) &#123; this.name = name&#125;Animal.prototype.species = 'animal'function Leo() &#123;&#125; // 我是头小狮子想要无中生有, 那是不可能的😏, 所以我们准备了模板 Animal. Animal 有的东西, Leo 也想拥有.而且 Animal 能用地东西也同样适用于 Leo.所以, 我们期待 Leo 最终长成这个样子.1234function Leo(name) &#123; this.name = name&#125;Leo.prototype.species = 'animal'‘就长这副熊样!? 这和简单的复制黏贴有什么区别!? 这和咸鱼又有什么区别!？ 说好的逼格呢！？’观察一下 Leo, Leo 构造函数内部逻辑和 Animal 构造函数的内部逻辑如出一辙. 既然都是一样的, 为什么不能借来用用呢? 改造一下,12345678function Animal(name) &#123; this.name = name&#125;Animal.prototype.species = 'animal'function Leo(name) &#123; Animal.call(this, name)&#125;这种在构造函数内部借函数而不借助原型继承的方式被称之为 借用构造函数式继承.把属性和方法放在构造函数内部的定义, 使得每个构造出来的实例都有自己的属性和方法. 而对一些需要实例间共享的属性或方法却是没辙.当然了, 我们本来就没打算止步于此. 构造函数内部可以靠借, 那原型上呢? 如何让 Leo 的原型上能和 Animal 的原型保持一致呢?‘这不是废话么? 我除了会借, 我还会继承啊, 原型继承啊!!!’关于原型链, 我们已经知道是怎么一回事了(不知道的可参考从Function入手原型链).原型继承就是通过原型链实现了对象本身没有的属性访问和方法调用. 利用这个特性, 我们可以在原型上做些手脚.思路一: 可以使得 Leo 的 prototype 直接指向 Animal 的 prototype.123456789function Animal(name) &#123; this.name = name&#125;Animal.prototype.species = 'animal'function Leo(name) &#123; Animal.call(this, name)&#125;Leo.prototype = Animal.prototype这里有一点需要注意的, Leo.prototype = Animal.prototype 这种写法就等于完全覆写了 Leo 的原型, Leo.prototype.constructor 将和 Animal.prototype.constructor 保持一致, 这会使得一些等式显得诡异.不信, 请看:1Leo.prototype.constructor === Animal.prototype.constructor === Animal针对这种情况, 我们往往会做一些修正:123// 接上例代码省略Leo.prototype = Animal.prototypeLeo.prototype.constructor = Leo即使修正好了, 可是还有个大问题.那就是, 如果想给 Leo 原型添加属性或方法, 将会影响到 Animal, 进而会影响到所有 Animal 的实例. 毕竟它们的原型之间已经画了等号.1234567// 接上例代码省略let Dog = new Animal('dog')Dog.sayName // undefinedLeo.prototype.sayName = function() &#123; console.log(this.name)&#125;Dog.sayName() // dog‘我只想偷个懒, 没想过要捣乱啊😲!!!’为了消除这种影响, 我们需要一个中间纽带过渡. 还好我们知道 new 可以用来修改原型链.思路二: Leo 的 prototype 指向 Animal 的实例.12345678910function Animal(name) &#123; this.name = name&#125;Animal.prototype.species = 'animal'function Leo(name) &#123; Animal.call(this, name)&#125;Leo.prototype = new Animal()Leo.prototype.contructor = Leo这种在构造函数内部借函数同时又借助原型继承的方式被称之为 组合继承. Leo 换个角度其实长这样:12345678function Leo(name) &#123; this.name = name&#125;Leo.prototype = &#123; constructor: Leo, name: undefined, __proto__: Animal.prototype&#125;在这种继承模式中, Leo 的实例可以有自己的属性和方法, 实例之间又可以通过 prototype 来共享属性和方法却不会影响 Animal, 还可以通过 _proto_ 追溯到 Animal.prototype.一切都很完美👏. 不过还记得文章开始时所说的么在实现继承的过程中, 一旦同时出现 new 和 apply 或 call, 就会有重复交集的可能, 这时就需要想想是否有可以改进的地方.Animal 被调用了两次, 第一次是 Leo 构造函数内部作为一个普通函数被调用, 第二次是被作为构造函数构造一个实例充当 Leo 的原型.Animal 内部定义的属性和方法同时出现在 Leo 的原型和 Leo 的实例上. 实例上有的东西就不会再到原型上查找. 反之, 实例上没有的东西才会到原型上查找. 显然, 有多余的存在.‘这不是最优解, 我要最好的! 下一个!’思路三: 既然有重复, 那就去其一呗. 既然 new 比 call 和 apply 厉害, 那就留着 new 吧.12345678function Animal(name) &#123; this.name = name&#125;Animal.prototype.species = 'animal'function Leo(name) &#123;&#125;Leo.prototype = new Animal()Leo.prototype.contructor = Leo这种在构造函数内部不借函数只借助原型继承的方式被称之为 原型链继承.经过这么一折腾, 发现不好的地方有增无减. 实例没了自己的属性和方法了, 连 Animal 构造函数内部定义的属性方法都可以在实例间共享了(思路二也存在这个问题), 而且参数也不给传了.‘我要的不多, 能轻点折腾不, 心脏不好’回到 思路二, 那就删了 new 吧.思路四: 接上 思路二, 删了 new, 那只能在原型上做调整了.我们从一开始就只是希望 Leo 的 prototype 指向 Animal 的 prototype, 不多不少且不会出现 思路一 的坏影响.既然不能直接在两者之间画等号, 就造一个过渡纽带呗. 能够关联起原型链的不只有 new, Object.create() 也是可以的.创建一个 _proto_ 指向 Animal.prototype 的对象充当 Leo 的原型不就解决问题了么.12345678910function Animal(name) &#123; this.name = name&#125;Animal.prototype.species = 'animal'function Leo(name) &#123; Animal.call(this, name)&#125;Leo.prototype = Object.create(Animal.prototype)Leo.prototype.contructor = Leo这种在构造函数内部借函数同时又间接借助原型继承的方式被称之为 寄生组合式继承.这种模式完美解决了 思路二 的弊端. 算是较为理想的继承模式吧.‘确认过眼神, 你才我想要的!’以上还是只是构造函数间的继承, 还有基于已存在对象的继承, 譬如, 原型式继承 和 寄生式继承等.讲真, 说了辣么多, 我还真没记住 借用构造函数式继承, 组合继承, 原型链继承, 寄生组合式继承, 原型式继承, 寄生式继承等.‘你没记住这么多模式, 那你都记住什么了’答曰: 要想很好得继承, 一靠朋友, 二靠拼爹.‘这孩子是不是傻? 这都什么年代了? 再说了, 就没人告诉你你家里有矿???’思路五: ES6 引入了 Class（类）这个概念，通过 class 关键字，可以定义类, Class 实质上是 JavaScript 现有的基于原型的继承的语法糖. Class 可以通过extends关键字实现继承. 我们可以对 思路四 来个华丽变身.123456789101112class Animal &#123; constructor(name) &#123; this.name = name &#125;&#125;Animal.prototype.species = 'animal'class Leo extends Animal &#123; constructor(name) &#123; super(name) &#125;&#125;经过这么一处理后行为上和 思路四 基本没什么区别, constructor(){} 充当了之前的构造函数, super() 作为函数调用扮演着 Animal.call(this, name) 的角色(还可以表示父类). 最重要的是 Leo 的 _proto_ 也指向了 Animal.‘矿多基因好, 啧啧啧, 我都快要喜欢上我自己了😏’]]></content>
      <categories>
        <category>很难么</category>
      </categories>
      <tags>
        <tag>JavaScript继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[让Python漫步在浏览器上]]></title>
    <url>%2F%E8%AE%A9Python%E6%BC%AB%E6%AD%A5%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8A%2F</url>
    <content type="text"><![CDATA[随着人工智能技术的普及，越来越多的前端程序员开始关注相关技术。Python 作为人工智能领域最常用的语言，与前端程序员日常使用的语言 JavaScript 同属脚本语言，且在两者发展过程中，社区也多有相互借鉴之处，因此有很多相似。一个熟悉 JavaScript 语言的前端程序员，通过掌握了他们之间的不同之处，可以快速上手 Python.如何快速上手? 对于一个前端程序员来说, 如果能够在熟悉的浏览器环境下学习, 最好不过了. 所以, 那就手撸一个 Pathon 在线编程. 而本文的重点则是本地文件的操作, 以下所有代码可见在线demo.File APIFileReader将 File 和 Blob 类型的文件或数据异步读入内存.InstanceOfFileReader PropertiesinstanceOfFileReader.error(只读) : 在读取时的出现的错误.instanceOfFileReader.readyState(只读) : 提供读取操作时的状态.Value(readyState)State(FileReader)Description0EMPTY未加载任何数据1LOADING加载数据中2DONE已完成数据读取instanceOfFileReader.result(只读) : 读取的结果, 要么是 String, 要么是 ArrayBuffer, 这取决于读取的方法, 且仅在 load 事件触发后可用.InstanceOfFileReader MethodsinstanceOfFileReader.abort() : 终止读取操作.instanceOfFileReader.readAsArrayBuffer() : 以 ArrayBuffer 类型为输出结果进行读取.instanceOfFileReader.readAsDataURL() : 以 Data URLs 类型为输出结果进行读取.instanceOfFileReader.readAsText() : 以 String 类型为输出结果进行读取.InstanceOfFileReader Eventsonloadstart/loadstart : 在读取操作开始时触发.onprogress/progress : 在读取过程中触发以汇报当前读取进度.onload/load : 在读取操作成功完成时触发.onabort/abort : 因调用 abort() 而终止读取时触发.onerror/error : 在读取时遇到错误时触发.onloadend/loadend : 在读取操作完成时触发(无论成功或失败).12&lt;!-- html --&gt;&lt;input type='file' onchange='openFile(event)'&gt;123456789101112131415161718192021222324252627282930313233343536373839404142// jsconst stateNames = &#123; [FileReader.EMPTY] : 'EMPTY', [FileReader.LOADING] : 'LOADING', [FileReader.DONE] : 'DONE'&#125;;let openFile = function(event) &#123; let input = event.target; let reader = new FileReader(); // 打开注解即可查看隐藏属性 // reader.onloadstart = function() &#123; // reader.abort(); // &#125;; reader.onprogress = function(e) &#123; console.log('Event: ', e.type) &#125;; reader.onload = function(e) &#123; console.log('Event: ', e.type) &#125;; reader.onloadend = function(e) &#123; console.log('Event: ', e.type) console.log(reader.error.message); &#125;; reader.onabort = function(e) &#123; console.log('Event: ', e.type) &#125; reader.onerror = function(e) &#123; console.log('Event: ', e.type) console.log(reader.error.message); &#125; reader.onload = function()&#123; let dataURL = reader.result; console.log('ReadyState: ' + stateNames[reader.readyState]); console.log('Result: ', dataURL) &#125;; console.log('ReadyState: ' + stateNames[reader.readyState]); // 打开注解即可查看隐藏属性 // reader.readAsDataURL(input.files[0]); // reader.readAsArrayBuffer(input.files[0]) reader.readAsText(input.files[0]) console.log('ReadyState: ' + stateNames[reader.readyState]);&#125;;Blob原始数据的不可变对象. File 就是衍生于 Blob.当 Blob 作为构造函数时, new Blob(blobParts, blobPropertyBag) 接受两个参数 :=&gt; blobParts : ArrayBuffer, ArrayBufferView, Blob, 或 String 对象类型之一.=&gt; blobPropertyBag({type, endings}) : type=&gt; MIME类型. endings(transparent|native) =&gt; 用于指定包含行结束符 \n 的字符串如何被写入.InstanceOfBlob PropertiesinstanceOfBlob.size(只读) : 所包含数据的大小(以字节为单位).instanceOfBlob.type(只读) : 所包含数据的MIME类型, 如果类型未知，则该值为空字符串.InstanceOfBlob MethodsinstanceOfBlob.slice([start, [end, [contentType]]]) : 创建基于原 Blob 对象指定字节范围内的数据的新 Blob 对象, 并赋予新 Blob 对象指定类型. 异于 Array.slice() 和 String.slice()12345678// jslet blob = new Blob( new String('hello world'), &#123;type: 'plain/text',endings: 'native'&#125;);let reader_1 = new FileReader();reader_1.onload = function() &#123; let result = reader_1.result; console.log('result: ', result, 'type: ', blob.type, 'size: ', blob.size)&#125;reader_1.readAsText(blob);FileFile 是 Blob 的一种特殊类型, 所以适用 Blob 的场景也同样适用于 File.File 对象可以是来自用户在一个 &lt;input&gt; 元素上选择文件后返回的 FileList 对象, 也可以来自拖放操作生成的 DataTransfer 对象, 还可以是来自在一个 HTMLCanvasElement 上执行 mozGetAsFile() 方法后返回结果.当 File 作为构造函数时, 较类似于 Blob.new File(fileParts[, name[, filePropertyBag]]) 接受两个参数 :=&gt; fileParts : ArrayBuffer, ArrayBufferView, Blob, 或 String 对象类型之一.=&gt; name : 文件名称或文件路径.=&gt; blobPropertyBag({type, endings}) : type=&gt; MIME类型. endings(transparent|native) =&gt; 用于指定包含行结束符 \n 的字符串如何被写入.InstanceOfFile PropertiesinstanceOfFile.lastModified(只读) : 当前文件最后修改时间, 自 1970年1月1日0:00 以来的毫秒数.instanceOfFile.lastModifiedDate(只读) : 当前文件最后修改时间.instanceOfFile.name(只读) : 当前文件的名称.instanceOfFile.webkitRelativePath(只读) : 当前文件的路径.instanceOfFile.size(只读) : 当前文件的大小(以字节为单位).instanceOfFile.type(只读) : 当前文件的MIME类型.InstanceOfFile Methods继承使用 Blob 的方法.FileReaderSync以同步的方式读取 File 或 Blob 对象中的内容, 仅在 workers 里可用, 因为在主线程里进行同步 I/O 操作可能会阻塞用户界面. 有着和 FileReader 相同的读取方法.URL提供了将 Blob 生成 url 的方法, 可使本地内容生成 url 传给接受 url 的 API.URL MethodsURL.createObjectURL() : 为指定的 File 或 Blob 或 MediaSource 对象创建一个新的 url.Lifetime of blob URLsURL.revokeObjectURL() : 释放之前生成的 url.123&lt;!-- html --&gt;&lt;input type='file' accept='image/*' onchange='uploadPicture(event)'&gt;&lt;div id='picture'&gt;&lt;/div&gt;12345678910111213141516171819202122232425262728293031323334// jslet picture = document.getElementById('picture');let uploadPicture = function(event) &#123;let target = event.target;let file = target.files[0];// URLlet img = document.createElement('img');let url = URL.createObjectURL(file);img.width = 300;img.src = url;img.onload = function() &#123; URL.revokeObjectURL(url);&#125;;picture.appendChild(img);// Auto downloadlet downLink = document.createElement('a');let downUrl = URL.createObjectURL(file, &#123; type: 'image/*' &#125;);downLink.download = `picture.png`;downLink.href = downUrl;downLink.click();URL.revokeObjectURL(downUrl);// FileReaderlet reader_3 = new FileReader();reader_3.onload = function() &#123; let result = reader_3.result; let img = document.createElement('img'); img.width = 300; img.src = result; picture.appendChild(img);&#125;reader_3.readAsDataURL(file);&#125;]]></content>
      <categories>
        <category>File API 总结</category>
      </categories>
      <tags>
        <tag>File API</tag>
        <tag>FileReader</tag>
        <tag>Blob</tag>
        <tag>URL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Function原型方法]]></title>
    <url>%2FFunction%E5%8E%9F%E5%9E%8B%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[FunctionFunction 作为构造函数用来创建一个新的 Function 对象.概述详见从Function入手原型链. Function 用来创建函数对象, 而 Function 本身也是函数, 所以有一个让很多人困扰的地方.1Object.getPrototypeOf(Function) === Function.prototype // true原型方法Function.prototype.toString()描述 :返回一个表示当前函数源代码的字符串.语法 :function.toString()在内置函数或由 Function.prototype.bind 返回的函数上调用该方法, 则有:1234567891011String.toString()// "function String() &#123; [native code] &#125;"Number.toString()// "function Number() &#123; [native code] &#125;"String.bind(null).toString()// "function () &#123; [native code] &#125;"Number.bind(null).toString()// "function () &#123; [native code] &#125;"普通函数调用该方法, 则有:123456(function() &#123;&#125;).toString()// "function() &#123;&#125;"function man(params) &#123;console.log(params)&#125;man.toString()// "function man(params) &#123;console.log(params)&#125;"非 Function 对象调用该方法, 会抛出 TypeError.12Function.prototype.toString.call(&#123;&#125;)// TypeError: Function.prototype.toString requires that 'this' be a FunctionFunction.prototype.apply()描述 :为调用的函数指定 this 值, 即 this 的执行上下文, 并以数组的形式传入参数.语法 :function.apply(thisArg, argArray)thisArg : 用于改变函数体内部 this 指向的 context. 当 argArray 为 undefined 或 null 时, thisArg 将替换成全局对象. 为基本类型值时, 将会被包装成相应的对象. 否则将不会做任何改变.argArray : 数组或类数组对象. argArray 里的元素将逐个放入参数列表中. 若检测 argArray 不是对象, 将会抛出 TypeError 错误.123456789101112131415161718192021222324252627282930313233343536373839const man = &#123; age: 18, sex: 'man', saySex() &#123; console.log(`I am a $&#123;this.sex&#125;`) &#125;&#125;const women = &#123; age: 16, sex: 'women'&#125;man.saySex.apply(women)// I am a women------------------------------function log_1(arg) &#123; console.log(arg)&#125;log_1(1);log_1(1,2,3);// 1// 1function log_2() &#123; const log = console.log; log.apply(null, arguments)&#125;log_2(1);log_2(1, 2, 3)// 1// 1 2 3------------------------------let a = ['h','e','l','l','o'];let b = ['w','o','r','l','d'];let push = Array.prototype.push;push.apply(a, b);console.log(a);// [ 'h', 'e', 'l', 'l', 'o', 'w', 'o', 'r', 'l', 'd' ]Function.prototype.call()描述 :为调用的函数指定 this 值, 即 this 的执行上下文, 并以列表的形式传入参数.语法 :function.call(thisArg[ , arg1 [ , arg2, …, argN]])thisArg : 用于改变函数体内部 this 指向的 context. 当 argArray 为 undefined 或 null 时, thisArg 将替换成全局对象. 为基本类型值时, 将会被包装成相应的对象. 否则将不会做任何改变.argN : 入参将从左到右的顺序加入到参数列表中.123456789101112131415161718function Person(name, age) &#123; this.name = name; this.age = age;&#125;function Man(name, age) &#123; Person.call(this, name, age); this.sex = 'man';&#125;const Adam = new Man('Adam', 18);console.log(Adam)// Man &#123; name: 'Adam', age: 18, sex: 'man' &#125;------------------------------let a = ['h','e','l','l','o'];let push = Array.prototype.push;push.call(a, 'w','o','r','l','d');console.log(a);// [ 'h', 'e', 'l', 'l', 'o', 'w', 'o', 'r', 'l', 'd' ]Function.prototype.bind()描述 :创建一个新的绑定函数, 为函数指定 this 值, 即 this 的执行上下文, 并以列表的形式传入参数.语法 :function.bind(thisArg[ , arg1 [ , arg2, …, argN]])thisArg : 调用绑定函数时作为this参数传递给目标函数的值.argN : 当目标函数被调用时，预先添加到绑定函数的参数列表中的参数.1234567891011121314151617for(var i = 0; i &lt;= 3; i++) &#123; setTimeout((function(i) &#123; console.log('i', i) &#125;).bind(null, i), 1000)&#125;// 0// 1// 2// 3------------------------------// 类数组转数组let argArray = Array.prototype.slice.call(arguments);// 或let slice = Array.prototype.slice;let boundSlice = Function.prototype.call.bind(slice);boundSlice(arguments);]]></content>
      <categories>
        <category>Function总结</category>
      </categories>
      <tags>
        <tag>Function</tag>
        <tag>Function原型</tag>
        <tag>apply</tag>
        <tag>call</tag>
        <tag>bind</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从Function入手原型链]]></title>
    <url>%2F%E4%BB%8EFunction%E5%85%A5%E6%89%8B%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[FunctionFunction 是函数? 是构造函数? 还是函数对象? 在翻阅 ECMA 规范时, 这几个名词也是无缝切换中, 稍不留神就可能跑偏了.都应该知道, 构造函数是用来打造具有相同属性和行为事物的模具.在作为构造函数之前, 它首先是个函数, 函数是可以被调用的(这也是区别于其它对象的因素). 它是由一系列语句组成, 并最终返回一个值. 每一个函数被创建的时候, 都有一个 prototype 属性.普通函数能够变成构造函数, 那都是 new 将函数的 prototype 和生成的实例关联起来了. 换句话说, 每个普通函数都有称为构建函数的潜质.12345678910111213141516// 常见的构造函数模式function Man(name) &#123; this.name = name; this.sex = 'man';&#125;Man.prototype.sayHi = function() &#123; console.log('hello', this.name)&#125;let man_1 = new Man('夜曉宸');// 我是普通函数function man(name) &#123; console.log('hello', name)&#125;// 只要经过 new 调教后, 我也可以被称为构造函数了let man_2 = new man('夜曉宸');Function和内置函数都说函数是 JavaScript 里的头等对象, 这话一点不假. 在 为强制类型转换正名 里已经提到过, JavaScript 里的数据类型除了基本数据类型, 就是复杂数据类型. 而这些复杂数据类型都和 Function 有着密切关系.Function构造函数函数的身影在 JavaScript 中随处可见, 有造字符串类型的 String 函数, 有造数值类型的 Number 函数, 除了这些内置函数, 还有上面我自己写的 Man 和 man 函数. JavaScript 的作者在写 JavaScript 语言的时候, 可能知道有且需要 String, Number 这样的函数处理写数据, 于是有了内置函数这么一说. 那么内置函数满足不了我们的需求呢, 如何去创建一个函数呢? 其实, 在没有这些内置函数之前, 就有了这么一个东西. 那就是为创建函数而生的函数 —— Function. 等会儿, 有点绕😵, 创建函数的函数? 那岂不是把自己也给创建了🤔? 是的, 没错, 就是这么一个奇葩的存在.The Function constructor is the %Function% intrinsic object and the initial value of the Functionproperty of the global object. When Functionis called as a function rather than as a constructor, it creates and initializes a new Function object. Thus the function call Function(…)is equivalent to the object creation expression new Function(…)with the same arguments.所以说, 包括这些内置函数, 它们都是由 Function 构建函数造出来的. 如何去验证函数是不是函数造出来的呢?new操作符All ordinary objects have an internal slot called [[Prototype]]. The value of this internal slot is either null or an object and is used for implementing inheritance.每个普通对象都有一个 [[Prototype]], 这个属性就是用来实现原型继承用的.上面👆也提到了, 在用构造函数造 new 出实例对象时, 实例对象内部的 [[Prototype]] 会关联到构造函数的 prototype 所指向的对象. new 主要做以下两件事:将实例对象的 [[Prototype]] 关联到构造函数的 prototype 上.将 this 绑定到新创建的实例对象上, 并调用构造函数(就是将函数体里的语句执行一遍).类似于:1234567function New(func) &#123; const obj = &#123;&#125;; // _proto_ 和 [[Prototype]] 不是同一个东西, 后者是内部使用的. ojb._proto_ = func.prototype; func.call(obj); return obj;&#125;Object.getPrototypeOf() 是用来检测指定对象内部 [[Prototype]] 属性的值.对于上面👆的 Man 和 man_1 关系, 试一波.1Object.getPrototypeOf(man_1) === Man.prototype // true;Function和函数回头再看看 String, Number, Boolean, Array, Object, Function, RegExp, Date, Error, Symbol 这些内置函数和 Function 构造函数的关系(注意包含了 Function 自身). 这里是把这些内置函数作为由 Function 构造出来的实例对象对待的. (函数也是对象的一子类型)1234567891011121314151617181920212223Object.getPrototypeOf(String) === Function.prototype // trueObject.getPrototypeOf(Number) === Function.prototype // trueObject.getPrototypeOf(Boolean) === Function.prototype // trueObject.getPrototypeOf(Array) === Function.prototype // trueObject.getPrototypeOf(Object) === Function.prototype // trueObject.getPrototypeOf(Function) === Function.prototype // trueObject.getPrototypeOf(RegExp) === Function.prototype // trueObject.getPrototypeOf(Date) === Function.prototype // trueObject.getPrototypeOf(Error) === Function.prototype // trueObject.getPrototypeOf(Symbol) === Function.prototype // trueObject.getPrototypeOf(Man) === Function.prototype // true 👀👆🌰Object.getPrototypeOf(man_1) === Function.prototype // false 👀👆🌰在之前的 为强制类型转换正名 已经知道了, JavaScript 里的对象类型基本上也就是那么多. 以上函数的原型链, 最终会指向 Function.prototype (仅为目前, 后面还有 Object.prototype 和 null ). 这也是解释了为什么任何一个普通函数都可以调用 call , apply 等 Functon.prototype 上的方法.Function和原型所有的函数的原型链里都将会出现 Functon.prototype, 由构造函数 new 出来的实例对象的 [[Prototype]] 会关联到构造函数 prototype 上.1234let num = new Number(0);Object.getPrototypeOf(num) === Number.prototype // trueObject.getPrototypeOf(Man) === Function.prototype // true 👀👆🌰到目前为止, 任何函数或对象都可以追溯到 Functon.prototype 和 构造函数的 prototype 上. 那么接下来, 又如何沿着原型链再往后找呢?The Function prototype object is the intrinsic object %FunctionPrototype%. The Function prototype object is itself a built-in function object.这句话告诉我们, Function 的原型是一个函数对象. 可我们也知道, 所有的函数都应该来自于 Function. 由此可推导, Function.prototype 内部属性 [[Prototype]] 应指向 Function.prototype. 实际上并不是这样. 同样情况的还有 Array.1Object.getPrototypeOf(Function.prototype) === Function.prototype // falseECMA 规范也给出了解释, 不知是不是解释这个的.It does not have a [[Construct]] internal method so it is not a constructor.NOTE The Function prototype object is specified to be a function object to ensure compatibility with ECMAScript code that was created prior to the ECMAScript 2015 specification.以上推导可忽略. 所以呢,The value of the [[Prototype]] internal slot of the Function prototype object is the intrinsic object %ObjectPrototype%.1Object.getPrototypeOf(Function.prototype) === Object.prototype // true其它的构造函数也是一样.1234567891011121314151617181920212223242526// true String.prototype is an ordinary object.Object.getPrototypeOf(String.prototype) === Object.prototype// true String.prototype is an ordinary object.Object.getPrototypeOf(Number.prototype) === Object.prototype// true String.prototype is an ordinary object.Object.getPrototypeOf(Boolean.prototype) === Object.prototype// true String.prototype is an Array exotic objects.Object.getPrototypeOf(Array.prototype) === Object.prototype// true String.prototype is an ordinary object.Object.getPrototypeOf(Function.prototype) === Object.prototype// true String.prototype is a built-in function object.Object.getPrototypeOf(RegExp.prototype) === Object.prototype// true String.prototype is an ordinary object.Object.getPrototypeOf(Date.prototype) === Object.prototype// true String.prototype is an ordinary object.Object.getPrototypeOf(Error.prototype) === Object.prototype// true String.prototype is an ordinary object.Object.getPrototypeOf(Symbol.prototype) === Object.prototype所有的函数或对象的原型链都会追溯到 Object.prototype 上, 难道这里就是终点么? 不是的, 还有个 null . 所以, 最终,1Object.getPrototypeOf(Object.prototype) === null // true总结一波:Function 是构造函数的地方, 构造函数是函数, 内建函数也是函数.被构造出来的实例对象内部属性 [[Prototype]] 会关联到构造函数的 prototype 所指向的对象.prototype chain 的走向为:instance =&gt; constructor.prototype =&gt; Object.prototype =&gt; null. (构造函数造出的实例对象走向)function =&gt; Function.prototype =&gt; Object.prototype =&gt; null.(函数走向)…上图说明一切.]]></content>
      <categories>
        <category>很难么</category>
      </categories>
      <tags>
        <tag>构造函数</tag>
        <tag>Function</tag>
        <tag>函数</tag>
        <tag>new操作符</tag>
        <tag>原型链</tag>
        <tag>prototype</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为强制类型转换正名]]></title>
    <url>%2F%E4%B8%BA%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%AD%A3%E5%90%8D%2F</url>
    <content type="text"><![CDATA[强制类型转换引子强制类型转换是JavaScript开发人员最头疼的问题之一, 它常被诟病为语言设计上的一个缺陷, 太危险, 应该束之高阁.作为开发人员, 往往会遇到或写过涉及到类型转换的代码, 只是我们从来没有意识到. 因为我们基本碰运气.猜猜看😏:作为基本类型值, 为什么我们可以使用相关的属性或方法? eg: &#39;hello&#39;.charAt(0) (内置类型和内建函数的关系)a &amp;&amp; (b || c) 这波操作我们知道, 那么 if (a &amp;&amp; (b || c)), 这里又做了哪些操作? (||和&amp;&amp;)if (a == 1 &amp;&amp; a== 2) { dosomething }, dosomething竟然执行了, 什么鬼? (ToPrimitive)[] == ![] =&gt; true ?; false == [] =&gt; true ?; &quot;0&quot; == false =&gt; true ?(抽象相等)if (~indexOf(&#39;a&#39;)), 这波操作熟悉不? (+/-/!/~)在String, Number, Boolean类型之间比较时, 进行的强制类型转换又遵循了哪些规则? (抽象操作)下面就要学会用实力碰运气.类型内置类型JavaScript 有七种内置类型. 空值: null, 未定义: undefined, 布尔值: boolean, 数字: number, 字符串: string, 对象: object, 符号: symbol. 除 对象:object, 为复杂数据类型, 其它均为基本数据类型.内建函数常用的内建函数: String(), Number(), Boolean(), Array(), Object(), Function(), RegExp(), Date(), Error(), Symbol().内置类型和内建函数的关系为了便于操作基本类型值, JavaScript提供了封装对象(内建函数), 它们具有各自的基本类型相应的特殊行为. 当读取一个基本类型值的时候, JavaScript引擎会自动对该值进行封装(创建一个相应类型的对象包装它)从而能够调用一些方法和属性操作数据. 这就解释了问题 1.类型检测typeof =&gt; 基本类型的检测均有同名的与之对应. null 除外(不同的对象在底层都表示为二进制, 在JavaScript中二进制前三位都为 0 会被判断为 Object 类型, null 的二进制表示为0, 前三位自然为0, 所以执行 typeof 时会返回 &#39;object&#39;.), null是假值, 也是唯一一个typeof检测会返回 &#39;object&#39; 的基本数据类型值.1234typeof null // "object"let a = null;(!a &amp;&amp; typeof a === 'object') // true复杂数据类型typeof检测返回 &#39;object&#39;, function(函数)除外. 函数因内部属性 [[Call]] 使其可被调用, 其实属于可调用对象.1typeof function()&#123;&#125; // "function"Object.prototype.toString =&gt; 通过typeof检测返回&#39;object&#39;的对象中还可以细分为好多种, 从内建函数就可以知道.它们都包含一个内部属性[[Class]], 一般通过Object.prototype.toString(…)来查看.1234567891011const str = new String('hello');const num = new Number(123);const arr = new Array(1, 2, 3);console.log(Object.prototype.toString.call(str))console.log(Object.prototype.toString.call(num))console.log(Object.prototype.toString.call(arr))// [object String]// [object Number]// [object Array]抽象操作在数据类型转换时, 处理不同的数据转换都有对应的抽象操作(仅供内部使用的操作), 在这里用到的包括 ToPrimitive, ToString, ToNumber, ToBoolean. 这些抽象操作定义了一些转换规则, 不论是显式强制类型转换, 还是隐式强制类型转换, 无一例外都遵循了这些规则(显式和隐式的命名叫法来自《你不知道的JavaScript》). 这里就解释了问题 5和问题 6.ToPrimitive该抽象操作是将传入的参数转换为非对象的数据. 当传入的参数为 Object 时, 它会调用内部方法[[DefaultValue]] 遵循一定规则返回非复杂数据类型, 规则详见DefaultValue. 故 ToString, ToNumber, ToBoolean在处理Object时, 会先经过ToPrimitive处理返回基本类型值.[[DefaultValue]](hint)语法:[[DefaultValue]]的规则会依赖于传入的参数hint, ToString传入的 hint 值为 String, ToNumber传入的 hint 值为 Number.[[DefaultValue]](String) =&gt; 若 toString 可调用, 且 toString(Obj) 为基本类型值, 则返回该基本类型值. 否则, 若 valueOf 可调用, 且 valueOf(Obj) 为基本类型值, 则返回该基本类型值. 若以上处理还未得到基本类型值, 则抛出 TypeError.[[DefaultValue]](Number) =&gt; 该规则正好和上规则调用 toString, valueOf 的顺序相反. 若 valueOf 可调用, 且 valueOf(Obj) 为基本类型值, 则返回该基本类型值. 否则, 若 toString 可调用, 且 toString(Obj) 为基本类型值, 则返回该基本类型值. 若以上处理还未得到基本类型值, 则抛出 TypeError.[[DefaultValue]]() =&gt; 未传参时, 按照 hint值为 Number 处理. Date 对象除外, 按照hint值为 String 处理.现在我们就用以上的知识点来解释问题 3是什么鬼.12345678910let i = 1;Number.prototype.valueOf = () =&gt; &#123; return i++&#125;;let a = new Number("0"); // 字符串强制转换为数字类型是不执行Toprimitive抽象操作的.console.log('a_1:', a);if(a == 1 &amp;&amp; a == 2) &#123; console.log('a==1 &amp; a==2', 'i:', i);&#125;// a==1 &amp; a==2 i: 3我们改写了内建函数 Number 原型上的 valueOf 方法, 并使得一个字符串转换成 Number 对象, 第一次 Object 类型和 Number 类型做比较时, Object 类型将进行 ToPrimitive 处理(抽象相等), 内部调用了 valueOf, 返回 2. 第二次同样的处理方式, 返回 3.ToString该抽象操作负责处理非字符串到字符串的转换.typeresultnull“null”undefined“undefined”booleantrue =&gt; “true”; false =&gt; “false”string不转换numberToString Applied to the Number TypeObject先经ToPrimitive返回基本类型值, 再遵循上述规则ToNumber该抽象操作负责处理非数字到数字的转换.typeresultnull+0undefinedNaNbooleantrue =&gt; 1; false =&gt; 0stringToNumber Applied to the String Typenumber不转换Object先经ToPrimitive返回基本类型值, 再遵循上述规则常见的字符串转换数字:字符串是空的 =&gt; 转换为0.字符串只包含数字 =&gt; 转换为十进制数值.字符串包含有效的浮点格式 =&gt; 转换为对应的浮点数值.字符串中包含有效的十六进制格式 =&gt; 转换为相同大小的十进制整数值.字符串中包含除以上格式之外的符号 =&gt; 转换为 NaN.ToBoolean该抽象操作负责处理非布尔值到布尔值转换.typeresultnullfalseundefinedfalseboolean不转换string“” =&gt; false; 其它 =&gt; truenumber+0, −0, NaN =&gt; false; 其它 =&gt; trueObjecttrue真值 &amp; 假值假值(强制类型转换false的值) =&gt; undefined, null, false, +0, -0, NaN, &quot;&quot;.真值(强制类型转换true的值) =&gt; 除了假值, 都是真值.特殊的存在假值对象 =&gt; documen.all 等. eg: Boolean(window.all) // false隐式强制类型转换+/-/!/~+/- 一元运算符 =&gt; 运算符会将操作数进行ToNumber处理.! =&gt; 会将操作数进行ToBoolean处理.~ =&gt; (~x)相当于 -(x + 1) eg: ~(-1) ==&gt; 0; ~(0) ==&gt; 1; 在if (…)中作类型转换时, 只有-1时, 才为假值.+加号运算符 =&gt; 若操作数有String类型, 则都进行ToString处理, 字符串拼接. 否则进行ToNumber处理, 数字加法.条件判断if (...), for(;;;), while(...), do...while(...)中的条件判断表达式.? : 中的条件判断表达式.|| 和 &amp;&amp; 中的中的条件判断表达式.以上遵循ToBoolean规则.||和&amp;&amp;返回值是两个操作数的中的一个(且仅一个). 首先对第一个操作数条件判断, 若为非布尔值则进行ToBoolean强制类型转换.再条件判断.|| =&gt; 条件判断为true, 则返回第一个操作数; 否则, 返回第二个操作数. 相当于 a ? a : b;&amp;&amp; =&gt; 条件判断为true, 则返回第二个操作数; 否则, 返回第一个操作数, 相当于 a ? b : a;结合条件判断, 解释下问题 21234567let a = true;let b = undefined;let c = 'hello';if (a &amp;&amp; (b || c)) &#123; dosomething()&#125;a &amp;&amp; (b || c) 返回 'hello', if语句中经Toboolean处理强制类型转换为true.抽象相等这里的知识点是用来解释 问题 4 的, 也是考验人品的地方. 这下我们要靠实力拼运气.同类型的比较.1234+ 0 == -0 // truenull == null // trueundefined == undefined // trueNaN == NaN // false, 唯一一个非自反的值null 和 undefined 的比较.12null == undefined // trueundefined == null // trueNumber 类型和 String 类型的比较. =&gt; String 类型要强制类型转换为 Number 类型, 即 ToNumber(String).(参见ToNumber)Boolean 类型和其它类型的比较. =&gt; Boolean 类型要强制类型转换为 Number 类型, 即 ToNumber(Boolean).(参见ToNumber)Object 类型和 String 类型或 Number 类型. =&gt; Object 类型要强制转换为基本类型值, 即 ToPrimitive(Object).(参见ToPrimitive)其它情况, false.回头看看问题 4中的等式. [] == ![], false == [], &quot;0&quot; == false.[] == ![] =&gt; ! 操作符会对操作数进行ToBoolean处理, [] 是真值, !true 则为 false. 再遵循第 4 点, Boolean 类型经过 ToNumber 转换为 Number类型, 则为数值 0. 再遵循第 5 点, 对 [] 进行 ToPrimitive 操作, 先后调用 valueOf(), toString()直到返回基本类型, 直到返回 &quot;&quot;. (先[].valueOf() =&gt; [], 非基本类型值; 再[].toString() =&gt; “”, 基本类型值, 返回该基本类型值.). 再遵循第 3 点, 对 &quot;&quot; 进行 ToNumber处理, 则为数值 0. 到此, 0 == 0, 再遵循第 1 点(其实没写全😌, 详见The Abstract Equality Comparison Algorithm), return true, 完美!😏.false == [] =&gt; 同理 [] == ![].&quot;0&quot; == false =&gt; 同理 [] == ![].123[] == ![] // truefalse == [] // true"0" == false // true运气是留给有准备的人, 所以呢, 我要准备买彩票了.😏]]></content>
      <categories>
        <category>很难么</category>
      </categories>
      <tags>
        <tag>强制类型转换</tag>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String原型方法]]></title>
    <url>%2FString%E5%8E%9F%E5%9E%8B%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[StringString全局对象是一个用于字符串或一个字符序列的构造函数.概述除 Object 以外的所有类型都是不可变的(值本身无法被改变). JavaScript 中字符串是不可变的「JavaScript 中对字符串的操作一定返回了一个新字符串, 原始字符串并没有被改变」.字符串字面量(通过单引号或双引号定义)和直接调用 String 方法(没有通过 new 生成字符串对象实例)的字符串都是基本字符串. JavaScript 会自动将基本字符串转换为字符串对象, 只有将基本字符串转化为字符串对象之后才可以使用字符串对象的方法.123456789101112131415let a = 'Hello, World';let b = String('Hello, World');let c = new String('Hello, World');console.log('a', a);console.log('b', b);console.log('c', c);// a Hello, World// b Hello, World/* c String =&#123; 0: "H", 1: "e",2: "l", 3: "l", 4: "o", 5: ",", 6: " ", 7: "W", 8: "o", 9: r", 10: "l", 11: "d", length: 12 &#125; */// 可以看到String构造出来的是一个类数组, 这样就可以通过.或[]来取值.当基本字符串需要调用一个字符串对象才有的方法或者查询值的时候(基本字符串是没有这些方法的「原始值」)，JavaScript 会自动将基本字符串转化为字符串对象并且调用相应的方法或者执行查询「JavaScript会自动将字符串字面值转换为一个临时字符串对象，调用该方法，然后废弃掉那个临时的字符串对象」.原型方法(部分)String.prototype.charAt()描述 :从一个字符串中返回指定索引位置的字符.语法 :str.charAt(index)index(可选) : 介于 0 ~ (str.length - 1) 的整数. 若无, 默认值为 0. 超过指定范围数值, 则返回空字符串.12345678910var anyString = "Hello World";console.log("The character at index 0 is '" + anyString.charAt() + "'");console.log("The character at index 1 is '" + anyString.charAt(1) + "'");console.log("The character at index 2 is '" + anyString.charAt(2) + "'");console.log("The character at index 11 is '" + anyString.charAt(11) + "'");// The character at index 0 is 'H'// The character at index 1 is 'e'// The character at index 2 is 'l'// The character at index 11 is ''String.prototype.concat()描述 :将原字符串与多个字符串拼接成新的字符串.语法 :str.concat(string[, string1, ..., stringN])stringN : 要拼接的字符串.1234let 你好世界 = 'Hello'.concat(' World');console.log('你好世界 = ', 你好世界);// 你好世界 = Hello WorldString.prototype.trim()描述 :将字符串的两端空白字符删除.语法 :str.trim()123456let str_1_length = ' Hello World ! '.length;let str_1 = ' Hello World ! '.trim();console.log('str_1_length', str_1_length, 'str_1', str_1, str_1.length);// str_1_length 24 str_1 Hello World ! 13String.prototype.replace()描述 :在字符串中匹配并替换指定字符串.语法 :str.replace(regexp|string, newString|function)regexp : 一个 RegExp 对象或者其字面量.string : 待匹配的字符串, 仅仅是第一个匹配会被替换.newString : 用于取代的字符串.function : 每次匹配都要调用的函数.12345678910111213141516171819let str_1 = '521521521521'.replace('521', '我爱你');let str_2 = '521521521521'.replace(/521/g, '我爱你');let str_3 = '521521521521'.replace(/(521)/g, function(a, b, c, d)&#123; console.log('arguments', arguments); if (c === 0) return a; return '我爱你';&#125;);console.log('str_1', str_1);console.log('str_2', str_2);console.log('str_3', str_3);// arguments &#123; '0': '521', '1': '521', '2': 0, '3': '521521521521' &#125;// arguments &#123; '0': '521', '1': '521', '2': 3, '3': '521521521521' &#125;// arguments &#123; '0': '521', '1': '521', '2': 6, '3': '521521521521' &#125;// arguments &#123; '0': '521', '1': '521', '2': 9, '3': '521521521521' &#125;// str_1 我爱你521521521// str_2 我爱你我爱你我爱你我爱你// str_3 521我爱你我爱你我爱你String.prototype.split()描述 :在字符串中指定分隔符, 并在分隔符处分割字符串.语法 :str.split([separator[, limit]])separator : 字符串或正则表达式. 若省略, 则返回的数组包含一个由整个字符串组成的元素.limit : 限定返回的分割片段数量.123456789101112131415161718192021let str_1 = 'Hello World'.split();let str_2 = 'Hello World'.split('');let str_3 = 'Hello World'.split(' ');let str_4 = 'Hello World, Hello World, Hello World'.split(',', 2);let str_5 = 'He5llo 2Worl1d'.split(/\d/);let str_6 = 'He5llo 2Worl2d'.split(/(\d)/);console.log('str_1',str_1);console.log('str_2',str_2);console.log('str_3',str_3);console.log('str_4',str_4);console.log('str_5',str_5);console.log('str_5',str_6);// str_1 [ 'Hello World' ]// str_2 [ 'H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd' ]// str_3 [ 'Hello', 'World' ]// str_4 [ 'Hello World', ' Hello World' ]// str_5 [ 'He', 'llo ', 'Worl', 'd' ]// str_5 [ 'He', '5', 'llo ', '2', 'Worl', '2', 'd' ]String.prototype.slice()描述 :提取字符串的一部分.语法 :str.slice(begin[, end])begin(可选) : 起始索引, 默认值为0. 如果是负数, 则开始索引会被自动计算成为 str.length + start.end : 终止索引, 默认值 str.length. 不包括end位置. 如果是负数时, 规则如上.1234567891011let str_1 = '0123456789'.slice();let str_2 = '0123456789'.slice(-1);let str_3 = '0123456789'.slice(1, -1);console.log('str_1', str_1);console.log('str_2', str_2);console.log('str_3', str_3);// str_1 0123456789// str_2 9// str_3 12345678String.prototype.substring()描述 :提取字符串的一部分.语法 :str.substring(begin[, end])begin : 起始索引.end : 终止索引.1234567891011let str_1 = '0123456789'.substring();let str_2 = '0123456789'.substring(0, 7);let str_3 = '0123456789'.substring(7, 0);console.log('str_1', str_1);console.log('str_2', str_2);console.log('str_3', str_3);// str_1 0123456789// str_2 0123456// str_3 0123456String.prototype.substr()描述 :提取字符串的一部分.语法 :str.substr(start[, length])start(可选) : 起始索引, 默认值为0. 如果是负数, 则开始索引会被自动计算成为 str.length + start.length : 提取的字符数.1234567891011let str_1 = '0123456789'.substr();let str_2 = '0123456789'.substr(-3);let str_3 = '0123456789'.substr(0, 6);console.log('str_1', str_1);console.log('str_2', str_2);console.log('str_3', str_3);// str_1 0123456789// str_2 789// str_3 012345String.prototype.includes()描述 :判断字符串中是否有指定字符串. 依条件返回 true 或 false.语法 :str.includes(string[, position])string : 需要查询的字符串.position : 指定查询起始位置, 默认为 0.1234567let boolean_1 = 'Hello World'.includes('World');let boolean_2 = 'Hello World'.includes('你好世界');console.log('boolean_1 = ', boolean_1);console.log('boolean_2 = ', boolean_2);// boolean_1 = true// boolean_2 = falseString.prototype.startsWith()描述 :判断字符串是否以指定字符串开头. 依条件返回 true 或 false.语法 :str.startsWith(string[, position])string : 需要查询的字符串.position : 指定字符串开头的位置, 默认值为 0.1234567891011let boolean_1 = '123456789'.startsWith(1);let boolean_2 = '123456789'.startsWith(3, 4);let boolean_3 = '123456789'.startsWith(7, 6);console.log('boolean_1', boolean_1);console.log('boolean_2', boolean_2);console.log('boolean_3', boolean_3);// boolean_1 true// boolean_2 false// boolean_3 trueString.prototype.endsWith()描述 :判断字符串是否以指定字符串结尾. 依条件返回 true 或 false.语法 :str.endsWith(string[, position])string : 需要查询的字符串.position : 指定字符串结尾的位置(字符串的长度), 默认值为 str.length.1234567891011let boolean_1 = '123456789'.endsWith(9);let boolean_2 = '123456789'.endsWith(9, 8);let boolean_3 = '123456789'.endsWith(7, 7);console.log('boolean_1', boolean_1);console.log('boolean_2', boolean_2);console.log('boolean_3', boolean_3);// boolean_1 true// boolean_2 false// boolean_3 trueString.prototype.indexOf()描述 :查询指定字符串在字符串中首次出现的索引位置. 若未查询到, 则返回 -1.语法 :str.indexOf(string[, position])string : 需要查询的字符串.position : 首次被找到的元素在数组中的索引位置, 默认值为 0.1234567891011let pos_1 = '0123456789'.indexOf(8);let pos_2 = '0123456789'.indexOf(8, 9);let pos_3 = '0123456789'.indexOf(8, 8);console.log('pos_1', pos_1);console.log('pos_2', pos_2);console.log('pos_3', pos_3);// pos_1 8// pos_2 -1// pos_3 8String.prototype.lastIndexOf()描述 :从字符串的后面向前查找, 查询指定字符串在字符串中首次出现的索引位置. 若未查询到, 则返回 -1.语法 :str.lastIndexOf(string[, position])string : 需要查询的字符串.position : 逆向查找起始索引, 默认值 str.length - 1.1234567891011let pos_1 = '0123456789'.lastIndexOf(9);let pos_2 = '0123456789'.lastIndexOf(9, 9);let pos_3 = '0123456789'.lastIndexOf(9, 8);console.log('pos_1', pos_1);console.log('pos_2', pos_2);console.log('pos_3', pos_3);// pos_1 9// pos_2 9// pos_3 -1String.prototype.match()描述 :字符串检索匹配正则表达式.语法 :str.match(regexp)regexp : 正则表达式对象, 如果传入一个非正则表达式对象, 则会隐式地使用 new RegExp(obj) 将其转换为一个 RegExp. 如果你未提供任何参数, 直接使用 match(), 那么你会得到一个包含空字符串的 Array : [&quot;&quot;].返回值 : 如果字符串匹配到了表达式, 会返回一个数组, 数组的第一项是进行匹配完整的字符串, 之后的项是用圆括号捕获的结果. 如果没有匹配到, 返回null.1234567891011let pos_1 = '0123456789'.match(9);let pos_2 = '0123456789'.match(/8\d+/);let pos_3 = '0123456789'.match(/7\d&#123;1&#125;/);console.log('pos_1', pos_1);console.log('pos_2', pos_2);console.log('pos_3', pos_3);// pos_1 [ '9', index: 9, input: '0123456789' ]// pos_2 [ '89', index: 8, input: '0123456789' ]// pos_3 [ '78', index: 7, input: '0123456789' ]String.prototype.search()描述 :字符串检索匹配正则表达式.语法 :str.search(regexp)regexp : 正则表达式对象, 如果传入一个非正则表达式对象, 则会隐式地使用 new RegExp(obj) 将其转换为一个 RegExp. 如果你未提供任何参数, 直接使用 match(), 那么你会得到一个包含空字符串的 Array : [&quot;&quot;].返回值 : 如果匹配成功, 则 search() 返回正则表达式在字符串中首次匹配项的索引. 否则, 返回 -1.1234567891011let pos_1 = '0123456789'.search(9);let pos_2 = '0123456789'.search(/8\d+/);let pos_3 = '0123456789'.search(/7\d&#123;1&#125;/);console.log('pos_1', pos_1);console.log('pos_2', pos_2);console.log('pos_3', pos_3);// pos_1 9// pos_2 8// pos_3 7String.prototype.toLowerCase()描述 :将字符串转换成小写形式.语法 :str.toLowerCase()12345let str_1 = 'Hello World !'.toLowerCase();console.log('str_1', str_1);// str_1 hello world !String.prototype.toUpperCase()描述 :将字符串转换成大写形式.语法 :str.toUpperCase()12345let str_1 = 'Hello World !'.toUpperCase();console.log('str_1', str_1);// str_1 HELLO WORLD !String.prototype.toString()描述 :将指定对象转换成字符串形式.语法 :str.toString()12345let str_1 = new String('Hello World !');console.log('str_1', str_1, 'str_1.toString()', str_1.toString());// str_1 [String: 'Hello World !'] str_1.toString() Hello World !(不同浏览器展现效果可能不同)String.prototype.valueOf()描述 :返回一个String对象的原始值（primitive value）.语法 :str.valueOf()123456let str = new String('Hello World!');let str_1 = str.valueOf();console.log('str_1', str_1);// str_1 Hello World!String.prototype[@@iterator]()描述 :返回一个String对象的原始值（primitive value）.语法 :str.valueOf()12345678910111213141516171819202122let str = 'Hello World!';let str_1 = str[Symbol.iterator]();console.log('str_1', str_1.next());// str_1 &#123; value: 'H', done: false &#125;for(let item of str) &#123; console.log('item', item);&#125;// item H// item e// item l// item l// item o// item// item W// item o// item r// item l// item d// item !]]></content>
      <categories>
        <category>字符串总结</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>字符串原型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VS Code使用基础]]></title>
    <url>%2FVS-Code%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[工欲善其事, 必先利其器. 作为一个前端程序猿打造一个好看好用的编辑器, 对于工作效率的提高有很大的帮助.主题字体字体选用的FiraCode, 下载安装然后参见VS Code Instructions相关设置. 其它好看的字体还有Source Code Pro等.颜色主题和文件图标主题颜色主题选用的是One Dark Pro. 编辑器内置了几款颜色主题, 如果没有喜欢的就在扩展主题里找找.文件图标主题配置同颜色主题配置.用户设置Commonly Used控制字段控制内容files.autoSave自动保存editor.tabSize制表符的空格数editor.renderWhitespace空白字符显示方式editor.wordWrap换行方式files.exclude配置排除的文件和文件夹的 glob 模式. 不需要关心的文件或文件夹在此排除.files.associations配置语言的文件关联. eg:&quot;**.jsp&quot;: &quot;javascript&quot;files.trimTrailingWhitespace启用后，将在保存文件时剪裁尾随空格workbench.editor.labelFormat控制编辑器标签的格式window.openFilesInNewWindow控制是否在新窗口中打开文件terminal.integrated.shell.osx终端在 macOS 上使用的 Shell 的路径breadcrumbs.enabled启用/禁用导航路径(面包屑)emmet.includeLanguages在默认不支持 Emmet 的语言中启用 Emmet 缩写功能. eg:&quot;vue-html&quot;: &quot;html&quot;, &quot;javascript&quot;: &quot;javascriptreact&quot;编辑器控制字段控制内容editor.formatOnType控制编辑器在键入一行后是否自动格式化该行editor.minimap.enabled是否显示小地图editor.mouseWheelZoom按住 Ctrl 键并滚动鼠标滚轮时对编辑器字体大小进行缩放editor.parameterHints.enabled在输入时显示含有参数文档和类型信息的小面板files.exclude配置排除的文件和文件夹的 glob 模式. 不需要关心的文件或文件夹在此排除.files.associations配置语言的文件关联. eg:`”.jsp”: “javascript”`*快捷键关键字快捷键删除行cmd + D合并行ctrl + J光标后退ctrl + _光标前进ctrl + shift + _向下面插入行cmd + enter向上面插入行cmd + shift + enter转到文件cmd + P显示所有命令cmd + shift + P文件查找cmd + F全局搜索cmd + shift + F切换行注释cmd + /切换块注释shift + alt + A撤销cmd + Z恢复撤销cmd + shift + Z缩进tab缩进shift + tab移动到行尾cmd + right移动到行首cmd + left向上移动行cmd + up向下移动行cmd + down保持打开状态cmd + K enter打开集成终端ctrl + `集成终端清屏cmd + K格式化文件shift + alt + F常见操作窗口code命令VS Code快速打开文件夹或文件,可以将其直接拖至VS Code图标上. 或cmd + shift + P打开命令面板, 向Path添加code, 用code命令操作.文件对比工作区可以将其它项目与当前项目置于同一工作区, 在同一个窗口查看编辑.自定义终端在Mac终端改造里, 已经打造好了个性化的终端了. 在VS Code里只需要换个路径即可.在用户设置里用以下配置覆盖.1"terminal.integrated.shell.osx": "/bin/zsh",添加自定义snippetVS Code内置了自定义snippet功能, 用户可以根据自己的需求去添加自己想要的代码段, 灵活且方便, 这样就完全没有必要去安装类似的插件了. 细节可参考[VS Code]跟我一起在Visual Studio Code 添加自定义snippet（代码段），附详细配置.插件Chinese (Simplified) Language Pack for VS Code此中文（简体）语言包为 VS Code 提供本地化界面.Bookmarks在代码中做标记, 可以在不同的标记中快速便捷的切换.Auto Rename Tag修改HTML/XML标签时, 首尾标签会自动同步更改.ESLint一个开源的 JavaScript 代码检查插件, 可以在编写或保存文件时对文件进行检测. 根据规则配置文件对文件进行检测提示, 并可以自动修复部分不符合规则的部分.&quot;eslint.options&quot;: { &quot;configFile&quot;: &quot;**/**/**&quot; } : 本地的配置文件地址路径.eslint.validate: 可被识别的文件类型.eslint.autoFixOnSave: 保存时自动修复.Debugger for Chrome在代码里断点, 就是相对地知道文件在哪里吧, Chrome里打断点还是挺好用地. Debugger for Chrome 配置可参见官网例子.插件什么的真的不见得能提高多少效率, 讲真, 颜值才是正义, 颜值才是王道🤔.]]></content>
      <categories>
        <category>善事利器</category>
      </categories>
      <tags>
        <tag>编辑器</tag>
        <tag>Visual Studio Code</tag>
        <tag>VS Code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[观察者模式再次进阶]]></title>
    <url>%2F%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E5%86%8D%E6%AC%A1%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[发布/订阅者模式发布/订阅模式概念说起观察者模式, 往往会牵扯到发布/订阅模式. 两者存在着很多的相似之处, 它们都是维护着一个列表, 然后都可以对列表的对象进行增删和通知. 不同的地方可能就在于处理添加和通知的方式上吧.发布/订阅模式使用了一个主题/事件通道, 这个通道介于希望接到通知的对象(订阅者)和激活事件的对象(发布者)之间. 该事件系统允许代码定义应用程序的特定事件, 这些事件可以传达自定义参数, 自定义参数包含订阅者所需的值. 其目的是避免订阅者和发布者之间产生依赖关系. ———《设计模式: 可复用面向对象软件基础》戏说发布/订阅模式模式以下所有代码参见publish/subscribe.既然和观察者模式类似, 那么在从观察者模式说起提到的小故事, 就可以接着往下续了.subject1带着那么一拨人回去复命, 经过一段时间的磨合实践, 效果也是很明显. 附近的公司听到风声后, 也纷纷组织派遣员工前来学习. 人多了, 需求也变多了, 这么多人肯定不能再呆在一起学习了. 原来只是一个公司的人呆在一间屋子里学习, 得到命令后大家开始各司其职. 现在, 各个公司的学习内容不同, 它们理应独立开来. 因为各个公司动作可以不同步, 但公司内部一定要同步起来. 为了区别对待, 每个公司都有能和别人区分的令牌, 有了令牌同一个公司的人就可以进入与令牌相对应的房间了(当然一个人也可以有很多令牌, 商业间谍吧😂).1234567// 我是Pubsub, 我负责管理这拨人.class Pubsub &#123; constructor() &#123; // 维护事件列表, 这里将以对象的形式出现, key: value, key: 令牌, value: 同一公司员工列表. this. handles = &#123;&#125; &#125;&#125;现在, 不同公司的人前来学习的时候, 需要告诉Pubsub他们公司的令牌号, 进而引领到令牌对应的房间.12345678910class Pubsub &#123; // 省略 // 注册事件. 如果是公司第一次派人过来, 那就新开一间. subscribe(type, handle) &#123; if (!this.handles[type]) &#123; this.handles[type] = [] &#125; this.handles[type].push(handle) &#125;&#125;如果某个房间的某个人, 或整个房间的人都不打算来了, 也需要Pubsub将其注销.12345678910111213class Pubsub &#123; // 省略 // 注销事件. 公司个人或整体注销. unsubscribe(type, handle) &#123; let pos = this.handles[type].indexOf(handle) if (!handle) &#123; // 不传handle, 则默认注销所有和type事件相关的事件处理函数. this.handles.length = 0 &#125; else &#123; ~pos &amp;&amp; this.handles[type].splice(pos, 1) &#125; &#125;&#125;不同的团体做出了区分, 算是万事具备. 想要哪个房间里的人动起来, 有了令牌号, 只要对着吼一嗓子即可.123456789101112class Pubsub &#123; // 省略 // 通知事件 publish() &#123; // 执行所有和type事件相关的处理函数. let type = Array.prototype.shift.call(arguments) this.handles[type].forEach(handle =&gt; &#123; // 箭头函数不绑定Arguments对象 handle.apply(this, arguments) &#125;) &#125;&#125;让我们看看效果如何.12345678910111213141516171819202122232425let handle1 = (...rest) =&gt; &#123;document.write('handle1', JSON.stringify(rest), '&lt;br/&gt;')&#125;let handle2 = (...rest) =&gt; &#123;document.write('handle2', JSON.stringify(rest))&#125;let ps = new Pubsub()ps.subscribe('notify-1', handle1)ps.subscribe('notify-1', handle2)ps.subscribe('notify-2', handle2)ps.unsubscribe('notify-1', handle2)ps.publish('notify-1', 'hahaha', 'heiheihei', [], &#123;&#125;)ps.publish('notify-2', 'hehehehehe')// 结果:handle1["hahaha","heiheihei",[],&#123;&#125;]handle2["hehehehehe"]不难发现, 我们的Pubsub老师只认令牌😅.]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>观察者模式</tag>
        <tag>发布/订阅模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac终端改造]]></title>
    <url>%2FMac%E7%BB%88%E7%AB%AF%E6%94%B9%E9%80%A0%2F</url>
    <content type="text"><![CDATA[平时Mac使用的shell使bash, 它虽然能满足我们的需要, 但是使用起来不是很方便. zsh可配置性强, 用户可以自定义配置, 个性化强.更换shell查看当前使用的shellecho $SHELL1/bin/bash查看系统当前内置的shellcat /etc/shells123456/bin/bash/bin/csh/bin/ksh/bin/sh/bin/tcsh/bin/zsh如果没有发现/bin/zsh, 就需要手动安装Zsh.替换shellchsh -s /bin/zsh12Changing shell for **.Password for **: your password重启echo $SHELL1/bin/zsh替换成功!安装oh-my-zshoh-my-zsh用来管理Zsh配置的.安装sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;.1234567891011121314Looking for an existing zsh config...Using the Oh My Zsh template file and adding it to ~/.zshrc __ ______ / /_ ____ ___ __ __ ____ _____/ /_/ __ \/ __ \ / __ `__ \/ / / / /_ / / ___/ __ \/ /_/ / / / / / / / / / / /_/ / / /_(__ ) / / /\____/_/ /_/ /_/ /_/ /_/\__, / /___/____/_/ /_/ /____/ ....is now installed!Please look over the ~/.zshrc file to select plugins, themes, and options.p.s. Follow us at https://twitter.com/ohmyzsh.p.p.s. Get stickers and t-shirts at https://shop.planetargon.com.更改配置vim ~/.zshrc12345678910111213141516171819202122232425# Set name of the theme to load --- if set to "random", it will# load a random theme each time oh-my-zsh is loaded, in which case,# to know which specific one was loaded, run: echo $RANDOM_THEME# See https://github.com/robbyrussell/oh-my-zsh/wiki/ThemesZSH_THEME="robbyrussell"# Uncomment the following line to disable bi-weekly auto-update checks.# DISABLE_AUTO_UPDATE="true"# Uncomment the following line to enable command auto-correction.ENABLE_CORRECTION="true"# Uncomment the following line to display red dots whilst waiting for completion.COMPLETION_WAITING_DOTS="true"# Which plugins would you like to load?# Standard plugins can be found in ~/.oh-my-zsh/plugins/*# Custom plugins may be added to ~/.oh-my-zsh/custom/plugins/# Example format: plugins=(rails git textmate ruby lighthouse)# Add wisely, as too many plugins slow down shell startup.plugins=(git)source $ZSH/oh-my-zsh.sh以上是部分配置, 需将#删除才能生效. 键入i进入编辑模式, 修改后esc退出编辑模式, 键入:wq保存退出. oh-my-zsh有支持的主题和插件, 可以自由配置.插件推荐zsh-syntax-highlighting安装zsh-syntax-highlightinggit clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting修改配置(zsh-syntax-highlighting)vim ~/.zshrc123plugins=( git zsh-syntax-highlighting)让修改生效(zsh-syntax-highlighting)source ~/.zshrczsh-autosuggestions安装zsh-autosuggestionsgit clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions修改配置(zsh-autosuggestions)vim ~/.zshrc123plugins=( git zsh-autosuggestions zsh-syntax-highlighting)让修改生效(zsh-autosuggestions)source ~/.zshrc好了, 打完收工!]]></content>
      <categories>
        <category>善事利器</category>
      </categories>
      <tags>
        <tag>Mac终端</tag>
        <tag>oh-my-zsh</tag>
        <tag>zsh</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进击的观察者模式]]></title>
    <url>%2F%E8%BF%9B%E5%87%BB%E7%9A%84%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[商品信息改变带来的烦恼Talk is cheap. Show me the code. (译: 屁话少说, 放码过来)以下所有代码参见Design pattern transformation.12345678910111213141516171819202122232425// 商品的信息: 价格 &amp; 折扣const data = &#123; price: 100, discount: 0.8&#125;// 顾客信息: 是否为会员 &amp; 购买数量 &amp; 总消费 &amp; 购买时间戳const customer = &#123; "VIP": true, "quantity": 10, "total": 0,&#125;// 总消费计算方式total = (info) =&gt; &#123; if(!info.VIP) &#123; info.total = data.price * info.quantity; &#125; else &#123; info.total = data.price * data.discount * info.quantity; &#125;&#125;total(customer);console.log('customer', customer);// customer &#123; VIP: true, quantity: 10, total: 800 &#125;从代码中很容易看得出来, 我们就是想实现一个简单的计费功能. 可现实中, 商品的价格可能并不是一成不变的.data.price = 200价格变动后, 我们需要及时地获取总消费, 那么就必须重新调用下 total 计费.123total(customer);console.log('customer', customer);// customer &#123; VIP: true, quantity: 10, total: 1600 &#125;这是一个大数据时代, 任何数据都有价值. 现在, 我们还想要每次购买时的时间点.12345678910 const customer = &#123; "VIP": true, "quantity": 10, "total": 0,+ "timeStamp": 0 &#125; // 获取购买时间 purchaseTime = (info) =&gt; &#123; info.timeStamp = Date.now(); &#125;于是, 我们需要执行的函数就多了一个.1234total(customer)purchaseTime(customer)console.log('customer', customer)// &#123; VIP: true, quantity: 10, total: 1600, timeStamp: 1542293676297 &#125;如果我们的需求还有很多, 而且不知一个customer呢. 那么, 每次价格变化我们需要执行很多步骤, 每次啊, 麻烦得很.1234567891011121314151617181920+ const customer1 = &#123;+ "VIP": false,+ "quantity": 8,+ "total": 0,+ "timeStamp": 0+ &#125; total(customer) purchaseTime(customer) func(customer) ... funcN(customer1) total(customer1) purchaseTime(customer1) func(customer1) ... funcN(customer) ... funcN(customerN)现在我们就对上面的代码进行观察者模式改造.用观察者模式改造从上面的例子中🌰🀄️不难看出, 每次价格变化时, 我们都需要重复调用满足需求的方法. 不妨想想, 如果我们把这些方法存储起来, 等到价格变化时再去统一调用, 岂不是很方便. 那么问题来了, 这和之前所说的观察者模式(从观察者模式说起)有什么区别呢? 在此, 我们试着用观察者模式改造下.首先观察者模式都是一个套路. 先一个类维护一个列表, 对列表有增删和通知更新功能. 另一个类则是提供了更新接口.123456789101112131415161718192021// 观察目标类class Subject &#123; constructor() &#123; this.observerList = [] &#125; addObserver(observer) &#123; this.observerList.push(observer) &#125; notify(params) &#123; this.observerList.forEach(observer =&gt; &#123; observer.update(params) &#125;) &#125;&#125;// 观察者类class Observer &#123; constructor(fn) &#123; this.update = fn &#125;&#125;接着, 把我们想要调用的方法包装一下, 存储起来.12345678// 将要重复使用的包装一下observer1 = new Observer(total)observer2 = new Observer(purchaseTime)// 存起来let subject = new Subject()subject.addObserver(observer1)subject.addObserver(observer2)每次价格改变时, 只需要通知一下即可.1234// 调整商品价格data.price = 100subject.notify(customer)subject.notify(customer1)改造结束. 初看起来, 可能变得繁琐了. 但是, 遇到复杂的情况, 这不失是一个好办法. 接下来, 我们看看结合Objec.defineProperty会有什么惊喜.与Objec.defineProperty结合支付宝的花呗都可以自己还钱了🤣, 我们为什么还要别人管着😏. 大家都知道经过Objec.defineProperty处理的对象, 在设置和获取对象属性的时候, 会自动触发响应set和get方法. 利用这一点, 我们就可以做到生活自理了. 熟悉的配方, 熟悉的味道. 熟悉的套路我们不妨再走一遍.123456789101112131415161718192021// 观察目标类class Dependency &#123; constructor() &#123; this.watcherList = [] &#125; addObserver(observer) &#123; this.watcherList.push(observer) &#125; notify(params) &#123; this.watcherList.forEach(watcher =&gt; &#123; watcher.update(params) &#125;) &#125;&#125;// 观察类class Watcher &#123; constructor(fn) &#123; this.update = fn &#125;&#125;我们此行的目的, 是要在data.price 或data.discount改变时, 程序能够自动触发, 得到我们想要的结果. 换句话说, 通知更新的时机是在设置data.price或data.discount的时候.12345678910111213 Object.keys(data).forEach(key =&gt; &#123; let value = data[key] const dep = new Dependency() Object.defineProperty(data, key, &#123; set(newVal) &#123; value = newVal dep.notify() &#125;, get() &#123; return value &#125; &#125;)&#125;)对象的每个属性都给了一个依赖实例, 管理自己的依赖. 考虑到customer有很多个, 需要通知到位. 另外, 添加依赖和管理依赖, 前者是因, 后者是果. 在管理之前我们需要想好怎么添加依赖. 回头看一看.123456789101112 // 总消费计算方式 total = (info) =&gt; &#123; if(!info.VIP) &#123; info.total = data.price * info.quantity; &#125; else &#123; info.total = data.price * data.discount * info.quantity; &#125; &#125; // 获取购买时间purchaseTime = (info) =&gt; &#123; info.timeStamp = Date.now();&#125;我们发现, total 函数依赖于data.price或data.discount的. 如果我们在获取属性时去添加依赖倒是一个好时机.1234567891011121314151617181920212223242526272829303132333435 class Dependency &#123; // 省略 &#125;+ Dependency.targey = null;class Watcher &#123; constructor(fn, key) &#123; this.update = fn+ this.key = key+ this.value = this.getter() &#125;+ getter() &#123;+ Dependency.targey = this;+ // 触发下面的get()+ this.value = data[this.key];+ Dependency.targey = null;+ &#125;&#125;Object.keys(data).forEach(key =&gt; &#123; let value = data[key] const dep = new Dependency() Object.defineProperty(data, key, &#123; set(newVal) &#123; value = newVal dep.notify() &#125;, get() &#123;+ if (Dependency.targey) &#123;+ dep.addObserver(Dependency.targey)+ &#125; return value &#125; &#125;)&#125;)然而 purchaseTime 方法里并没有data.price或data.discount可以设置. 所以这个方法行不通. 那么, 干脆紧接着依赖实例去添加依赖吧. 同时考虑到多个customer, 我们封装下.1234567891011121314151617181920212223// 与defineProperty结合function defineReactive(data, watcherList, funcList) &#123; Object.keys(data).forEach(key =&gt; &#123; let value = data[key] const dep = new Dependency() funcList.forEach(func =&gt; &#123; dep.addObserver(new Watcher(func)) &#125;) Object.defineProperty(data, key, &#123; set(newVal) &#123; value = newVal watcherList.forEach(watcher =&gt; &#123; dep.notify(watcher) &#125;) &#125;, get() &#123; return value &#125; &#125;) &#125;)&#125;defineReactive(data, [customer, customer1], [total, purchaseTime])大功告成, 价格变动时, 我们就会自动获取到想要的结果了. 我都能自理了, 你花呗为嘛还不能自己还钱呢😒]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>观察者模式</tag>
        <tag>Object.defineProperty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从观察者模式说起]]></title>
    <url>%2F%E4%BB%8E%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E8%AF%B4%E8%B5%B7%2F</url>
    <content type="text"><![CDATA[观察者模式观察者模式的定义Observer(观察者)是一种设计模式, 其中, 一个对象(称为 subject) 维持一系列依赖于它的观察者对象, 将有关状态的任何变更自动通知给观察者.当一个目标(subject)需要告诉观察者发生了什么有趣的事情, 它会向观察者广播一个通知. 当我们不再希望某个特定的观察者获得其注册目标(subject)发出的改变通知时, 该目标可以将它从观察者列表中删除.“一个或多个观察者对目标的状态感兴趣, 它们通过将自己依附在目标对象上以便注册所感兴趣的内容. 目标状态发生改变并且观察者可能对这些改变感兴趣, 就会发送一个通知消息, 调用每个观察者的更新方法. 当观察者不再对目标状态感兴趣时, 它们可以简单地将自己从中分离.” ———《设计模式: 可复用面向对象软件基础》观察者模式的理解从观察者模式的定义中可以对观察者模式有个大体的了解. 观察者模式中有两类, 一类被称为目标(Subject), 一类被称为观察者(Observer). Subject的工作是维护一系列的Observer, 可以对它们进行添加、删除和通知的操作. Observer的工作则是为Subject状态发生变化需要获得通知的对象提供更新接口.戏说观察者模式先不管观察者模式是什么, 我们可以试着想想如何从观察者模式的定义去实现这些功能. 下面我们从一个小故事说起.从前有个人. 凭着天资聪颖再加上闯荡江湖多年, 无论从事什么行业都能称为行业翘楚, 算是有名气的人物.1class Subject &#123;&#125; // 我是有个人. Subject是江湖送我的绰号.有一天, 有一个初创公司慕名前来拜访, 探讨如何在现在这个激烈的竞争环境下赢得一席之地.1class Observer &#123;&#125; // 我是一家初创公司, Observer是我公司的名字.两人见面直奔主题.‘你可以派些人来, 我给他们做培训. ’, Subject如此说道. Observer点头同意.‘可是我如何才能让他们服从并执行呢?’, Subject问到. ‘我们可以向你提供统一的对接方式’, Observer回答到.‘行, 谁要有兴趣谁就过来吧’12345678/* update是我们的对接方式, fn是我们的职能.只需要走update这个流程, 我们会各司其职.下面这是个我们的模子, 每个走出去的人都大体这样.*/class Observer &#123; constructor(fn) &#123; this.update = fn &#125;&#125;为了后续的开展, 夜曉宸也做了准备. 为随后要来的人腾出了空间, 并想好了如何接待每个人.12345678class Subject &#123; constructor() &#123; this.observesList = []; // 这里是为参与者腾出的空间. &#125; addObserver(observer) &#123; this.observerList.push(observer); // 招待每一个参与者, 就是引导参与者进入腾出的空间. &#125;&#125;不日, Observer派人带着各自本职职务过来了.123const observer1 = new Observer(() =&gt; &#123;document.write(`$&#123;order&#125;: 我是财务, 我要开始算绩效发工资了&lt;br/&gt;`));const observer2 = new Observer(() =&gt; &#123;document.write(`$&#123;order&#125;: 我是后勤客服, 有什么事情需要帮助的?&lt;br/&gt;`));const observer3 = new Observer(() =&gt; &#123;document.write(`$&#123;order&#125;: 我是人事, 我要招人了&lt;br/&gt;`));既然人来了, 那就接待.1234const subject = new Subject(); // 事务繁忙, 派了一个影分身.subject.addObserver(observer1); // 引导observer1进入房间.subject.addObserver(observer2); // 引导observer2进入房间.subject.addObserver(observer3); // // 引导observer3进入房间.‘既然来到了这个房间, 就要明确一点, 那就是你们得听我指令, 到时我会使用你们公司统一的对接方式’1234567class Subject &#123; // 省略 notify(context) &#123; // 由公司提供的统一对接方式，向在场的每一个Observer传达并让其执行. this.observerList.forEach(observer =&gt; observer.update(context)); &#125;&#125;‘如果你们不想呆下去了, 可以和我说, 我可以引导你们出去’12345678class Subject &#123; // 省略 removeObserver(observer) &#123; // 对于不再感兴趣的Observer，可以将其剔除，其不会再收到任何来自Subject的通知. let pos = this.observerList.indexOf(observer); this.observerList.splice(pos, 1); &#125;&#125;‘现在, 要下达指令了!’12// 省略subject.notify('描述下各自的职能');‘好了, 这些就是我们培训的内容, 就是这么简单’‘就这么简单?!?, 既然这样, 就送我出去吧, 我不想再呆下去了 ’, observer2说到.12// 省略subject.removeObserver(observer2);到此故事告一段落了, Observer模式在线Demo.再看观察者模式我们从几段对话中, 稀里糊涂的完成了本文开头观察者模式所定义的那样. 有负责管理一系列依赖的对象, 有提供更新接口的对象. 我们可以看到, 当subject1发出通知时, 每个observe都能去执行. observer们的行为依赖于subject1的. 为什么能够做到这一点, 那是因为observe们的行为作为自身的一部分寄存在了subject1, subject1就可以在需要的时候去自己腾出的小屋子里通知observer们执行.如果subject1 带着这么一波参加过培训的observer们回去交差, 肯定会被笑话. subject1和observer们的这种协作方式, 被称做观察者模式. 这不过是一个模式, 何时存储何种东西, 何时又去执行存储的东西那才是关键. 如果放到上面的小故事里, 那就是何时需要何种人, 何时开始去做事, 这都需要审时度势. 只有这样公司才能在激烈的竞争环境中赢得一席之地. 只有这样, 观察者模式才能发挥它最大的作用.]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>观察者模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Array原型之迭代方法]]></title>
    <url>%2FArray%E5%8E%9F%E5%9E%8B%E4%B9%8B%E8%BF%AD%E4%BB%A3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[ArrayArray对象是用于构造数组的全局对象.概述数组对象是一个有序的数据(原始类型或对象类型)集合, 是一种类列表对象,它的原型提供了数组操作的方法.数组只能用整数作为数组元素的索引,而不是字符串,且从0开始,第一个元素的索引为0.使用非整数并通过[]或.来访问数组或设置数组元素时,所操作的并不是数组列表的元素,而是数组对象属性集合上的变量.数组对象的属性和数组元素列表是分开存储的,并且数组的遍历和修改操作也不能作用于这些命名属性.123456var arr = [];arr['zero'] = 'zero';arr[0] = 0;arr.forEach(item =&gt; console.log(item))// 0原型方法迭代方法Array.prototype.forEach()语法 :array.forEach(callback(currentValue[, index[, array]]){ // do something }[, thisArg])callback : 数组中每个元素都会执行的回调函数.currentValue : 数组中正在被处理的当前元素.index : 数组中正在被处理的当前元素的索引.array : 调用该方法的数组.thisArg : 执行回调函数时this对应的对象. 如果省略了 thisArg 参数, 或者赋值为 null 或 undefined, 则 this 指向全局对象.返回值 :123456789101112let obj = &#123;name: 'obj'&#125;;let arr0 = [3, 2, 1];let arr00 = arr0.forEach(function(currentValue, index, array)&#123; console.log('arr0:', arr0,'currentValue:', currentValue, 'index:', index, 'array:', array, 'thisArg:', this);&#125;, obj);console.log('arr00:', arr00);// arr0: [ 3, 2, 1 ] currentValue: 3 index: 0 array: [ 3, 2, 1 ] thisArg: &#123;name: 'obj' &#125;;// arr0: [ 3, 2, 1 ] currentValue: 2 index: 1 array: [ 3, 2, 1 ] thisArg: &#123;name: 'obj' &#125;;// arr0: [ 3, 2, 1 ] currentValue: 1 index: 2 array: [ 3, 2, 1 ] thisArg: &#123;name: 'obj' &#125;;// arr00: undefined;Array.prototype.map()语法 :array.map(callback(currentValue[, index[, array]]){ // do something }[, thisArg])callback : 数组中每个元素都会执行的回调函数.currentValue : 数组中正在被处理的当前元素.index : 数组中正在被处理的当前元素的索引.array : 调用该方法的数组.thisArg : 执行回调函数时this对应的对象. 如果省略了 thisArg 参数, 或者赋值为 null 或 undefined, 则 this 指向全局对象.返回值 : 由每个数组元素调用callback后的返回值组成的新数组.1234567891011121314let obj = &#123;name: 'obj'&#125;;let arr0 = [3, 2, 1];let arr00 = arr0.map(function(currentValue, index, array)&#123; let newVal = currentValue * 2; console.log('arr0:', arr0, 'currentValue:', currentValue, 'index:', index, 'array:', array, 'newVal:', newVal, 'thisArg:', this); return newVal;&#125;, obj);console.log('arr00:', arr00);// arr0: [ 3, 2, 1 ] currentValue: 3 index: 0 array: [ 3, 2, 1 ] newVal: 6 thisArg: &#123; name: 'obj' &#125;;// arr0: [ 3, 2, 1 ] currentValue: 2 index: 1 array: [ 3, 2, 1 ] newVal: 4 thisArg: &#123; name: 'obj' &#125;;// arr0: [ 3, 2, 1 ] currentValue: 1 index: 2 array: [ 3, 2, 1 ] newVal: 2 thisArg: &#123; name: 'obj' &#125;;// arr00: [ 6, 4, 2 ]Array.prototype.every()语法 :array.every(callback(currentValue[, index[, array]]){ // do something }[, thisArg])callback : 数组中每个元素都会执行的回调函数.currentValue : 数组中正在被处理的当前元素.index : 数组中正在被处理的当前元素的索引.array : 调用该方法的数组.thisArg : 执行回调函数时this对应的对象. 如果省略了 thisArg 参数, 或者赋值为 null 或 undefined, 则 this 指向全局对象.返回值 : 布尔值. 由数组中每个元素调用callback后, 当所有的元素都符合条件(真值)才返回true. 否则, 返回false. 另外, 对于放在空数组上的任何条件, 此方法返回 true.1234567891011121314151617181920212223242526272829303132let obj = &#123; name: 'obj'&#125;let arr0 = [3, 2, 1];let arr00 = arr0.every(function(currentValue, index, array)&#123; let newVal = currentValue * 3; console.log('arr0:', arr0, 'currentValue:', currentValue, 'index:', index, 'array:', array, 'newVal:', newVal, 'thisArg:', this); return newVal &gt; 2;&#125;, obj)console.log('arr00:', arr00);// arr0: [ 3, 2, 1 ] currentValue: 3 index: 0 array: [ 3, 2, 1 ] newVal: 9 thisArg: &#123; name: 'obj' &#125;// arr0: [ 3, 2, 1 ] currentValue: 2 index: 1 array: [ 3, 2, 1 ] newVal: 6 thisArg: &#123; name: 'obj' &#125;// arr0: [ 3, 2, 1 ] currentValue: 1 index: 2 array: [ 3, 2, 1 ] newVal: 3 thisArg: &#123; name: 'obj' &#125;// arr00: true;let obj = &#123; name: 'obj'&#125;let arr0 = [3, 2, 1];let arr00 = arr0.every(function(currentValue, index, array)&#123; let newVal = currentValue * 3; console.log('arr0:', arr0, 'currentValue:', currentValue, 'index:', index, 'array:', array, 'newVal:', newVal, 'thisArg:', this); return newVal &gt; 6;&#125;, obj)console.log('arr00:', arr00);// arr0: [ 3, 2, 1 ] currentValue: 3 index: 0 array: [ 3, 2, 1 ] newVal: 9 thisArg: &#123; name: 'obj' &#125;;// arr0: [ 3, 2, 1 ] currentValue: 2 index: 1 array: [ 3, 2, 1 ] newVal: 6 thisArg: &#123; name: 'obj' &#125;;// arr00: false;Array.prototype.some()语法 :array.some(callback(currentValue[, index[, array]]){ // do something }[, thisArg])callback : 数组中每个元素都会执行的回调函数.currentValue : 数组中正在被处理的当前元素.index : 数组中正在被处理的当前元素的索引.array : 调用该方法的数组.返回值 : 布尔值. 由数组中每个元素调用callback后, 当有元素符合条件(真值)就返回true. 否则, 返回false. 另外, 对于放在空数组上的任何条件, 此方法返回 false.12345678910111213141516171819202122232425262728293031let obj = &#123; name: 'obj'&#125;let arr0 = [3, 2, 1];let arr00 = arr0.some(function(currentValue, index, array)&#123; let newVal = currentValue * 3; console.log('arr0:', arr0, 'currentValue:', currentValue, 'index:', index, 'array:', array, 'newVal:', newVal, 'thisArg:', this); return newVal &gt; 6;&#125;, obj)console.log('arr00:', arr00);// arr0: [ 3, 2, 1 ] currentValue: 3 index: 0 array: [ 3, 2, 1 ] newVal: 9 thisArg: &#123; name: 'obj' &#125;;// arr00: true;let obj = &#123; name: 'obj'&#125;let arr0 = [3, 2, 1];let arr00 = arr0.some(function(currentValue, index, array)&#123; let newVal = currentValue * 3; console.log('arr0:', arr0, 'currentValue:', currentValue, 'index:', index, 'array:', array, 'newVal:', newVal, 'thisArg:', this); return newVal &gt; 9;&#125;, obj)console.log('arr00:', arr00);// arr0: [ 3, 2, 1 ] currentValue: 3 index: 0 array: [ 3, 2, 1 ] newVal: 9 thisArg: &#123; name: 'obj' &#125;;// arr0: [ 3, 2, 1 ] currentValue: 2 index: 1 array: [ 3, 2, 1 ] newVal: 6 thisArg: &#123; name: 'obj' &#125;;// arr0: [ 3, 2, 1 ] currentValue: 1 index: 2 array: [ 3, 2, 1 ] newVal: 3 thisArg: &#123; name: 'obj' &#125;;// arr00: false;Array.prototype.filter()语法 :arr.filter(callback(currentValue[, index[, array]])[, thisArg])callback : 数组中每个元素都会执行的回调函数.currentValue : 数组中正在被处理的当前元素.index : 数组中正在被处理的当前元素的索引.array : 调用该方法的数组.返回值 : 数组中每个元素调用callback后, 由符合条件的数组元素组成的新数组.如果没有符合条件的元素, 则返回空数组.12345678910111213141516let obj = &#123; name: 'obj'&#125;let arr0 = [3, 2, 1];let arr00 = arr0.filter(function(currentValue, index, array)&#123; let boolean = currentValue &gt; 1 ? true : false; console.log('arr0:', arr0, 'currentValue:', currentValue, 'index:', index, 'array:', array, 'thisArg:', this); return boolean;&#125;, obj)console.log('arr00:', arr00);// arr0: [ 3, 2, 1 ] currentValue: 3 index: 0 array: [ 3, 2, 1 ] thisArg: &#123; name: 'obj' &#125;// arr0: [ 3, 2, 1 ] currentValue: 2 index: 1 array: [ 3, 2, 1 ] thisArg: &#123; name: 'obj' &#125;//arr0: [ 3, 2, 1 ] currentValue: 1 index: 2 array: [ 3, 2, 1 ] thisArg: &#123; name: 'obj' &#125;// arr00: [ 3, 2 ];Array.prototype.find()语法 :arr.find(callback(currentValue[, index[, array]])[, thisArg])callback : 数组中每个元素都会执行的回调函数.currentValue : 数组中正在被处理的当前元素.index : 数组中正在被处理的当前元素的索引.array : 调用该方法的数组.返回值 : 数组中每个元素调用callback后, 返回第一个符合条件的元素. 否则返回 undefined.1234567891011121314let obj = &#123; name: 'obj'&#125;let arr0 = [3, 2, 1];let arr00 = arr0.find(function(currentValue, index, array)&#123; let boolean = currentValue &gt; 1 ? true : false; console.log('arr0:', arr0, 'currentValue:', currentValue, 'index:', index, 'array:', array, 'thisArg:', this); return boolean;&#125;, obj)console.log('arr00:', arr00);// arr0: [ 3, 2, 1 ] currentValue: 3 index: 0 array: [ 3, 2, 1 ] thisArg: &#123; name: 'obj' &#125;;// arr00: 3;Array.prototype.findIndex()语法 :arr.findIndex(callback(currentValue[, index[, array]])[, thisArg])callback : 数组中每个元素都会执行的回调函数.currentValue : 数组中正在被处理的当前元素.index : 数组中正在被处理的当前元素的索引.array : 调用该方法的数组.返回值 : 数组中每个元素调用callback后, 返回第一个符合条件的元素索引. 否则返回 -1.1234567891011121314let obj = &#123; name: 'obj'&#125;let arr0 = [3, 2, 1];let arr00 = arr0.findIndex(function(currentValue, index, array)&#123; let boolean = currentValue &gt; 1 ? true : false; console.log('arr0:', arr0, 'currentValue:', currentValue, 'index:', index, 'array:', array, 'thisArg:', this); return boolean;&#125;, obj)console.log('arr00:', arr00);// arr0: [ 3, 2, 1 ] currentValue: 3 index: 0 array: [ 3, 2, 1 ] thisArg: &#123; name: 'obj' &#125;;// arr00: 0;Array.prototype.reduce()语法 :arr.reduce(callback(accumulator[, currentValue[, index[, array]]])[, initialValue])callback : 数组中每个元素都会执行的回调函数.accumulator : 上一个元素调用回调函数后的返回值. 回调函数第一次执行时, 若提供了initialValue,则accumulator取值为initialValue. 若没有提供initialValue, 则accumulator取值为数组中第一个元素.currentValue : 数组中正在被处理的当前元素. 回调函数第一次执行时, 若提供了initialValue, 则currentValue取值为数组中第一个元素. 若没有提供initialValue, 则currentValue取值为数组中第二值.index : 数组中正在被处理的当前元素的索引.array : 调用该方法的数组.返回值 : 数组中每个元素调用callback后, 将上一次回调函数执行结果作为下一次回调函数参数, 并最终返回单个结果值.1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253let arr0 = [3, 2, 1];let arr00 = arr0.reduce(function(accumulator, currentValue, index, array) &#123; console.log('arr0', arr0, 'accumulator:', accumulator, 'currentValue:', currentValue, 'index:', index, 'array:', array); return accumulator + currentValue;&#125;, 0);console.log('arr00:', arr00);// arr0 [ 3, 2, 1 ] accumulator: 0 currentValue: 3 index: 0 array: [ 3, 2, 1 ];// arr0 [ 3, 2, 1 ] accumulator: 3 currentValue: 2 index: 1 array: [ 3, 2, 1 ];// arr0 [ 3, 2, 1 ] accumulator: 5 currentValue: 1 index: 2 array: [ 3, 2, 1 ];// arr00: 6;let arr0 = [3, 2, 1];let arr00 = arr0.reduce(function(accumulator, currentValue, index, array) &#123; console.log('arr0', arr0, 'accumulator:', accumulator, 'currentValue:', currentValue, 'index:', index, 'array:', array); return accumulator + currentValue;&#125;);console.log('arr00:', arr00);// arr0 [ 3, 2, 1 ] accumulator: 3 currentValue: 2 index: 1 array: [ 3, 2, 1 ];// arr0 [ 3, 2, 1 ] accumulator: 5 currentValue: 1 index: 2 array: [ 3, 2, 1 ];// arr00: 6;let arr0 = [1, 2, 3, 44, 5, 3, 2, 53, 1, 2, 3, 5, 44, 53, 55];const reducer = (accumulator, currentValue) =&gt; &#123; console.log('arr0', arr0, 'accumulator', accumulator, 'currentValue', currentValue); if (accumulator.length === 0 || accumulator[accumulator.length - 1] !== currentValue) &#123; accumulator.push(currentValue); &#125; return accumulator;&#125;;let arr00 = arr0.sort((a, b) =&gt; &#123;return a - b&#125;).reduce(reducer, []);console.log('arr00:', arr00);// arr0 [ 1, 1, 2, 2, 2, 3, 3, 3, 5, 5, 44, 44, 53, 53, 55 ] accumulator [] currentValue 1;// arr0 [ 1, 1, 2, 2, 2, 3, 3, 3, 5, 5, 44, 44, 53, 53, 55 ] accumulator [ 1 ] currentValue 1;// arr0 [ 1, 1, 2, 2, 2, 3, 3, 3, 5, 5, 44, 44, 53, 53, 55 ] accumulator [ 1 ] currentValue 2;// arr0 [ 1, 1, 2, 2, 2, 3, 3, 3, 5, 5, 44, 44, 53, 53, 55 ] accumulator [ 1, 2 ] currentValue 2;// arr0 [ 1, 1, 2, 2, 2, 3, 3, 3, 5, 5, 44, 44, 53, 53, 55 ] accumulator [ 1, 2 ] currentValue 2;// arr0 [ 1, 1, 2, 2, 2, 3, 3, 3, 5, 5, 44, 44, 53, 53, 55 ] accumulator [ 1, 2 ] currentValue 3;// arr0 [ 1, 1, 2, 2, 2, 3, 3, 3, 5, 5, 44, 44, 53, 53, 55 ] accumulator [ 1, 2, 3 ] currentValue 3;// arr0 [ 1, 1, 2, 2, 2, 3, 3, 3, 5, 5, 44, 44, 53, 53, 55 ] accumulator [ 1, 2, 3 ] currentValue 3;// arr0 [ 1, 1, 2, 2, 2, 3, 3, 3, 5, 5, 44, 44, 53, 53, 55 ] accumulator [ 1, 2, 3 ] currentValue 5;// arr0 [ 1, 1, 2, 2, 2, 3, 3, 3, 5, 5, 44, 44, 53, 53, 55 ] accumulator [ 1, 2, 3, 5 ] currentValue 5;// arr0 [ 1, 1, 2, 2, 2, 3, 3, 3, 5, 5, 44, 44, 53, 53, 55 ] accumulator [ 1, 2, 3, 5 ] currentValue 44;// arr0 [ 1, 1, 2, 2, 2, 3, 3, 3, 5, 5, 44, 44, 53, 53, 55 ] accumulator [ 1, 2, 3, 5, 44 ] currentValue 44;// arr0 [ 1, 1, 2, 2, 2, 3, 3, 3, 5, 5, 44, 44, 53, 53, 55 ] accumulator [ 1, 2, 3, 5, 44 ] currentValue 53;// arr0 [ 1, 1, 2, 2, 2, 3, 3, 3, 5, 5, 44, 44, 53, 53, 55 ] accumulator [ 1, 2, 3, 5, 44, 53 ] currentValue 53;// arr0 [ 1, 1, 2, 2, 2, 3, 3, 3, 5, 5, 44, 44, 53, 53, 55 ] accumulator [ 1, 2, 3, 5, 44, 53 ] currentValue 55;// arr00: [ 1, 2, 3, 5, 44, 53, 55 ];Array.prototype.reduceRight()语法(从右向左遍历,见reduce) :arr.reduceRight(callback(accumulator[, currentValue[, index[, array]]])[, initialValue])Array.prototype.entries()语法 :arr.entries()返回值 : 一个新的包含数组中每个索引的键/值对的Array Iterator对象.1234567891011121314151617181920212223242526272829303132333435let arr0 = [3, 2, 1];let arr00 = arr0.entries();let arr000 = arr00.next();let arr0000 = arr000.value;console.log('arr00:', arr00);console.log('arr000:', arr000);console.log('arr0000:', arr0000);// arr00;// Array Iterator &#123;&#125;// __proto__: Array Iterator// next: ƒ next()// Symbol(Symbol.toStringTag): "Array Iterator"// arr000;// &#123;value: Array(2), done: false&#125;j;// arr0000;// [0, 3];let arr0 = [3, 2, 1];let arr00 = arr0.entries();for(let item of arr00) &#123; console.log(item);&#125;// [ 0, 3 ];// [ 1, 2 ];// [ 2, 1 ];let arr0 = [3, 2, 1];let arr00 = [...arr0.entries()];console.log('arr00:', arr00);// arr00: [ [ 0, 3 ], [ 1, 2 ], [ 2, 1 ] ]Array.prototype.keys()语法 :arr.keys()返回值 : 一个新的包含数组中每个索引键的Array Iterator对象.123456789101112131415let arr0 = [3, 2, 1];let arr00 = arr0.keys();for(let item of arr00) &#123; console.log(item);&#125;// 0// 1// 2let arr0 = [3, 2, 1];let arr00 = [...arr0.keys()];console.log('arr00:', arr00);// arr00: [ 0, 1, 2 ];Array.prototype.values()语法 :arr.values()返回值 : 一个新的包含数组每个索引对应值的 Array Iterator 对象.1234567891011121314let arr0 = [3, 2, 1];let arr00 = arr0.keys();for(let item of arr00) &#123; console.log(item);&#125;// 0// 1// 2let arr0 = [3, 2, 1];let arr00 = [...arr0.keys()];console.log('arr00:', arr00);// arr00: [ 0, 1, 2 ];Array.prototype[@@iterator]()语法 :arr[Symbol.iterator]()返回值 : 数组的 iterator 方法，默认情况下与 values() 返回值相同.]]></content>
      <categories>
        <category>数组总结</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>数组原型</tag>
        <tag>迭代方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Array原型之非变异方法]]></title>
    <url>%2FArray%E5%8E%9F%E5%9E%8B%E4%B9%8B%E9%9D%9E%E5%8F%98%E5%BC%82%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[ArrayArray对象是用于构造数组的全局对象.概述数组对象是一个有序的数据(原始类型或对象类型)集合, 是一种类列表对象,它的原型提供了数组操作的方法.数组只能用整数作为数组元素的索引,而不是字符串,且从0开始,第一个元素的索引为0.使用非整数并通过[]或.来访问数组或设置数组元素时,所操作的并不是数组列表的元素,而是数组对象属性集合上的变量.数组对象的属性和数组元素列表是分开存储的,并且数组的遍历和修改操作也不能作用于这些命名属性.123456var arr = [];arr['zero'] = 'zero';arr[0] = 0;arr.forEach(item =&gt; console.log(item))// 0原型方法非变异方法Array.prototype.slice()描述 :浅拷贝数组指定区域的元素.语法 :arr.slice(begin[, end])begin(可选) : 起始索引, 默认值为0. 如果是负数, 则开始索引会被自动计算成为 this.length + start.end : 终止索引, 默认值 this.length. 不包括end位置. 如果是负数时, 规则如上.返回值 : 返回截取的新数组(浅复制).1234567891011let arr0 = [3, 2, 1];let arr00 = arr0.slice();console.log('arr0:', arr0, 'arr00:', arr00);// arr0: [ 3, 2, 1 ] arr00: [ 3, 2, 1 ]let arr1 = [5, 4, 3, 2, 1];let arr11 = arr1.slice(2, 3);console.log('arr1:', arr1, 'arr11:', arr11);// arr1: [ 5, 4, 3, 2, 1 ] arr11: [ 3 ].Array.prototype.concat()描述 :合并多个值或数组.语法 :array.concat(element0[, element1[, ...[, elementN]]])elementN : 将要连接的值或数组.返回值 : 多个值或数组合并后的新数组.12345678910111213let arr0 = [6, 5, 4];let arr1 = [3, 2, 1];let arr = arr0.concat(arr1);console.log('arr0:', arr0, 'arr1:', arr1, 'arr:', arr);// arr0: [ 6, 5, 4 ] arr1: [ 3, 2, 1 ] arr: [ 6, 5, 4, 3, 2, 1 ]let arr2 = [6, 5, 4];let arr3 = [2, 1];let arr = arr2.concat(3, arr3);console.log('arr2: ', arr2, 'arr3: ', arr3, 'arr', arr);// arr2: [ 6, 5, 4 ] arr3: [ 2, 1 ] arr [ 6, 5, 4, 3, 2, 1 ]Array.prototype.join()描述 :将数组众元素用指定字符连接成字符串.语法 :arr.join(connector)connector : 指定一个字符链接数组中的每个元素, 默认逗号连接.返回值 : 用指定连接符将数组中元素连接起来的字符串.1234567let arr0 = [3, 2, 1];let str1 = arr0.join();let str2 = arr0.join('');let str3 = arr0.join('-');console.log('arr0:', arr0, 'str1:', str1, 'str2:', str2, 'str3:', str3);// arr0: [ 3, 2, 1 ] str1: 3,2,1 str2: 321 str3: 3-2-1;Array.prototype.toString()描述 :用字符串形式表示数组元素.语法 :arr.toString()返回值 : 逗号连接数组元素组成的字符串. 当数组元素为数组时, 自动调用其toString()方法.123456let arr0 = [3, 2, 1];let arr00 = arr0.toString();let arr1 = [[6, [5, 4]], 3, 2, 1].toString();console.log('arr0:', arr0, 'arr00:', arr00, 'arr1:', arr1);// arr0: [ 3, 2, 1 ] arr00: 3,2,1 arr1: 6,5,4,3,2,1;Array.prototype.includes()描述 :判断数组中是否指定值.语法 :arr.includes(searchElement[, fromIndex])searchElement : 需要查询的值.fromIndex : 起始索引, 默认值为0. 如果是负数时, 规则如上.返回值 : 布尔值.123456let arr0 = [3, 2, 1];let a = arr0.includes(3);let b = arr0.includes(3, 1);console.log('arr0', arr0, 'a:', a, 'b:', b);// arr0 [ 3, 2, 1 ] a: true b: false;Array.prototype.indexOf()描述 :查询指定元素在数组中首次出现的索引位置.语法 :arr.indexOf(searchElement[, fromIndex])searchElement : 需要查询的值.fromIndex : 起始索引, 默认值为0. 如果是负数时, 规则如上.返回值 : 首次被找到的元素在数组中的索引位置; 若没有找到则返回 -1.123456let arr0 = [3, 2, 1];let a = arr0.indexOf(1);let b = arr0.indexOf(3, 1);console.log('arr0:', arr0, 'a:', a, 'b:', b);// arr0: [ 3, 2, 1 ] a: 2 b: -1;Array.prototype.lastIndexOf()描述 :从数组的后面向前查找, 查询指定元素在数组中首次出现的索引位置.语法 :arr.lastIndexOf(searchElement[, fromIndex = arr.length - 1])searchElement : 需要查询的值.fromIndex : 逆向查找起始索引, 默认值 this.length - 1.返回值 : 逆向首次被找到的元素在数组中的索引位置.123456let arr0 = [3, 2, 1];let a = arr0.lastIndexOf(1);let b = arr0.lastIndexOf(3, 1);console.log('arr0:', arr0, 'a:', a, 'b:', b);// arr0: [ 3, 2, 1 ] a: 2 b: 0;]]></content>
      <categories>
        <category>数组总结</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>数组原型</tag>
        <tag>非变异方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Array原型之变异方法]]></title>
    <url>%2FArray%E5%8E%9F%E5%9E%8B%E4%B9%8B%E5%8F%98%E5%BC%82%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[ArrayArray对象是用于构造数组的全局对象.概述数组对象是一个有序的数据(原始类型或对象类型)集合, 是一种类列表对象,它的原型提供了数组操作的方法.数组只能用整数作为数组元素的索引,而不是字符串,且从0开始,第一个元素的索引为0.使用非整数并通过[]或.来访问数组或设置数组元素时,所操作的并不是数组列表的元素,而是数组对象属性集合上的变量.数组对象的属性和数组元素列表是分开存储的,并且数组的遍历和修改操作也不能作用于这些命名属性.123456var arr = [];arr['zero'] = 'zero';arr[0] = 0;arr.forEach(item =&gt; console.log(item))// 0原型方法变异方法Array.prototype.push()描述 :在数组末尾添加一个或多个元素.语法 :arr.push(element0 ..., elementN)elementN : 将要添加到数组末尾的元素.返回值 : 被改动后的原数组的length值, 且原数组被改变.12345let arr0 = [3, 2, 1];let arr0Len = arr0.push('Array');console.log('arr0:', arr0, 'arr0Len:', arr0Len);// arr0: [3, 2, 1, 'Array'] arr0Len: 4;Array.prototype.unshift()描述 :在数组开头添加一个或多个元素.语法 :arr.unshift(element1, ..., elementN)elementN : 将要添加到数组开头的元素.返回值 : 被改动后的原数组的length值, 且原数组被改变.12345let arr0 = [3, 2, 1];let arr0Len = arr0.unshift('Array');console.log('arr0:', arr0, 'arr0Len:', arr0Len);// arr0: ['Array', 3, 2, 1] arr0Len: 4;Array.prototype.pop()描述 :从数组中删除最后一个元素.语法 :arr.pop()返回值 : 被删除的数组元素(空属组调用, 则返回undefined), 且原数组被改变.12345let arr0 = [3, 2, 1];let ele = arr0.pop();console.log('arr0:', arr0, 'ele:', ele);// arr0: [3, 2] ele: 1;Array.prototype.shift()描述 :从数组中删除第一个元素.语法 :arr.shift()返回值 : 被删除的数组元素(空属组调用, 则返回undefined), 且原数组被改变.12345let arr0 = [3, 2, 1];let ele = arr0.shift();console.log('arr0:', arr0, 'ele:', ele);// arr0: [2, 1] ele: 3;Array.prototype.splice()描述 :从数组中删除指定数量的元素并添加向数组添加元素.语法 :array.splice(start[, deleteCount[, element1[, ...[, elementN]]]])start : 指定修改位置(从0计数).deleteCount 要移除的数组元素个数. 默认值为 this.length - start.elementN : 要添加的数组元素.返回值 : 由被删除的元素组成的数组, 且原数组被改变.1234567891011121314151617181920212223let arr0 = [3, 2, 1];let arr00 = arr0.splice(2, 0, 4, 5, 6);console.log('arr0:', arr0, 'arr00:', arr00);// arr0: [3, 2, 4, 5, 6, 1] arr00: [];let arr1 = [3, 2, 1];let arr11 = arr1.splice(2, 1, 4, 5, 6);console.log('arr1:', arr1, 'arr11:', arr11);// arr1: [3, 2, 4, 5, 6] arr11: [1];let arr3 = [3, 2, 1];let arr33 = arr3.splice(1, 2);console.log('arr3:', arr3, 'arr33:', arr33);// arr3: [3] arr33: [2, 1];let arr4 = [3, 2, 1];let arr44 = arr4.splice(3, 0 , 4, 5, 6);console.log('arr4:', arr4, 'arr44:', arr44);// arr4: [3, 2, 1, 4, 5, 6] arr44: [];Array.prototype.sort()描述 :用原地算法对数组的元素进行排序.语法 :arr.sort([compareFunction])compareFunction : 用来指定按某种顺序进行排列的函数. 如果省略, 元素按照转换为的字符串的各个字符的Unicode位点进行排序. 指明了 compareFunction, 那么数组会按照调用该函数的返回值排序. a 和 b 是两个将要被比较的元素:compareFunction(a, b) 小于 0, 那么 a 会被排列到 b 之前;compareFunction(a, b) 等于 0, a 和 b 的相对位置不变;compareFunction(a, b) 大于 0, b 会被排列到 a 之前;返回值 : 排序后的数组.12345let arr0 = [3, 4, 2, 5, 1];let arr00 = arr0.sort((a, b) =&gt; a-b);console.log('arr0:', arr0, 'arr00:', arr00);// arr0:, [1, 2, 3, 4, 5] arr00: [1, 2, 3, 4, 5];Array.prototype.reverse()描述 :将数组中元素的位置颠倒.语法 :arr.reverse()返回值 : 位置颠倒后的数组.12345let arr0 = [3, 2, 1];let arr00 = arr0.reverse();console.log('arr0:', arr0, 'arr00:', arr00);// arr0: [1, 2, 3] arr00: [1, 2, 3];Array.prototype.copyWithin()描述 :将数组的某一部分浅复制到指定位置.语法 :arr.copyWithin(target[, start[, end]])target : 索引起始为0. 被复制的内容将要替换的位置. 如果是负数, target将从 this.length + target开始计算.start : 起始索引, 默认值为0. 被复制内容的起始位置, 包括start位置的元素. 如果是负数, 则开始索引会被自动计算成为 this.length + start.end : 终止索引, 默认值为this .length, 索引起始为0. 被复制内容的结束位置, 但不包括end位置的元素. 如果是负数. 则终止索引会被自动计算成为 this.length + end.返回值 : 被改动后的原数组. 数组内容变化, 长度不变.1234567891011121314151617let arr0 = [3, 2, 1];let arr00 = arr0.copyWithin(2, 0);console.log('arr0:', arr0, 'arr00:', arr00);//arr0: [3, 2, 3] arr00: [3, 2, 3];let arr1 = [3, 2, 1];let arr11 = arr1.copyWithin(2, 1, 2);console.log('arr1:', arr1, 'arr11:', arr11);// arr1: [3, 2, 2] arr11: [3, 2, 2];let arr2 = [3, 2, 1];let arr22 = arr2.copyWithin(-1, -2, -1);console.log('arr2', arr2, 'arr22', arr22);// arr1: [3, 2, 2] arr11: [3, 2, 2];Array.prototype.fill()描述 :将数组的某一区域的全部元素用指定值替换.语法 :arr.fill(value[, start[, end]])value : 填充数组的参数值.start : 起始索引, 默认值为 0. 如果是负数时, 规则如上.end : 终止索引, 默认值为 this.length. 不包括end位置. 如果是负数时, 规则如上.返回值 : 被改动后的原数组.1234567891011let arr0 = [3, 2, 1];let arr00 = arr0.fill(3);console.log('arr0:', arr0, 'arr00:', arr00);// arr0: [3, 3, 3] arr00: [3, 3, 3];let arr1 = [3, 2, 1];let arr11 = arr1.fill(3, 1);console.log('arr1:', arr1, 'arr11:', arr11);// arr1: [3, 3, 3] arr11: [3, 3, 3]]]></content>
      <categories>
        <category>数组总结</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>数组原型</tag>
        <tag>变异方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Array构造函数]]></title>
    <url>%2FArray%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[ArrayArray对象是用于构造数组的全局对象.概述数组对象是一个有序的数据(原始类型或对象类型)集合, 是一种类列表对象,它的原型提供了数组操作的方法.数组只能用整数作为数组元素的索引,而不是字符串,且从0开始,第一个元素的索引为0.使用非整数并通过[]或.来访问数组或设置数组元素时,所操作的并不是数组列表的元素,而是数组对象属性集合上的变量.数组对象的属性和数组元素列表是分开存储的,并且数组的遍历和修改操作也不能作用于这些命名属性.123456var arr = [];arr['zero'] = 'zero';arr[0] = 0;arr.forEach(item =&gt; console.log(item))// 0构造函数属性Array.length构造函数的length属性,该属性为静态属性(详见Function.length),不是数组实例的length属性,其值为1.123console.log(Array.length);// 1Array.prototype构造函数的原型对象,所有的数组实例都会从Array.prototype继承属性和方法.通过扩展Array原型上的属性和方法进而为所有的数组实例增加属性和方法.123456789101112Array.prototype.type = "Array";Array.prototype.first = function() &#123; return this[0];&#125;;var arr = [3, 2, 1];arr.type;// Array;arr.first();// 3;构造函数方法Array.from()描述 :从一个类似数组或可迭代对象中创建一个新的数组实例.语法 :Array.from(arrayLike[, mapFn[, thisArg]])ArrrayLike : 伪数组对象(拥有length属性和若干索引属性) 和 可迭代对象.mapFn : 返回的新数组都会执行的回调函数.thisArg : 执行回调函数时this对应的对象.返回值 : 新的数组实例.123456789101112131415161718Array.from('Array');// ["A", "r", "r", "a", "y"];(function () &#123; return Array.from(arguments);&#125;)(3, 2, 1)// [3, 2, 1];let s = new Set(['array', Array]);Array.from(s);// ["array", function];Array.from([3, 2, 1], x =&gt; x.toString());// ["3", "2", "1"];Array.isArray()描述 :判断待验证的参数是否为Array.语法 :Array.isArray(obj)obj : 待验证参数.返回值 : 若待验证参数为数组时,则为true; 否则false.123456789101112131415161718Array.isArray([]);// true;Array.isArray(&#123;&#125;);// false;Array.isArray(Array.prototype);// true;// Polyfillif (!Array.isArray) &#123; Array.isArray = function(arg) &#123; return Object.prototype.toString.call(arg) === '[object Array]'; &#125;;&#125;;Array.of()描述 :创建一个由传入参数组成的新数组实例, 而不考虑参数的数量或类型.语法 :Array.of(element0[, element1[, ...[, elementN]]])elementN : 任意个参数,将顺序得成为数组的元素.返回值 : 新的数组实例.123456789101112131415161718Array.of(3);// [3];Array.of(3, 2, 1);// [3, 2, 1];Array.of('Array', Array);// ["Array", function];// Polyfillif (!Array.of) &#123; Array.of = function() &#123; return Array.prototype.slice.call(arguments); &#125;;&#125;]]></content>
      <categories>
        <category>数组总结</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>构造函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器缓存机制]]></title>
    <url>%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[浏览器缓存强缓存释义: 客户端第一次问服务器要某个资源时，服务器丢还给客户端所请求的这个资源同时，告诉客户端将这个资源保存在本地，并且在未来的某个时点之前如果还需要这个资源，直接从本地获取就行了，不用向服务器请求.这种方式缓存下来的资源称为强缓存.Expires &amp; Cache-Control:max-ageExpires:该字段是http1.0时的规范，值为一个绝对时间的GMT格式的时间字符串，代表缓存资源的过期时间，在这个时点之前，即命中缓存.Cache-Control:该字段是http1.0时的规范，值为一个绝对时间的GMT格式的时间字符串，代表缓存资源的过期时间，在这个时点之前，即命中缓存.参数:no-cache: 如果请求头部包含no-cache指令，表示客户端不接收缓存过的响应.中间缓存服务器必须将请求转发给给源服务器. 浏览器强制刷新(window下ctrl+F5)就是这个原理，所以的请求都设置no-cacheno-store: 暗示请求和响应包含机密信息，不能进行缓存.区分: no-store才是真正的不缓存max-age: 该指令用来标识缓存资源的最大有效期. 如果max-age=0，就会向源服务器发送请求进行缓存资源新鲜度的验证.浏览器普通刷新F5“Cache-Control”:” cache-directive”*作为请求首部时，cache-directive 的可选值有:“Cache-Control”:” cache-directive”*作为响应首部时，cache-directive 的可选值有:在请求头中max-age=0与no-cache的区别？返回的状态来看：no-cache都是200，而max-age可能是304（如果浏览器有缓存）. 请求参数：max-age请求头一般会携带If-Modified-Since或If-None-Match字段进行新鲜度验证，而no-cache不会携带. F5刷新是max-age=0来实现，而强制刷新(Ctrl+F5)是通过no-cache实现. 异同: Expires是HTTP 1.0+的首部，用来指定一个绝对的过期日期，依赖客户端时间设置的准确性,缓存时间是相对服务器上的时间而言的.而max-age是HTTP/1.1的Cache-Control的一个字段，用来指定文档的最大使用时间.协商缓存释义: 客户端第一次问服务器要某个资源时，服务器丢还给客户端所请求的这个资源同时，将该资源的一些信息（文件摘要、或者最后修改时间）也返回给客户端，告诉客户端将这个资源缓存在本地.当客户端下一次需要这个资源时，将请求以及相关信息（文件摘要、或者最后修改时间）一并发送给服务器，由服务器来判断客户端缓存的资源是否需要更新：如不需要更新，就直接告诉客户端获取本地缓存资源；如需要更新，则将最新的资源连同相应的信息一并返回给客户端.Last-Modified &amp; If-Modified-Since &amp; Etag &amp; If-None-MatchLast-Modidied &amp; If-Modified-Since:Last-Modified: 为实体首部字段，值为资源最后更新时间，随服务器response返回.If-Modified-Since: 为请求首部字段，通过比较两个时间来判断资源在两次请求期间是否有过修改，如果没有修改，则命中协商缓存，浏览器从缓存中获取资源；如果有过修改，则服务器返回资源，同时返回新的Last-Modified时间.Etag &amp; If-None-Match:Etag: 为相应头部字段，表示资源内容的唯一标识，随服务器response返回.If-None-Match: 为请求头部字段，服务器通过比较请求头部的If-None-Match与当前资源的ETag是否一致来判断资源是否在两次请求之间有过修改，如果没有修改，则命中协商缓存，浏览器从缓存中获取资源；如果有过修改，则服务器返回资源，同时返回新的ETag.不能缓存的请求HTTP信息头中包含Cache-Control:no-cache，pragma:no-cache（HTTP1.0），或Cache-Control:max-age=0等告诉浏览器不用缓存的请求. Cache-Control: no-cache：这个很容易让人产生误解，使人误以为是响应不被缓存.实际上Cache-Control: no-cache是会被缓存的，只不过每次在向客户端（浏览器）提供响应数据时，缓存都要向服务器评估缓存响应的有效性需要根据Cookie，认证信息等决定输入内容的动态请求是不能被缓存的经过HTTPS安全加密的请求（有人也经过测试发现，ie其实在头部加入Cache-Control：max-age信息，firefox在头部加入Cache-Control:Public之后，能够对HTTPS的资源进行缓存，参考《HTTPS的七个误解》）POST请求无法被缓存HTTP响应头中不包含Last-Modified/Etag，也不包含Cache-Control/Expires的请求无法被缓存浏览器缓存机制示意图]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github+Hexo+Next博客搭建之Hexo,Next及部署]]></title>
    <url>%2FGithub-Hexo-Next%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%B9%8BHexo-Next%E5%8F%8A%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[博客已经搭建好了,自然可以趁热打铁写一些博客搭建的经验.一是方便自己以后查看,免得忘记.二是如果有人想了解博客搭建的过程,也正好有个参考.(如果SEO做的好,就有可能看到这篇文章).本文仅记录怎么去搭建博客,而不会解释每一步原理,有些东西我自己都没有搞的太清楚.毕竟我只是想借助博客这个平台记录平时工作的经验而已,细究相关方面知识并不是我的最终目的现在回头看博客的搭建过程,可以总结归纳以下几点. markdown,git和GitHub,github和coding部署, Hexo和Next了解, SEO等Hexo,Next,部署,SEO该博客的搭建用的是Hexo博客框架,详细的说明官方文档都有提到.在主题的选择上用的是Next,对应的也有相关的官方文档.接下来就搭建过程中遇到的简单介绍一下Hexo中基本指令npm install -g hexo-cli // npm安装Hexo, 非Hexo中命令 hexo init &lt;folder&gt; // 指定文件夹下初始化Hexo,若没有设置folder, Hexo默认在目前的文件夹建立网站 cd &lt;folder&gt; // 进入指定文件夹, 非Hexo中命令 npm install // 安装配置文件packge.json中的依赖, 非Hexo中命令 hexo new [layout] &lt;title&gt; // 新建一篇文章.layout默认default_layout参数,标题有空格,需使用引号括起来 hexo generate // 生成静态文件. -d, --deploy 文件生成后立即部署网站.可简写为 hexo g hexo server // 启动服务器.默认情况下网址为:http://loalhost:4000/. -p, --port 重设端口 hexo deploy // 部署网站. -g, --generate 部署之前预先生成静态文件.可简写为 hexo d hexo clean // 清除缓存文件和已生成的静态文件 Hexo部署地址配置打开站点配置文件_config.yml,找到deploy字段,配置如下deploy: - type: git // 以下是我的git地址 repo: git@github.com:yexiaochen/yexiaochen.github.io.git branch: master - type: git // 以下是我的coding地址 repo: git@git.coding.net:yexiaochen/yexiaochen.coding.me.git branch: master 安装Next主题定位到Hexo站点目录下,执行一下命令即可git clone https://github.com/iissnan/hexo-theme-next themes/next 克隆完成后,打开站点配置文件_config.yml,找到theme字段,并将其值更改为next设置菜单页面Next主题有默认的菜单项,部分菜单项需要自己添加.添加菜单项页面新建标签页面在根目录下新建标签页面hexo new page tags 在新建的页面编辑一下内容123456---title: All tagsdate: 2018-03-24 18:02:30type: &quot;tags&quot;comments: false---在主题配置文件_config.yml内, 找到menu字段,添加如下内容123456789menu:home: / || home# about: /about/ || usertags: /tags/ || tagscategories: /categories/ || tharchives: /archives/ || archive# schedule: /schedule/ || calendar# sitemap: /sitemap.xml || sitemap# commonweal: /404/ || heartbeat在菜单项里添加分类项操作同上添加gitment评论 添加gitalk评论远程仓库新建一个repository,名字随意,待会儿会用到添加OAuth Apps.登陆GitHub,通过Settings =&gt; Developer settings =&gt; OAuth Apps,点击New OAuth App.添加后会生成Client ID和Client Secretgitalk和gitment是差不多的产品, 在我们更换评论系统时, 可以在其基础上修改. 在主题配置文件_config.yml内, 找到gitment字段,添加如下内容.12345678910111213gitment: enable: true mint: true # RECOMMEND, A mint on Gitment, to support count, language and proxy_gateway count: true # Show comments count in post meta area lazy: true # Comments lazy loading with a button cleanly: true # Hide &apos;Powered by ...&apos; on footer, and more language: # Force language, or auto switch by theme github_user: yexiaochen # MUST HAVE, Your Github ID 18507780 github_repo: blog-gitment # MUST HAVE, The repo you use to store Gitment comments client_id: your_client_id # MUST HAVE, Github client id for the Gitment client_secret: your_client_secret # EITHER this or proxy_gateway, Github access secret token for the Gitment proxy_gateway: # Address of api proxy, See: https://github.com/aimingoo/intersect redirect_protocol: # Protocol of redirect_uri with force_redirect_protocol when mint enabled在themes/next/layout/_third-party/comments/gitment.swig文件中, 按照gitalk文档里的配置进行修改.123456789const gitalk = new Gitalk(&#123;clientID: 'GitHub Application Client ID',clientSecret: 'GitHub Application Client Secret',repo: 'GitHub repo',owner: 'GitHub repo owner',admin: ['GitHub repo owner and collaborators, only these guys can initialize github issues'],id: location.pathname, // Ensure uniqueness and length less than 50distractionFreeMode: false // Facebook-like distraction free mode&#125;)注意: gitalk 需要GitHub账号登陆才可以创建初始化.部署coding部署到coding和部署到GitHub类似,也是要添加SSH的.新建的项目名称也是要求按照一定的规范来,细节可参考Coding Pages.在Pages服务的设置可参考下图DNS解析设置购买域名后,要对其进行解析设置.因为国外墙的原因,故博客在部署时也选在了不同的平台上.不同的解析路线对应不同的项目URL博客的搭建到此就结束了,其中还是有许多细节没有提到,时间久了已经忘了大部分了]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
        <tag>coding</tag>
        <tag>部署</tag>
        <tag>DNS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github+Hexo+Next博客搭建之git和GitHub]]></title>
    <url>%2FGithub-Hexo-Next%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%B9%8Bgit%E5%92%8C%08GitHub%2F</url>
    <content type="text"><![CDATA[博客已经搭建好了,自然可以趁热打铁写一些博客搭建的经验.一是方便自己以后查看,免得忘记.二是如果有人想了解博客搭建的过程,也正好有个参考.(如果SEO做的好,就有可能看到这篇文章).本文仅记录怎么去搭建博客,而不会解释每一步原理,有些东西我自己都没有搞的太清楚.毕竟我只是想借助博客这个平台记录平时工作的经验而已,细究相关方面知识并不是我的最终目的.现在回头看博客的搭建过程,可以总结归纳以下几点. markdown,git和GitHub,github和coding部署, Hexo和Next了解, SEO等git和GitHub接下来会按一下流程展开,本地git配置 =&gt; 关联远程仓库 =&gt; 初始化仓库.由于博主使用的Mac,执行命令时会和window下cmd有所区别.git配置完成git 的安装后,在使用之前需要配置一些全局参数, 如username和email.因为GitHub每次commit都会记录它们.git config --global user.name &quot;username&quot; git config --global user.email &quot;email&quot; 除了username和email外,还有许多自定义配置,示例:git config --global color.ui true // git输出显示不同颜色 git config --global ignorecase true // git对仓库中的文件大小写敏感 git config --global alias.st status // git提供alias的功能,git status缩写为git st git config --global apply.whitespace nowarn // git忽略空白的变化 查看所有已经做出的配置:git config -l 或 git config --list 添加远程仓库首先在github官网有自己的账号,之后就可以创建仓库了.添加SSH Key由于你的本地Git仓库和github仓库之间的传输是通过SSH加密的,所以需执行以下步骤:本地创建ssh key.$ ssh-keygen -t rsa -C &quot;your_email@youremail.com&quot; 后面的your_email@youremail.com改为你在github上注册的邮箱,之后会要求确认路径和输入密码,我们默认一路回车就行.成功的话会在~/下生成.ssh文件夹,进去打开id_rsa.pub,复制里面的key.ls -al ~/.ssh // 查看是否存在id_rsa.pub,若存在,执行下一步; cd ~/.ssh // 进入.ssh目录 cat id_rsa.pub // 查看复制id_rsa.pub 在GitHub里添加复制的id_rsa.pub. Settings =&gt; SSH and GPG keys =&gt;New SSH key.操作之后,如图示:Title任意填写,Key填入之前复制的id_rsa.pub.点击Add SSH key,添加已经完成.验证是否成功,输入下列命令:ssh -T git@github.com 如果是第一次的会提示是否continue,输入yes就会看到:You’ve successfully authenticated,but GitHub does not provide shell access.这就表示已成功连上github.创建GitHub项目并添加远程仓库登陆github账户后,点击New repository, 会有Create a new repository页面,填写相关信息,点击Create repository,可以根据官网提供的方式添加远程仓库.如下:…or create a new repository on the command lineecho &quot;# something&quot; &gt;&gt; README.md // 生成readme.md git init // 初始化本地仓库 git add README.md // 将文件添加到暂存区 git commit -m &quot;first commit&quot; // 将暂存区文件提交到仓库中 git remote add origin git@github.com:your-repository // 添加你的远程仓库 git push -u origin master // 将本地仓库推送到远程仓库 …or push an existing repository from the command linegit remote add origin git@github.com:your-repository git push -u origin master 以上步骤完成了本地仓库到远程仓库的连接,接下来总结git的一些常用的命令深入了解可参考 git中文git的常用命令状态和工作区域三种状态已提交: 表示数据已经安全得保存在本地数据库中.已修改: 表示修改了文件,但还没保存到数据库中.已暂存: 表示对一个已修改文件的当前版本做了标记,使之包含在下次提交的快照中.三种工作区域Git仓库目录: 是Git用来保存项目的元数据和对象数据库的地方.这是Git中最重要的部分,从其他计算机克隆仓库时,拷贝的就是这里的数据.工作目录: 对项目的某个版本独立提取出来的内容.这些从Git仓库的压缩数据库中提取出来的文件,放在磁盘上供你使用或修改.暂存区: 是一个文件,保存了下次将提交的文件列表信息,一般在Git仓库目录中.有时也被称作’索引’.工作目录下的两种状态已跟踪: 指被纳入了版本控制的文件,在上一次快照中有它们的记录,在工作一段时间后,它们的状态可能处于为修改,已修改或已暂存.未跟踪: 工作目录中除了已跟踪文件以外的所有其它文件都属于未跟踪文件,它们既不存在与上次快照中,也没有放入暂存区.初次克隆某个仓库的时候,工作目录中的所有文件都属于已跟踪文件,并处于未修改状态.Git工作流程基本的 Git 工作流程如下：在工作目录中修改文件.暂存文件,将文件的快照放入暂存区域.提交更新,找到暂存区域的文件,将快照永久性存储到 Git 仓库目录.如果 Git 目录中保存着的特定版本文件,就属于已提交状态. 如果作了修改并已放入暂存区域，就属于已暂存状态.如果自上次取出后,作了修改但还没有放到暂存区域,就是已修改状态.基础操作初始化Git仓库git init 该命令将创建一个名为.git的子目录,这个子目录含有初始化的Git仓库中所有的必须文件添加文件到暂存区git add &lt;file&gt; // 添加单个文件到暂存区 git add . // &apos;.&apos; 表示所有文件、文件夹和子文件夹 添加文件到仓库git commit // 将暂存区的文件提交到仓库中 git commit -m &apos;提交信息&apos; // -m 带提交信息,说明本次提交内容或修改等 git commit -am // -a Git会自动把所有已经跟踪过的文件暂存一并提交,从而跳过git add步骤 查看文件状态git status // 查看哪些文件处于什么状态 git status -s // git status -short 输出简介显示 ?? filename-1 // 新添加未跟踪文件前面有??标记 A filename-2 // 新添加到暂存区文件前有A标记 M filename-3 // 出现在左边的M表示,该文件被修改了并放入了暂存区 M filename-4 // 出现在右边的M表示该文件被修改了但没放入暂存取 MM filename-5 // 同时出现表示在工作区被修改并提交到暂存区由于在工作区中被修改了,所以说暂存区和工作区都有该文件的修改记录 查看文件具体修改git diff // 该命令查看未暂存的文件更新了哪些部分,用于比较工作目录中当前文件和暂存区域快照之间的差异 git diff --cached // 该命令用于查看已暂存的将要添加到下次提交里的内容 (Git 1.6.1 及更高版本还允许使用 git diff --staged，效果是相同的) 查看提交历史git log // 按提交时间列出所有的更新,最新的更新排在最上面 git log -p -(n) // -p 用来显示每次提交的内容差异. -(n) 仅显示最近n次提交 git log --stat // 每次的简略的统计信息 git log --pretty=oneline // 该选项指定使用不同于默认格式的方式展示提交历史. 可用选项包括oneline,short,full,fuller和format(后跟指定格式) git log --shortstat // 只显示--stat中最后的行数修改添加移除统计 git log --name-only // 仅在提交信息后显示已修改的文件清单 git log --name-status // 显示新增、修改、删除的文件清单 git log --graph // 显示ASCLL图形表示的分支合并历史 git relog // 引用日志,记录了HEAD和分支引用所指向的历史,只存在在于本地仓库 撤销操作git reset HEAD &lt;file&gt; // 丢弃已经进入暂存取的修改 git checkout -- &lt;file&gt; // 丢弃工作区中文件的修改 git checkout -- . // 丢弃当前目录下所有工作区中的修改 退回到某个提交版本git reset --hard HEAD^ // 回退到上一个提交 git reset --hard HEAD^^ // 回退到上上一个提交 git reset --hard &lt;commit_id&gt; // 回退到指定id的提交版本 删除操作在文件未添加到暂存取之前,可以直接物理删除想要删除的文件.或通过git checkout -- &lt;file&gt; 来丢弃修改.如果文件已经被提交,则需要git rm删除git rm &lt;file&gt; // 删除被提交的文件 远程仓库查看远程仓库git remote // 查看已配置的远程仓库服务器 git remote -v // 显示需要读写远程仓库使用的Git保存的简写与对应的URL git remote show &lt;remote-name&gt; // 查看某一个远程仓库的更多信息 添加远程仓库git remote add &lt;remote-name&gt; &lt;url&gt; // 添加地址为URL,名为remote-name的引用 从远程仓库中拉取与推送git fetch &lt;remote-name&gt; // 该命令将数据拉取到本地仓库,并不会自动合并或修改当前的工作 git pull &lt;remote-name&gt; // 改命令自动抓取然后合并远程分支到当前分支 git push &lt;remote-name&gt; &lt;branch-name&gt; // 将branch-name分支推送到remote-name服务器上 git push -u &lt;remote-name&gt; &lt;branch-name&gt; // 第一次使用带上-u参数,在将本地的 master 分支推送到远程新的 master 分支的同时,还会把本地的 master 分支和远程的 master 分支关联起来 远程仓库的移除与重命名git remote rm &lt;remote-name&gt; // 移除远程仓库 git remote rename &lt;old-name&gt; &lt;new-name&gt; // 重命名远程仓库 修改本地仓库对应的远程仓库git remote set-url &lt;remote-name&gt; &lt;url&gt; // 当远程的仓库地址发生变化时,需要修改本地仓库对应的远程仓库地址 分支管理git branch // 查看本地分支信息, 输出内容中,标记*,表示当前所在分支 git branch -v // 查看详细的本地分支信息 git branch &lt;branch-name&gt; // 新建一个branch-name分支 git checkout &lt;branch-name&gt; // 新建完branch-name分支后,并通过该命令切到branch-name分支 git checkout master git merge &lt;branch-name&gt; // 切换回master分支,并将branch-name分支的修改合并到master分支 git branch -d &lt;branch-name&gt; // 删除branch-name分支]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github+Hexo+Next博客搭建之Markdown]]></title>
    <url>%2FGithub-Hexo-Next%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%B9%8BMarkdown%2F</url>
    <content type="text"><![CDATA[博客已经搭建好了,自然可以趁热打铁写一些博客搭建的经验.一是方便自己以后查看,免得忘记.二是如果有人想了解博客搭建的过程,也正好有个参考.(如果SEO做的好,就有可能看到这篇文章).本文仅记录怎么去搭建博客,而不会解释每一步原理,有些东西我自己都没有搞的太清楚.毕竟我只是想借助博客这个平台记录平时工作的经验而已,细究相关方面知识并不是我的最终目的.现在回头看博客的搭建过程,可以总结归纳以下几点. markdown,git和GitHub, github和coding部署, Hexo和Next了解, SEO等Markdown工欲善其事,必先利其器.作为程序员,平时的编辑语言首选是markdown,markdown的使用其实很简单.之前除了整理一下文档外,平时倒是用的不多,在此整理一下段落和换行一个Markdown段落前后要有一个以上空行,普通段落不该用空行或制表符来缩进.段落内强迫换行可在插入处键入两个以上空格然后回车.标题markdown支持两种标题,类Setext和Atx形式.类Atx形式是在行首插入1到6个#,分别对应1到6级标题,示例:123# 一级标题## 二级标题### 三级标题区块引用Markdown中建立区块引用,需在行首最前面加上&gt;:1&gt; 这是一个区块引用效果展示:这是一个区块引用区块引用可以嵌套,只要根据层次加上不同数量的&gt;:123&gt; 这是顶层的&gt;&gt; 这是二级引用&gt;&gt;&gt; 这是三级引用效果展示:这是顶层的这是二级引用这是三级引用引用区块内可以使用其他Markdown语法,包括标题、列表、代码区块等:1234567&gt; 列表&gt; 1. item1&gt; 2. item2&gt;&gt; 代码区块&gt;&gt; 这是一个代码区块效果展示:列表item1item2代码区块这是一个代码区块列表Markdown支持有序列表和无序列表.列表项目标记通常放在最左边,也可以缩进,最多3个空格,项目标记后面一定要接着至少一个空格或制表符.列表项目可以包含多个段落,每个项目下的段落都必须缩进四个空格或是一个制表符:123456* 这是第一段落(空行)(四个空格一个制表符)这是第二段落或* 这是第一段落(两个空格)(四个空格一个制表符)这是第二段落效果展示:这是第一段落.这是第二段落这是第一段落这是第二段落列表项目内放进引用,引用需缩进四个空格或一个制表符:12* 列表项目内放进引用(四个空格或一个制表符)&gt; 这是引用一效果展示:列表项目内放进引用这是引用一列表项目内放进代码区块,该区块需缩进两次,八个空格或两个制表符:123* 列表项目内放进代码区块(空行)(八个空格或两个制表符)这是一个代码区块效果展示:列表项目内放进代码区块这是一个代码区块 无序列表无序列表使用星号(*)、加号(+)、减号(-)作为列表标记:123* item + item - item* item + item - item* item + item - item效果展示:itemitemitem有序列表有序列表则是数字接着英文句点( 数字 + . ):1231. item2. item3. item效果展示:item1item2item3代码区块Markdown中建立代码区块,需缩进四个空格或一个制表符:123这是一个普通段落:(空行)(八个空格或两个制表符)这是一个代码区块效果展示:这是一个普通段落:这是一个代码区块 分割线Markdown中的分隔线需三个以上的星号(*)、减号(-)、底线(_).也可以在星号或减号或底线中间插入空格,不影响效果.1234****-----_______**** ***** **********效果展示:链接Markdown支持两种形式的链接语法: 行内式和参考式.链接文字都是用[]标记.行内式行内式链接:1这是一个行内式链接[链接文字](链接URL &quot;链接标题&quot;)效果展示:这是一个行内式链接链接文字参考式1234参考式链接:这是一个参考式链接[链接文字][链接辨别标签](空行)[链接辨别标签]: 链接URL &quot;链接标题&quot;效果展示:这是一个参考式链接链接文字链接内容定义形式:方括号(前面可以选择性加上至多三个空格缩进),里面输入链接文字接着一个冒号接着一个以上的空格或制表符接着链接的网址, 可以用尖括号包起来选择性接着title内容,可以是单引号、双引号或括号,可以放到下一行,也可以加一些缩进链接辨别标签不区分大小写.隐式链接标记隐式链接标记可以省略制定链接标记,此时链接标记等同于链接文字:123这是一个隐式链接标记功能[隐式链接][][隐式链接]: 链接URL &quot;隐式链接标题&quot;效果展示:这是一个隐式链接标记功能隐式链接强调Markdown中标记强调字词需使用星号(*)或底线(_),被单个*或_包围的字词会被&lt;em&gt;标签包围,用两个*或_包起来,则会被转成&lt;strong&gt;,示例:123*强调***强调**__强调__效果展示:强调强调强调如果*或_两边都有空白,它们就只会被当成普通的符号.代码Markdown标记一小段行内代码,需用反引号包起来(`),支持语法高亮,包括:Apache, Bash, CoffeeScript, C++, C#, CSS, HTTP, Java, JavaScript, JSON, Markdown, Nginx, Objective-C, Perl, PHP, Properties, Python, Ruby, Shell Session, SQL, HTML, XML等.示例:1这是一个`行内代码标记`效果展示:这是一个行内代码标记图片Markdown中插入图片,有两种样式: 行内式和参考式.行内式1![图片替代文字](图片链接URL &quot;图片描述&quot;)一个感叹号!接着方括号[],里面是图片的替代文字接着括号,里面是图片的URL,最后还可以选择性加上文字描述.参考式12![图片替代文字][图片参考标记][图片参考标记]: 图片链接URL &quot;图片描述&quot;如果需对图片进行宽高,位置调整,可以使用普通的&lt;img&gt;标签自动链接Markdown支持比较短的自动链接形式来处理网址和电子信箱,需用尖括号&lt;&gt;1&lt;网址的URL&gt;表格Markdown中支持表格,:代表对其方式,:和|之间不能有空格,否则对其会有不兼容.示例:123456789(空格)|左侧|中间|右侧||:---:|:---:|:---:||描述一|描述二|描述三|或(空格)左侧|中间|右侧:---:|:---:|:---:描述一|描述二|描述三效果展示:左侧中间右侧描述一描述二描述三小结Markdown的简单应用到这也差不多写完了,当然还有好多的高级技巧可以自行百度或Google.语法本来就很简单,虽不说十分钟包教包会,但是只要尝试着在键盘上敲两下,看看效果,学会它还是挺容易的.]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[序言]]></title>
    <url>%2F%E5%BA%8F%E8%A8%80%2F</url>
    <content type="text"><![CDATA[忙活了好多天终于把博客搭建好了.平时上班的比较忙,利用零零散散的时间看了好多关于搭建博客的文章,消化之后,发现博客的搭建并不是想象那样麻烦.以前一直有搭建博客的想法,可是每每在搭建的过程中就放弃了.原因有很多,一部分是因为从没有接触过类似博客搭建的知识,也有部分原因是也没有搭建博客的需求.为什么写做任何事都是有原因的.有搭博客写博客的想法也是一直都是存在的.在大学的那会儿,一直觉得做程序员是一类高大上的人物,所以一直对这个行业心怀憧憬.平时看些技术型文章时,一般都是来自大牛的博客,写的文章或在第三方平台,或在自己搭建的博客上.就在那个时候,心中就有了能够拥有属于自己博客的想法.于是呢,自己也是有过尝试,但是对于毫无基础的菜鸟来说,那是一种折磨.挑战新的事物的确有意思,但是突然接触到好多不懂的概念,也是一种酸爽.不过随着经历和经验的积累,也慢慢发现,学习任何新的事物,都要有个循循渐进的过程,储备的足够了自然会从量变转为质变.当然这也是后来话了.在这个阶段搭建博客想法无非就是觉得新鲜,满足一下小虚荣.结局呢,可想而知,没有足够的动力,是不能完成有些许挑战性的任务的.毕竟动物趋于安逸,生性懒惰,没有压力,哪来的奔波.人,也是动物.毕业之后,就开始步入社会,这时候就要考虑如何谋生了.所幸的是,自己从一开始就选择了前端这个行业.从一个毕业就是失业的专业跳到了一个陌生的领域,除了曾经那一丝丝的憧憬让人有所安慰外,剩下的就是彷徨不安.在自学了一段时间的前端基础后,迫于对自身学习成果的不满和外在压力,硬着头皮投递了各家招聘网站的公司.白天参加面试,晚上还要学习巩固白天面试官提的问题.人的潜力或效率有时候还真是逼出来的.在面试期间的确学到了好多东西,也大概的知道了,这类行业到底需要什么样的人.人知道的越多,也就越知道不知道的太多.那时候自己就迫切希望能够稳定下来夯实一下自己的基础.经过一段时间的东奔西跑,找到了人生的第一份正式的工作.准确的说,是被找上了.不是说我的技术有多厉害,而是这份工作压根不需要什么技术.本来我是想拒绝的,也坦言了自己的状况.毕竟我是抱着学技术的心态出来的.可是经过一轮轮的面试,我也是知道,技术的重要性,再加上人家知道情况后还是要留人,那我也就留着呗.留在公司后,就是用cms搭个网站,申请个微信公众号做微信运营什么的.那时候真的什么都不知道,各种百度啊什么的.不过最终还是让我捣鼓出来了.之后日子也就安逸了,不过每天也是提心吊胆的,生怕哪一天老板又整出什么幺蛾子.时间空出来了,搭建博客的想法也是突然又重现在脑海中.趁着机会可以建站搭博客.所以,回家后又开始忙活起如何建站.可想法是好的,现实却偏偏作对.公司一直筹划着一些活动,微信上的一些活动也要同步得做起来,我又开始了各种网站收集资源.所以,搭博客的想法又泡汤了,而且学的前端基础在这段时间也丢了不少.换了工作后,接触的到了具体实在的项目,积累的相关经验也就多了起来,一些笔记类的应用也用了起来.在开发过程中会遇到许多问题,自己也就更加主动去接受新的知识.可是虽然看到了好的文章,也收藏了起来,但是同样也犯了好多人犯的毛病.收藏夹里的记录一天天增加,却从来没有再次看过.而且,平时看的东西太过零散,无法形成自己的一套知识体系. 动力有了,搭建博客的想法也最终可以落实了.怎么去写个人平时不善言辞,尤其平时做工作汇报时,最是尴尬,忙得要死结果几句话就给总结了.这突然让我想起了学生时代写作文的时候,我是如何凑足字数的.由于自身随心随性,不喜欢约束,只要有个大的目标就行了.个人觉得,约束后的自己不再是自己.有规划更要有自己的想法.我向来不喜欢照搬别人的做法.即使权威,也是不行.模具可以快速生产出许多成品,却无法产出一件精品.写东西也是要看状态的,尤其在写总结性的东西,需要把自己的想法加进去.状态在了,有时候看待问题会更加彻底.至于偏向于技术类型的东西,那就随便了,起码在我看来,那都是套路.无非就是要记录一下问题的解决方案.写什么虽然搭博客的起因更多的来源于总结自己的工作经验.但是这个世界不只有眼前的苟且,还有诗与远方对于洒脱成性的我,看待生活时,总会时不时得冒出自己的想法和感悟.虽说不是写诗,但是凝练文采,沉淀底蕴,未尝不可.小结终于到了小结了,本以为自己言语匮乏.没想到也已经写了这么多.万一哪天灵感来了,估计会写出一部中篇小说.万事开头难,本来想是直接进入主题,写经验总结的.但唯恐坚持不下去,就写了这篇序言,以增加仪式感,希望自己能够坚持下去.]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>序言</tag>
        <tag>博客</tag>
      </tags>
  </entry>
</search>
