<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[关于MVVM模式简单代码实现]]></title>
    <url>%2F%E5%85%B3%E4%BA%8EMVVM%E6%A8%A1%E5%BC%8F%E7%AE%80%E5%8D%95%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[在写 关于MVC模式简单代码实现 的过程中，觉得最麻烦的就是操作 DOM。所以这次升级了，打算用 React。用过 React 的同学都知道，React 在更新视图时，必须要通过 setState 方式改变状态，这一过程是需要我们主动调用的。而 Vue 是通过对 data 下的变量赋值直接更新了视图，Vue 之所以这么简单，是因为采用了数据劫持的方式。所以，这次的目的就是在 React 的基础上实现和 Vue 类似的效果。实现思路就是利用高阶组件里的反向继承对包裹组件的 state 劫持。这是一个练手的小项目，没考虑那么多。为什么这么闲呢，那是因为之前写了 用Type驯化JavaScript 这篇文章，所以就捣鼓出这么一个玩意。所有代码可见github12345678910111213141516171819202122232425262728293031323334// Mvvm.tsxconst hocExtends = (WrapperComponent: ComponentClass) =&gt; ( class extends WrapperComponent &#123; constructor(props: any) &#123; super(props); &#125; render() &#123; let self = this; this.state = new Proxy(&#123; ...this.state &#125;, &#123; get: function (target, key, receiver) &#123; return Reflect.get(target, key, receiver); &#125;, set: function (target, key, value, receiver): any &#123; self.setState(&#123; [key]: value &#125;) return Reflect.set(target, key, value, receiver); &#125; &#125;) return super.render() &#125; &#125;)......filterSearchStuff(searchStuff: string): void &#123; const &#123; stuffData &#125; = this.state; let stuffItem: IStuff = stuffData.find((item: IStuff) =&gt; item.stuff === searchStuff) this.state.stuffItem = stuffItem; // this.setState(&#123; // stuffItem // &#125;) &#125;......]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>MVVM</tag>
        <tag>TypeScript</tag>
        <tag>react</tag>
        <tag>高阶组件</tag>
        <tag>反向继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用Type驯化JavaScript]]></title>
    <url>%2F%E7%94%A8Type%E9%A9%AF%E5%8C%96JavaScript%2F</url>
    <content type="text"><![CDATA[TypeScript 具有类型系统，且是 JavaScript 的超集。它可以编译成普通的 JavaScript 代码。TypeScript 支持任意浏览器，任意环境，任意系统并且是开源的。作为弱类型、动态型语言，JavaScript 就像未驯化的野马一样。每个人都能上去坐两下，但是真正能够驾驭的只能是个中好手。近几年，前端经历了快速的发展已经不再是以前随便玩玩的小玩意了。面对越来越大型、越来越持久的项目来说，这种宽松的方式反而成了阻碍。东西做大了，随之而来的就是各种规矩规矩是从经验中总结，同时也是为了朝更好的方向发展，就比如编程里的设计原则和设计模式。「Man maketh manners」，记得王牌特工里，主角们在教育别人的时候总喜欢说这么一句话，「不知礼，无以立也」。在 TypeScript 里，「礼」就是 Type，Type 就是规矩。Typescript 通过类型注解提供编译时的静态类型检查，提前发现错误，同时也提高了代码的可读性和可维护性。TypeScript 里的类型注解是一种轻量级的为函数或变量添加约束的方式在 JavaScript 里，变量用于在特定时间存储特定值，其值及数据类型可以在脚本的生命周期内改变。而在 TypeScript 中，标识符（变量、函数、类、属性的名字，或者函数参数）在其定义时就指定了类型（或类型推论出）。在编译阶段，若出现了期望之外的类型，TypeScript 将会提示抛错（虽然有时候并不会影响程序的正常运行）。在 TypeScript 中，通过 : 类型 的方式为标识符添加类型注解。1234567891011121314151617let isDone: boolean = false; // boolean；let decLiteral: number = 6; // number；let name: string = "bob"; // string；let list: number[] = [1, 2, 3]; // Array&lt;number&gt;;let list: Array&lt;number&gt; = [1, 2, 3]; // Array&lt;number&gt;;let x: [string, number]; // tuple;enum Color &#123;Red, Green, Blue&#125; // enum;let notSure: any = 4; // any;function warnUser(): void &#123; // void; console.log("This is my warning message");&#125;let u: undefined = undefined; // undefined;let n: null = null; // null;function error(message: string): never &#123; // never; throw new Error(message);&#125;let obj: object = &#123;&#125;; // object在 TypeScript 中，数组（Array）是合并了相同类型的对象，而元组（tuple）合并了不同类型的对象。（Array&lt;any&gt;,也可以合并不同类型的数据）类型注解中的类型就是以上的那些类型么？TypeScript 的核心原则之一是对值所具有的结构进行类型检查，它有时被称做「鸭式辨型法」或「结构性子类型化」。上面的只是基础类型，它们是填充结构的基本单位而已。在 TypeScript 里，类型不应该还停留在 JavaScript 数据类型的层面上，还应包括基础类型的组合结构化。1234567891011let str: 'Hello'; // 字符串字面量类型；str = 'Hi' // error；let something: 'Hello' | 1; // 联合类型；something = 1 // ok；let obj: &#123;name: string, age: number&#125;; // 对象字面量obj = &#123; name: "夜曉宸", age: 18,&#125;换句话说，在定义标识符的时候，用一个类型模板来描述标识符的结构和内部类型组成。即类型模板就是标识符期望的样子。代码是给人看的，顺便是给机器运行的都说好的代码就该这样。但是在 TypeScript 里，这两句话可以颠倒下顺序。代码是给机器运行的，顺便是给人看的。在谈到 TypeScript 的好处时，有一条很重要，增强了编译器和 IDE 的功能，包括代码补全、接口提示、跳转到定义、重构等。而这些也得益于标识符的类型的精确划分或表述，所以想写好 Typescript 代码，就应该精确描述标识符的类型，而不是随处安放的 any。表述复杂结构最常用的方式 ———— 接口接口是 JavaScript 中没有的东西，是一个非常灵活的概念，可以抽象行为，也可以描述「对象的形状」。对于需要复用的结构类型，就可以使用接口的方式，而不是对象字面量内联式注解。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566interface Iperson &#123; // 对象 name: string, age: number, sayHi(): void,&#125;let obj: Iperson = &#123; name: "夜曉宸", age: 18, sayHi: ()=&gt; &#123;&#125;&#125;/* ——————人工分割线—————— */interface Iperson &#123; // 函数类型 (name: string, age: number): string&#125;let person: Iperson = (name, age) =&gt; &#123; return `$&#123;name&#125;,$&#123;age&#125;`&#125;person('夜曉宸', 18);/* ——————人工分割线—————— */interface Iperson &#123; // 构造函数 new (name: string, age: number)&#125;let person: Iperson = class Person &#123; name: string; age: number; constructor(name, age) &#123; this.name = name; this.age = age; &#125;&#125;new person('夜曉宸', 18);/* ——————人工分割线—————— */interface Iperson &#123; // 类实现接口 name: string, age: number,&#125;class Person implements Iperson&#123; name = '夜曉宸' age = 18&#125;new Person()/* ——————人工分割线—————— */interface Iperson &#123; // 混合类型 (name, age): string, age: number,&#125;function Person(): Iperson &#123; let me = &lt;Iperson&gt;function (name, age): string &#123; return `$&#123;name&#125;, $&#123;age&#125;` &#125; me.age = 18; return me;&#125;let person = Person();person('夜曉宸', 18)person.age以上是接口在对象、普通函数、构造函数、类上的表现。对于接口的属性，还可以做到精确控制，如可选属性、任意属性、只读属性等。最后，接口间可以继承，接口还可以继承类。当接口继承类时，它会继承类的成员但不包括其实现，但是若继承了拥有私有或受保护的成员类时，这个接口只能由这个类或其子类来实现了，这个和类的访问修饰符的特点有关系。说完接口，就要说说类了，因为它们有多相似的地方，比如充当对象的类型模板，继承成员等。类到底是什么呢？ES6 引入了 Class（类）这个概念，通过 class 关键字，可以定义类, Class 实质上是 JavaScript 现有的基于原型的继承的语法糖. Class 可以通过extends关键字实现继承。TypeScript 除了实现了所有 ES6 中的类的功能以外，还添加了一些新的用法。12345678910111213141516171819class Person &#123; static age: number = 18; constructor(public name: string, public age: number) &#123; &#125; sayHi(name: string): string&#123; return `Hi,$&#123;name&#125;` &#125;&#125;/* —————— 人工分割线 —————— */var Person = /** @class */ (function () &#123; function Person(name, age) &#123; this.name = name; this.age = age; &#125; Person.prototype.sayHi = function (name) &#123; return "Hi," + name; &#125;; Person.age = 18; return Person;&#125;());TypeScript 编译后，可以看出来，类其实就是一个函数而已。在 ES6 之前，通过构造函数的方式 new 出对象，造出的对象拥有和共享了构造函数内部绑定的属性方法及原型上的属性方法。TypeScript 里的接口描述的类类型就是类的实例部分应该遵循的类型模板。作为类的静态部分 ———— 构造函数，函数也应该有自己的属性特征。12345678910111213141516171819interface static_person &#123; age: number, new (name: string, age: number);&#125;interface instance_person &#123; name: string, age: number, say(name: string): string&#125;let person: static_person = class Person implements instance_person&#123; static age: number = 18; constructor(public name: string, public age: number) &#123; &#125; say(name) &#123; return `Hi,$&#123;name&#125;` &#125;&#125;new person('夜曉宸',18)由以上代码可以看出，类的静态部分和动态部分都有各自的类型模板。若是想要将类自身作为类型模板又该如何做呢？最简单的方法就是 typeof 类 的方式。123456789101112131415class Person &#123; static age: number = 18; constructor(public name: string, public age: number) &#123;&#125; say(name) &#123; return `Hi,$&#123;name&#125;` &#125;&#125;class Man &#123; static age: number; constructor(public name: string, public age: number) &#123;&#125; public sex = 'man'; say(name)&#123;return `Hi, $&#123;this.sex&#125;,$&#123;name&#125;`&#125;&#125;let man: typeof Person = Man;new man('夜曉宸', 18)类静态部分、类实例部分和类自身，它们都有自己需要遵循的类型模板。知道了其中的区别，也就能更好得理解类作为接口使用、接口继承类等用法了。12345678910111213class Person &#123; name: string; age: number;&#125;interface Man extends Person &#123; sex: 'man'&#125;let man: Man = &#123; name: '夜曉宸', age: 18, sex: 'man'&#125;除了结构上的约束，类也通过访问修饰符对其成员做了约束，包括 public，private，protected，readonly等。1234567891011121314class Person &#123; private name: string; protected age: number;&#125;interface SayPerson extends Person &#123; sayHi(): string&#125;class Human extends Person implements SayPerson &#123; sayHi() &#123; return `Hi, $&#123;this.age&#125;` &#125;&#125;知道了访问修饰符的特点，也就明白之前说过的「当接口继承类时，它会继承类的成员但不包括其实现，但是若继承了拥有私有或受保护的成员类时，这个接口只能由这个类或其子类来实现了」。如果一个标识符的类型不确定，该如何？对于一个内部逻辑相差不大，入參类型不同的函数来说，没必要因为参数类型不同而重复大部分代码，这时就需要一个类型变量来代替。1234567891011121314151617181920212223242526272829/* 范型函数 */class Person &#123; className = 'person'&#125;class Human &#123; classname = 'human'&#125;function create&lt;T&gt;(Class: new () =&gt; T) : T&#123; return new Class();&#125;create(Person).className/* 范型接口 */interface Creat&lt;T&gt;&#123; (Class: new () =&gt; T):T&#125;class Person &#123; className = 'person'&#125;class Human &#123; classname = 'human'&#125;function create&lt;T&gt;(Class: new () =&gt; T) : T&#123; return new Class();&#125;let person: Creat&lt;Person&gt; = create;person(Person) // OKperson(Human) // Error注意了，类型变量表示的是类型，而不是值。类型变量里塞的可能是任意一个类型，但根据场景，我们最好能够更加精确的描述标识符的类型。应了上面的一句话，「想写好 Typescript 代码，就应该精确描述标识符的类型，而不是随处安放的 any」。所以对于泛型，我们也可以做些约束，即，泛型约束。12345678910111213141516class Person &#123; name: string; age: number;&#125;interface Man extends Person &#123; sex: 'man'&#125;function getProperty&lt;T, K extends keyof T&gt;(obj: T, key: K): any &#123; return obj[key]&#125;let man: Man = &#123; name: '夜曉宸', age: 18, sex: 'man'&#125;getProperty(man, 'sex')用类型变量来注释标识符的类型有时会觉得还是不够精确。知道标识符的可能类型，然后组合起来123456789101112131415161718192021222324252627282930313233class Man &#123; name: string; age: number; study():string &#123;return ''&#125;&#125;class Women &#123; name: string; age: number; sing():string&#123;return ''&#125; &#125;function instance(Class: Man | Women) &#123; if ((&lt;Man&gt;Class).study) &#123; return (&lt;Man&gt;Class).study() &#125; else &#123; return (&lt;Women&gt;Class).sing() &#125;&#125;let man:Man = &#123; name: '夜曉宸', age: 18, study() &#123; return '我爱学习'; &#125;&#125;let women: Women = &#123; name: 'godness', age: 17, sing() &#123; return '我爱唱歌' &#125;&#125;instance(man) // 我爱学习instance(women) // 我爱唱歌有交叉类型、联合类型等，而类型命名则是更灵活的类型组织方式。123456789101112// 官网🌰type Name = string;type NameResolver = () =&gt; string;type NameOrResolver = Name | NameResolver;function getName(n: NameOrResolver): Name &#123; if (typeof n === 'string') &#123; return n; &#125; else &#123; return n(); &#125;&#125;类型多了之后，有时候需要对某一类型做特别处理，于是有类型断言 （&lt;类型&gt;） 和类型守卫（typeof, instanceof, in等）。还可以通过条件判断来选择哪种类型。1234// 官网🌰declare function f&lt;T extends boolean&gt;(x: T): T extends true ? string : number;// Type is 'string | numberlet x = f(Math.random() &lt; 0.5)当然了，以上代码好多的标识符是没有必要添加类型注解的。类型推断，即，类型是在哪里如何被推断的类型注解也不是越多越好，即使有些地方你不添加类型注解，TypeScript 也会通过上下文归类等方式找到最佳通用类型。]]></content>
      <categories>
        <category>这个想法不一定对</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随手记（一）]]></title>
    <url>%2F%E9%9A%8F%E6%89%8B%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[NET::ERR_CERT_DATE_INVALID描述：开发环境，接口请求转 https，Chrome 开发者工具控制台报错 ## NET::ERR_CERT_DATE_INVALID。解决方案：Chrome HSTS异常导致无法访问HTTPS网页涉及点：List of Chrome URLs、hstsChrome插件本地导出描述：由于某些原因，Chrome 应用商店无法浏览。对已下载的 Chrome 插件导出安装。解决方案：地址栏输入 chrome://extensions/, 开启开发者模式，打开待导出插件的详细信息，记录扩展程序 ID。地址栏输入 chrome://version/, 记录个人资料路径。扩展程序路径即为：个人资料路径 + ‘Extensions’ + 扩张程序 ID。终端进入拓展程序路径目录，目录下还有扩展程序的对应版本目录，记录扩展程序版本目录。回到扩展程序详情页，点击打包程序，输入扩展程序版本目录并点击打包扩展程序。进入扩展程序路径，拷贝 crx 格式文件即可。（ prm 为密钥文件）涉及点：无]]></content>
      <categories>
        <category>天坑也填坑</category>
      </categories>
      <tags>
        <tag>随手记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读懂UML类图]]></title>
    <url>%2F%E8%AF%BB%E6%87%82UML%E7%B1%BB%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[类的描述在面向对象编程，类是一种面向对象计算机编程语言的构造，是创建对象的蓝图，描述了所创建的对象共同的属性和方法。类的更严格的定义是由某种特定的元数据所组成的内聚的包。它描述了一些对象的行为规则，而这些对象就被称为该类的实例。类有接口和结构。接口描述了如何通过方法与类及其实例互操作，而结构描述了一个实例中数据如何划分为多个属性。类是与某个层的对象的最具体的类型。类还可以有运行时表示形式（元对象），它为操作与类相关的元数据提供了运行时支持。类的UML表示类图是面向对象系统建模中最常用和最重要的图，主要是用来显示系统中的类、接口以及它们之间的静态结构和关系的一种静态模型。类图描述一类的属性和操作，也对系统的约束。类图显示集合的类，接口，关联，协作和约束，它也被称为作为结构图。在类的UML图中，使用长方形描述一个类的主要构成，长方形垂直地分为三层，分别放置类的名称、属性和方法。第一部分是类名。第二部分是类的属性：即类的成员变量，类的性质。表示方式为：可见性 名称：类型 [= 缺省值]可见性表示该属性对于类外的元素是否可见，包括共有（public）、私有（private）和受保护（protected），在类图中分别表示为 +、- 和 #。类型表示属性的数据类型。缺省值表示属性的初始值，可选。第三部分是类的方法：即类的成员方法，操作或行为。表示方式为：可见性 名称（参数列表）[: 返回值]。可见性同类的属性。参数列表表示方法的参数，多个参数之间用逗号隔开。返回类型表示方法返回值类型，可选。类图常见关系在UML类图中，常见的有以下几种关系:泛化（Generalization）, 实现（Realization）,组合(Composition)，聚合（Aggregation）,关联（Association）,依赖(Dependency)。泛化（Generalization）：是父类与子类之间的关系，描述的是 is a king of(is a)的关系。表现为继承非抽象类。实现（Realization）：是类与接口的关系，表示为类是接口所有特征和行为的实现。表现为继承抽象类。组合(Composition)：是类之间整体与部分的关系。在组合关系中，整体对象负责成员对象的创建以及生命周期，即当整体对象被销毁时成员对象也会不复存在。聚合（Aggregation）：是类之间整体与部分的关系。在聚合关系中，成员对象是整体对象的一部分，但是成员对象可以脱离整体对象独立存在。关联（Association）：是类之间的结构关系，用于表示一类对象与另一类对象之间有联系。关联关系默认是双向的，表示相互知道，也可以单向关联、自关联、多重性关联。依赖(Dependency)：是描述一个对象在运行期间会用到另一个对象的关系（使用关系），通常在运行期间产生，并且随着运行时的变化，依赖关系也可能发生变换。各种关系的强弱顺序：泛化 = 实现 &gt; 组合 &gt; 聚合 &gt; 关联 &gt; 依赖]]></content>
      <categories>
        <category>写点啥</category>
      </categories>
      <tags>
        <tag>UML类图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DIP、IoC、DI、JS]]></title>
    <url>%2FDIP%E3%80%81IoC%E3%80%81DI%E3%80%81JS%2F</url>
    <content type="text"><![CDATA[在这个标题中，除了 JS 是乱入之外，其它的几个词汇都是存在一个共同点的，那就是依赖。那么，依赖是什么呢？比如，现在我正在写这篇博客文，但是我得在电脑上编辑，电脑便是我完成这件事的依赖。而在代码中，最直观的体现是模块之间的依赖。如某个模块依赖另外一个模块，那么另外的那个模块就是该模块的依赖。其实在上篇博客文章《JaVaScript中的模块》中，我们也手写了一个模块依赖管理器。依赖这个理解起来很简单，但这不代表可以随意的依赖。在写模块的时候，讲究个高内聚低耦合，以提高模块的可拓展性和可维护性。模块依赖了谁，怎么去依赖，都关乎了最终模块的好与坏。还好在编程界有着提高代码质量的金科玉律，我们可以用理论来指导实践，写出更好的代码。依赖反转原则依赖反转原则（Dependency inversion principle，DIP），是一种特定的解耦形式，使得高层次的模块不依赖于低层次的模块的实现细节，依赖关系被颠倒（反转），从而使得低层次模块依赖于高层次模块的需求抽象。———— 维基百科该原则规定：高层次的模块不应该依赖与低层次的模块，两者都应该依赖于抽象接口。抽象接口不应该依赖于具体实现。而具体实现则应该依赖于抽象接口。现在用一个例子来解释一波。1234567891011121314151617181920// Ajax.jsclass Ajax &#123; get() &#123; return this.constructor.name; &#125;&#125;export default Ajax;// main.jsimport Ajax from './Ajax';class Main &#123; constructor() &#123; this.render() &#125; render() &#123; let content = (new Ajax()).get(); console.log('content from', content); &#125;&#125;new Main();刚开始的时候，我们基于 XMLHttpRequest 对象，封装了 Ajax 用于请求数据。后来 fetch 出来了，我们打算跟上时代的脚步，封装 fetch 以取代 Ajax。1234567891011121314151617181920// Fetch.jsclass Fetch &#123; fetch() &#123; return this.constructor.name; &#125;&#125;export default Fetch;// main.jsimport Fetch from './Fetch';class Main &#123; constructor() &#123; this.render(); &#125; render() &#123; let content = (new Fetch()).fetch(); console.log('content from', content); &#125;&#125;new Main();从以上可以看出来，整个替代过程很麻烦，我们需要找出封装请求模块（Ajax、Fetch）的所有引用，然后替换掉。又由于 Ajax、Fetch 的方法命名也是不同，所以也需要对应地做更改。这就是传统的处理依赖关系的方式。在这里 Main 是高层次模块，Ajax、Fetch 是低层次模块。依赖关系创建于高层次模块，且高层次模块直接依赖低层次模块，这种依赖关系限制了高层次模块的复用性。依赖反转原则则颠倒这种依赖关系，并以上面提到的两个规定作为指导思想。12345678910111213141516171819202122232425// Service.jsclass Service &#123; request()&#123; throw `$&#123;this.constructor.name&#125; 没有实现 request 方法！` &#125;&#125;class Ajax extends Service &#123; request()&#123; return this.constructor.name; &#125;&#125;export default Ajax;// Main.jsimport Service from './Service.js';class Main &#123; constructor() &#123; this.render(); &#125; render() &#123; let content = (new Service).request(); console.log('content from', content); &#125;&#125;new Main();在这里我们把共同依赖的 Service 作为抽象接口，它就是高层次模块与低层次模块需要共同遵守的契约。在高层次模块中，它会默认 Service 会有 request 方法用来请求数据。在低层次模块中，它会遵从 Service 复写应该存在的方法。这在《在JavaScript中尝试组合模式》中，无论分支对象还是叶对象都实现 expense() 方法的道理差不多。即使后来需要封装 axios 取代 fetch，我们也只需要在 Service.js 中修改即可。再次回顾下传统的依赖关系。依赖关系创建于高层次模块，且高层次模块直接依赖低层次模块。经过以上的折腾，我们充其量只是解决了高层次模块直接依赖低层次模块的问题。那么依赖关系创建于高层次模块的问题呢？控制反转如果说依赖反转原则告诉我们该依赖谁，那么控制反转则告诉们谁应该来控制依赖。像上面的 Main 模块，它依赖 Service 模块。为了获得 Service 实例的引用，Main 在内部靠自身 new 出了一个 Service 实例。这样明显地引用其它模块，无异加大了模块间的耦合。控制反转（Inversion of Control，IoC），通过控制反转，对象在被创建的时候，有一个控制系统内所有对象的外界实体，将其所依赖的对象的引用传递给它。可以说，依赖被注入到对象中。———— 维基百科这些话的意思就是将依赖对象的创建和绑定转移到被依赖对象类的外部来实现。实现控制反转最常见的方式是依赖注入，还有一种方式依赖查找。依赖注入依赖注入（Dependency Injection，DI），在软件工程中，依赖注入是种实现控制反转用于解决依赖性设计模式。一个依赖关系指的是可被利用的一种对象（即服务提供端）。依赖注入是将所依赖的传递给将使用的从属对象（即客户端）。该服务将会变成客户端的状态的一部分。传递服务给客户端，而非允许客户端来建立或寻找服务，是本设计模式的基本要求。没看懂？没关系。这句话讲的是，把过程放在外面，将结果带入内部。在《JaVaScript中的模块》中，我们已经用到过依赖注入，就是对于依赖模块的模块，则把依赖作为参数使用。所以我们再次改造下，123456789101112131415161718192021222324252627282930// Service.jsclass Service &#123; request() &#123; throw `$&#123;this.constructor.name&#125; 没有实现 request 方法！` &#125;&#125;class Ajax extends Service &#123; request() &#123; return this.constructor.name; &#125;&#125;export default Ajax;// Main.jsclass Main &#123; constructor(options) &#123; this.Service = options.Service; this.render(); &#125; render() &#123; let content = this.Service.request(); console.log('content from', content); &#125;&#125;export default Main;// index.jsimport Service from './Service.js';import Main from './Main.js';new Main(&#123; Service: new Service()&#125;)在 Main 模块中, Service 的实例化是在外部完成，并在 index.js 中注入。相比上一次，改动后的代码并没有看出带来多大的好处。如果我们再增加一个模块呢？123456789class Router &#123; constructor() &#123; this.init(); &#125; init() &#123; console.log('Router::init') &#125;&#125;export default Router;12345678# Main.js+ this.Service = options.Router;# index.js+ import Router from './Router.js' new Main(&#123;+ Router: new Service() &#125;)若是内部实例化就不好处理了。可换成依赖注入后，这个问题就很好解决了。1234567891011121314151617181920212223242526272829303132// utils.jsexport const toOptions = params =&gt; Object.entries(params).reduce((accumulator, currentValue) =&gt; &#123; accumulator[currentValue[0]] = new currentValue[1]() return accumulator; &#125;, &#123;&#125;);// Main.jsclass Main &#123; constructor(options) &#123; Object.assign(this, options); this.render(); &#125; render() &#123; let content = this.Service.request(); console.log('content from', content); &#125;&#125;export default Main;// index.jsimport Service from './Service.js';import Router from './Router.js';import Main from './Main.js';import &#123; toOptions &#125; from './utils.js'/** * toOptions 转换成参数形式 * @params &#123;Object&#125; 类 * @return &#123;Object&#125; &#123;Service: Service实例, Router: Router实例&#125; */const options = toOptions(&#123;Service, Router&#125;);new Main(options);因为依赖注入把依赖的引用从外部引入，所以这里使用 Object.assign(this, options) 方式，把依赖全部加到了 this 上。即使再增加模块，也只需要在 index.js 中引入即可。到了这里，DIP、IoC、DI 的概念应该有个清晰的认识了。然后我们再结合实际，加个功能再次巩固一下。作为一功能个独立的模块，一般都有个初始化的过程。现在我们要做的是遵守一个初始化的约定，定义一个抽象接口，1234567891011121314151617181920212223242526// Interface.jsexport class Service &#123; request() &#123; throw `$&#123;this.constructor.name&#125; 没有实现 request 方法！` &#125;&#125;export class Init &#123; init() &#123; throw `$&#123;this.constructor.name&#125; 没有实现 init 方法！` &#125;&#125;// Service.jsimport &#123; Init, Service &#125; from './Interface.js';import &#123; mix &#125; from './utils.js'class Ajax extends mix(Init, Service) &#123; constructor() &#123; super(); &#125; init() &#123; console.log('Service::init') &#125; request() &#123; return this.constructor.name; &#125;&#125;export default Ajax;Main、Service、Router 都依赖 Init 接口（在这里就是一种协定），Service 模块比较特殊，所以做了 Mixin 处理。要做到统一初始化，Main 还需要做些事。12345678910111213141516171819// Main.jsimport &#123; Init &#125; from './Interface.js'class Main extends Init &#123; constructor(options) &#123; super(); Object.assign(this, options); this.options = options; this.render(); &#125; init() &#123; (Object.values(this.options)).map(item =&gt; item.init()); console.log('Main::init'); &#125; render() &#123; let content = this.Service.request(); console.log('content from', content); &#125;&#125;export default Main;至此，结束123456789101112131415161718192021222324// index.jsimport Service from './Service.js';import Router from './Router.js';import Main from './Main.js';import &#123; toOptions &#125; from './utils.js'/** * toOptions * 转换成参数形式 * @params &#123;Object&#125; 类 * @return &#123;Object&#125; * &#123; * Service: Service实例, * Router: Router实例 * &#125; */const options = toOptions(&#123; Service, Router &#125;);(new Main(options)).init();// content from Ajax// Service::init// Router::init// Main::init（以上所有示例可见GitHub）]]></content>
      <categories>
        <category>这个想法不一定对</category>
      </categories>
      <tags>
        <tag>DIP</tag>
        <tag>Ioc</tag>
        <tag>DI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JaVaScript中的模块]]></title>
    <url>%2FJaVaScript%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[模块在 JavaScript 中，模块只不过是基于函数某些特性的代码组织方式。在《你不知道的 JavaScript》中，给出了模块模式因具备的两个必要条件：必须有外部的封闭函数，该函数必须至少被调用一次（每次调用都会创建一个新的模块实例）。封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。从中我们可以看到一个比较重要的一点，从函数调用所返回的只有数据属性而没有闭包函数的对象并不是真正的模块。你看👀，理解闭包的重要性再次体现出来了。从以上要求的两点来看，只要满足相应的条件，我们很容易写出一个模块。123456789101112131415161718192021const userModule = ((name = 'module') =&gt; &#123; let id = 1,moduleName = name; const sayName = () =&gt; &#123; console.log('moduleName: %s', moduleName); &#125;; const sayId = () =&gt; &#123; console.log('id: %s', id); &#125;; const changeName = value =&gt; &#123; moduleName = value; &#125;; const changePublicAPI = () =&gt; &#123; publicAPI.sayIdentification = sayId &#125;; const publicAPI = &#123; sayIdentification: sayName, changeName, changePublicAPI, &#125; return publicAPI;&#125;)();以上在满足两个必要的基础上转换成了 IIFE（立即执行函数表达式）。同时可以看出，基于函数的模块可以在运行时通过内部保留着公共 API 对象的引用，从而对模块实例进行修改。模块机制模块的出现也是为了能够提高代码的复用率，方便代码管理。复用模块，自然会出现模块依赖的问题，所以说我们需要一个管理模块依赖的模块。1234567891011121314151617181920212223242526272829303132333435const moduleManage = (() =&gt; &#123; let modules = &#123;&#125;; const define = (name, deps, module) =&gt; &#123; deps = deps.map(item =&gt; modules[item]) modules[name] = module(...deps); &#125;; const exports = (name) =&gt; &#123; return modules[name]; &#125; return &#123; define, exports, &#125;&#125;)();moduleManage.define('a', [], () =&gt; &#123; const sayName = name =&gt; &#123; console.log('name: %s', name); &#125;; return &#123; sayName, &#125;&#125;);moduleManage.define('b', ['a'], (a) =&gt; &#123; let name = 'b'; const sayName = () =&gt; &#123; a.sayName(name) &#125;; return &#123; sayName, &#125;&#125;);var b = moduleManage.exports('b');b.sayName();模块依赖管理器也依然是个模块，这里的实现其实很简单。modules[name] = module(...deps)，使用 modules 缓存各个模块，对于依赖模块的模块，则把依赖作为参数使用。规范CommonJS 规范服务于服务端，同步阻塞，在写法风格上是依赖就近。但是在浏览器上，CommonJS 就不好使了，浏览器需要从服务器请求数据，下载完成后才会有下一步的执行。如果采用 CommonJS 的同步方式，指不定什么时候文件才会下载完成。为了推广到浏览器上，AMD 规范采用异步方式加载模块。先异步加载模块，加载完成后就可以在回调中使用依赖模块了。这样就保证了在使用依赖时，依赖已经加载完成。AMD 规范是早早地下载，早早地执行，在回调里 require 的是依赖的引用。在写法风格上是依赖前置，这种风格已经不同于 CommonJS 了。还有，这里早早地执行会带来一个问题，如果存在某个依赖某些条件不成立，导致没有用上。那么，这里的早早地执行岂不是多此一举了？CMD 规范是 sea.js 推崇的规范，它采用的也是异步加载模块的方式，只是在依赖模块的执行时机上有所不同。在写法风格上，又回归到 CommonJS，依赖就近。sea.js 是早早地下载，延迟执行。到了 ES6，终于从语法上支持模块化了，ES6 模块是编译时加载，使得在编译时就能确定模块的依赖关系，而且在将来服务器和浏览器都会支持 ES6 的模块化方案。]]></content>
      <categories>
        <category>这个想法不一定对</category>
      </categories>
      <tags>
        <tag>模块化</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异步的JavaScript（生成器篇）]]></title>
    <url>%2F%E5%BC%82%E6%AD%A5%E7%9A%84JavaScript%EF%BC%88%E7%BB%88%E7%AF%87%EF%BC%89%2F</url>
    <content type="text"><![CDATA[回顾所谓的异步，就是程序的一部分现在进行，而另一部分则在将来运行。异步处理的重点就是如何处理将来运行的那一部分。回调是 JavaScript 中最基本的异步模式，就是事先约定好将来要做的事然后回头调用。简单直接，但也存在不信任、调用嵌套过深等问题。对于编写代码、维护代码的我们而言，人类的大脑还是习惯于线性的处理方式。基于回调的异步模式所存在的问题促使着我们寻求一种机制来保证回调的可信任，同时能更好的表达异步。这时候 Promise 出现了，Promise 的出现，并非要取代回调。而是把回调转交给了一个位于我们和其它工具之间的可信任的中介机制。Promise 链也提供（尽管并不完美）以顺序的方式表达异步流的一个更好的方法，这有助于我们的大脑更好地计划和维护异步 JavaScript 代码。生成器Promise 虽然有序、可靠地管理回调，但是我们还是希望如同步般表达异步。我们已经知道生成器是作为生产迭代器的工厂函数，同时我们还要知道生成器也是一个消息传递系统。为什么是生成器在生成器出现之前，程序代码一旦执行，就没有停下来的时候，直到程序结束🔚。然而在生成器里代码是可以暂停的，而且还可以和生成器之外通信☎️，通信结束后又可以恢复执行。回想一下之前的异步流程控制，我们一直在想方设法使得异步任务能够同步表达。现在，我们可以借助生成器来实现这一想法💡。了解了生成器的特性之后，我们就应该知道，当生成器在执行一个异步任务时，完全可以把异步任务放在生成器外部执行，待异步任务执行结束后再返回🔙生成器恢复执行。要知道，生成器暂停的只是内部的状态，程序的其余部分还是正常运行的。这样的话，生成器内部的所有代码看起来都是同步表达了。同时我们也要注意到，生成器不过是一种新🆕的表达方式，和异步还是同步没有半毛钱💰关系。既然没有关系，那在异步模式选择上就更无所谓了。考虑到异步系列文章是渐进式的，所以我们就用 Promise + 生成器 模式来表达异步。生成器与Promise的结合在异步流程控制方面，生成器是由两部分组成的。一部分是生成器内部代码以同步的方式表达任务，另一部分是由生成器生成的迭代器处理异步。12345678910111213141516171819202122232425262728293031323334const async = n =&gt; &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; resolve(`第$&#123;n&#125;个异步任务`) &#125;, 0); &#125;)&#125;;const generator = function *generator()&#123; const response_1 = yield async(1); const response_2 = yield async(2); const response_3 = yield async(3); console.log('response_1: %s;response_2: %s;response_3: %s;',response_1,response_2,response_3);&#125;;const gen = generator();const gen_1 = generator();console.log('gen_next_1: %s; gen_next_2: %s; gen_next_3: %s;', gen_1.next().value, gen_1.next().value, gen_1.next().value);gen.next().value.then(yield_1 =&gt; &#123; console.log('yield_1: %s;', yield_1); return gen.next(yield_1).value.then(yield_2 =&gt; &#123; console.log('yield_2: %s;', yield_2) return gen.next(yield_2).value.then(yield_3 =&gt; &#123; console.log('yield_3: %s', yield_3); return gen.next(yield_3); &#125;) &#125;)&#125;);// gen_next_1: [object Promise]; gen_next_2: [object Promise]; gen_next_3: [object Promise];// yield_1: 第1个异步任务;// yield_2: 第2个异步任务;// yield_3: 第3个异步任务// response_1: 第1个异步任务;response_2: 第2个异步任务;response_3: 第3个异步任务;如果只看 generator 函数这块，函数内部的写法和同步无异。gen 和 gen_1 都是同一生成器的实例。如前文所述，理解这块代码还是要从两方面入手 ———— 迭代和消息传递。迭代属性在此不再赘述，现在重点是消息传递的属性。在生成器中，生成器函数被调用后并未立即执行，而是构造了一个迭代器。而生成器正是靠着 yield/next 来完成生成器内外部的双向通信。在生成器内部，yield 是用来暂停（完全保持其状态）和向外部传递数据的关键字/表达式（初始时函数也是处于未执行状态）。在生成器外部，next 具有恢复生成器和向生成器内部传递数据的能力。混沌初始（gen 造出来了），盘古开天辟地（第一个 next() 执行），天地初成，继女娲造人后，一切欣欣向荣。共工和祝融两个调皮蛋撞坏了不周山，给女娲出了一个难题（yield），华夏史驻此不前。女娲向上天求助（yield async(1)），上天回应了并送来了五彩石（yield_1）,女娲顺利补天，华夏史再次启程（next(yield_1)）。然而好景不长，华夏部落经常受到蚩尤部落骚扰侵犯，蚩尤的存在再次阻碍了华夏史的前行（yield）。黄帝无奈向其师求助（yield async(2)），九天玄女授其兵法（yield_2）,黄帝顺利杀蚩尤，华夏史再次启程（next(yield_2)）。然而好景不长，中原地带洪水泛滥，华夏史再次受阻（yield）。夏禹无奈向太上老君求助（yield async(3)）,太上老君赠其神铁（yield_3）,夏禹顺利治水，华夏史再次启程（next (yield_3)）。实在编不下去了，还好结束了。😓 代码运行过程大抵如此。生成器内部生成一个数据，然后抛给迭代器消费，迭代器又把执行结果甩给了生成器。就是这么简单，别想的太复杂就行。所谓的消息双向传递，指的不仅仅是正常情况下生成器内外部的数据。对于异常错误，生成器内外部也可以双向捕捉。因为生成器内部的暂停，是保留了其上下文的，所以 try...catch 又可以一展身手了。生成器自执行 &amp; async/awaitPromise + 生成器 来表达异步算是实现了，然而我们也应该注意到在用迭代器控制生成器的那部分太过繁琐。如果能够封装下就好了， 如下：12345678910111213141516171819202122232425262728293031323334const generator_wrap = function (generator) &#123; const args = [...arguments].slice(1); const gen = generator.apply(this, args); return new Promise((resolve, reject) =&gt; &#123; const handleNext = function handleNext(yield)&#123; let next; try &#123; next = gen.next(yield); &#125; catch (error) &#123; reject(error) &#125; if (next.done) &#123; resolve(next.value) &#125; else &#123; return Promise.resolve(next.value).then(yield =&gt; &#123; handleNext(yield); &#125;, error =&gt; &#123; gen.throw(error); &#125;) &#125; &#125;; handleNext(); &#125;)&#125;;// ———————————— 手动分割线 ————————————const generator = function *generator()&#123; const response_1 = yield async(1); const response_2 = yield async(2); const response_3 = yield async(3); console.log('response_1: %s;response_2: %s;response_3: %s;',response_1,response_2,response_3);&#125;;generator_wrap(generator);// response_1: 第1个异步任务;response_2: 第2个异步任务;response_3: 第3个异步任务;不看 generator_wrap 函数，只看分割线以下的部分。至此，异步流程的表达越来越接近理想中的模样了。但 generator_wrap 函数还是需要自己手动封装，不过现在不用啦😄ES2017 推出了 async/await ，我们不用再自己去管理生成器，简单、强大、方便的 async/await 为我们处理了一切。123456789const awati_async = async () =&gt; &#123; const response_1 = await async(1); const response_2 = await async(2); const response_3 = await async(3); console.log('response_1: %s;response_2: %s;response_3: %s;', response_1, response_2, response_3);&#125;;awati_async();// response_1: 第1个异步任务;response_2: 第2个异步任务;response_3: 第3个异步任务;至此，关于 JavaScript 的异步表达暂时告一段落了👋。]]></content>
      <categories>
        <category>很难么</category>
      </categories>
      <tags>
        <tag>异步</tag>
        <tag>生成器</tag>
        <tag>async/await</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从迭代器模式到迭代协议]]></title>
    <url>%2F%E4%BB%8E%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%88%B0%E8%BF%AD%E4%BB%A3%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[迭代器模式迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素，而不需要暴露该对象的内部表示。迭代器分为内部迭代器和外部迭代器。内部迭代器只需一次初始调用，而外部迭代器必须显式地请求迭代下一个元素，这样我们就可以手动控制迭代过程。实现一个内部迭代器：1234567891011Array.prototype.innerIterator = function(callback)&#123; for (let i = 0, len = this.length; i &lt; len; i++) &#123; callback &amp;&amp; callback.call(this[i], this[i], i) &#125;&#125;;[1,2,3].innerIterator(function(item, index)&#123; console.log('item:', item, 'index:', index)&#125;)// item: 1 index: 0// item: 2 index: 1// item: 3 index: 2实现一个外部迭代器：123456789101112131415161718Array.prototype.outerInterator = function()&#123; let index = 0; return &#123; next: () =&gt; &#123; return index &lt; this.length ? &#123;value: this[index++], done: false&#125;: &#123;value: undefined, done: true&#125; &#125; &#125;&#125;let iterator = [1,2,3].outerInterator();for(let next; (next = iterator.next()) &amp;&amp; !next.done;) &#123; console.log('item', next.value)&#125;// item 1// item 2// item 3迭代协议了解了迭代器模式，再来看看 ES6 中补充的迭代协议。可迭代（iterable）协议和迭代器（iterator）协议。可迭代协议：一个可迭代对象（或其原型上），必须有一个 Symbol.iterator 的属性，该属性所对应的值为返回一个对象的无參函数，被返回对象符合迭代器协议。当可迭代对象需要迭代时，调用该方法。一些数据类型内置了 @@iterator 方法，有自己默认的迭代行为。（String, Array, TypedArray, Map , Set 等都是内置可迭代对象， 因为它们的原型对象都有一个 @@iterator 方法.）（[Symbol.iterator]、@@iterator 可以认为是一回事）123let iterator = ('hi')[Symbol.iterator]()var a = iterator.next();// a &#123; value: 'h', done: false &#125;迭代器协议：一个迭代器必须实现了 next() 方法，该方法是返回一个对象的无參函数。被返回的对象有两个必要的属性：done 和 value。123456789101112131415161718Array.prototype.Iteration = function()&#123; let index = 0; return &#123; [Symbol.iterator]()&#123;return this&#125;, next: () =&gt; &#123; return index &lt; this.length ? &#123;value: this[index++], done: false&#125;: &#123;value: undefined, done: true&#125; &#125; &#125;&#125;;let Iteration = [2, 3, 4].Iteration();for(let value of Iteration) &#123; console.log('value', value)&#125;// value 2// value 3// value 4不能发现，Iteration 同时满足可迭代协议和迭代协议。又因为是可迭代的，for...of 是可以直接使用，而且这个和外部迭代器十分相似。一旦一种数据结构有了 @@iterator 方法后， 就认为是可迭代的。ES6 中许多新的方法就是基于此的 解构赋值、扩展运算符、yield*，还有 for..of、Array.from()等。知道了以上知识，也就知道了为什么对象不可以直接使用 for...of 了。不过我们可以在对象原型上添加 @@iterator 方法，使之成为可迭代的。12345678910111213141516171819Object.prototype.Iteration = function()&#123; let keys = Object.keys(this), index = 0; return&#123; [Symbol.iterator]()&#123;return this&#125;, next: () =&gt; &#123; let current = index++; return current &lt; keys.length? &#123;value: [keys[current], this[keys[current]]], done: false&#125;: &#123;value: undefined, done: true&#125;; &#125; &#125;&#125;let iterator = &#123;'a': 1, 'b': 2, 'c': 3&#125;.Iteration(); for(let [key, value] of iterator) &#123; console.log('key:', key, 'value:', value)&#125;// key: a value: 1// key: b value: 2// key: c value: 3生成器像以上的的对象都是我们自己手动实现的，符合可迭代协议和迭代协议的对象。看起来很麻烦，还好这些工作已经有函数替我们做了，那就是生成器函数。生成器函数是可以作为迭代器工厂的函数，当它被执行时会返回一个新的 Generator 对象，该对象符合可迭代协议和迭代器协议。现在我们用生成器函数使得对象符合迭代协议：1234567891011Object.prototype.Iteration = function *()&#123; for(let [key, value] of Object.entries(this))&#123; yield [key, value] &#125;&#125;for(let [key, value] of &#123;'a': 1, 'b': 2, 'c': 3&#125;.Iteration()) &#123; console.log('key:', key, 'value:', value)&#125;// key: a value: 1// key: b value: 2// key: c value: 3在这里生成器只是作为迭代器而已，其实它还是消息双向传递系统。也正是这些特性的存在，使得异步流程控制又向前迈了一大步。]]></content>
      <categories>
        <category>很难么</category>
      </categories>
      <tags>
        <tag>迭代器</tag>
        <tag>迭代协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用DevTools提高你的工作效率]]></title>
    <url>%2F%E7%94%A8DevTools%E6%8F%90%E9%AB%98%E4%BD%A0%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%95%88%E7%8E%87%2F</url>
    <content type="text"><![CDATA[Chrome DevTools 调试使用 demo地址作为前端开发者，免不了要和 DevTools 打交道,熟练的使用 DevTools 能够大大提高我们的工作效率。然而，开发者工具的使用并没有得到足够的重视。工欲善其事必先利其器，更何况，工具的学习成本比专业技能的学习成本小的多。Chrome 有不同版本，如果想第一时间体验一些新的功能可以使用除稳定版本的其它版本。本次主要围绕着 Workspace 和 Blackbox script 这两点来感受它们带来的便利。WorkspaceWorkspace 主要还是将浏览器关联本地文件，使得浏览器拥有读写本地文件的权利。随着前端的发展，业务和逻辑也越来越复杂。还好打包压缩工具应运而生，还有 sourceMap 的使用，又让我们从压缩混淆的代码中有了看源码的体验。此时我们依然可以 DevTools 里 Sources 页签里的 Filesystem 页签添加本地文件夹，从浏览器里修改本地文件。这个功能或许还有点用，但是还是不如人意。因为修改后的文件需要刷新后才能显示变动，而文件被更改后，打包工具需要重新编译，编译时间或许很长或许很短，而且页面被被整体刷新了，给人一种很生硬的感觉。不过，还好有 热组件替换 这么一说。给我们的应用程序加上这货之后，我们的开发将会更加丝滑😉。热组件替换以 create-react-app 为例🌰（最新版本），步骤如下。也可以看看👀官方怎么说react-hot-loader.1⃣️：1npm install react-hot-loader --save-dev2⃣️：在 entry 中添加 isEnvDevelopment &amp;&amp; &#39;react-hot-loader/patch&#39;,3⃣️：在 oneOf 中 babel-loader 的 plugins 中添加 [&#39;react-hot-loader/babel&#39;],4⃣️：在入口文件添加以下内容1234567891011121314151617181920import &#123; AppContainer &#125; from 'react-hot-loader'const root = document.getElementById('root')const render = (Component) =&gt; &#123; ReactDOM.render( &lt;AppContainer&gt; &lt;Component /&gt; &lt;/AppContainer&gt;, root )&#125;render(App)if (module.hot) &#123; module.hot.accept('./App', () =&gt; &#123; const NextApp = require('./App').default render(NextApp) &#125;)&#125;至此，热组件替换改造完成，让我们再次感受下。通过以上展示，我们可以发现，整个界面只是局部被替换了，过渡得很自然。这应该才是我们想要的效果✨。插一句，在 Network 页签中，Preserve log 一定要勾选上☑️。这样的话，即使页面刷新了，也是有记录📝的，非常方便在页面跳转刷新时使用。Blackbox script如果说以上是提高了开发上的效率，那么这个 Blackbox script 功能将会在定位上省下不少时间。在断点排查问题时，代码总会在不同的位置切换。但是，经常会遇到各种不是我们程序里的代码跳出来。不过，只要我们把该文件标记为 Blackbox script 时，下次就不会再出现了。当然这只是最基本的操作，要想充分利用这个功能，还是要配合其它功能的使用。Call Stack调用栈在排查问题是很有用的，我们知道，函数的执行是有执行上下文的，函数由最外层到最内层依次压入栈中，在执行的时候，依次从栈中弹出。这样我们就可以从最内层沿着链找到最外层。排查错误时也是这个道理，我们经常遇到不知名的错误❌，可能是调用第三方的，也可能是底层，总之不是我们写的代码（我信你个鬼😏）。遇到这种情况就可以尝试用调用栈的方法，既然执行了，肯定是有调用的地方，我们可以沿着链去找源头（十有八九是我们自己写的代码😏）。不过调用栈中可能混杂了不是我们自己写的函数，这时候 Blackbox script 就派上用场了。Event Listener Breakpoints可能在熟悉一个新的项目时，想知道某个 dom 绑定的处理事件。Sources 页签下的 Event Listener Breakpoints 可以定位到代码具体的位置，不过和上次一样，好多其它代码混淆视听，我们需要把它们标记为 Blackbox script。标记完后，下次就会直接在自己的代码里停住了。Initiator其实和 Event Listener Breakpoints 并排的 XHR/fetch Breakpoints 也很有用，不过和接下来要讲的功能比，就显得鸡肋了。在 Network 页签中，记录的都是请求的数据。在开发的时候常遇到这两种情况，1⃣️：接口报错，在 Network 页签中可以看到整个URL被标红了，要快速定位到调用接口的地方。2⃣️：请求出去了，请看看响应时，如何处理数据。其实，两个实质上都是一样，就是快速定位代码。快速定位在大型项目中还是挺麻烦的，除非业务比较熟，剩下只能全局搜索了。还好，Network 页签下的 Initiator 也有类似调用栈的东西，我们可以在其列表中找到，Blackbox script 的功能依然时屏蔽无关的代码。补充除了以上还有很多调试技巧，1⃣️：有时候我们看见了控制有错误❌输出，却不知道是哪里的问题。或者是控制有报错❌，但一闪而过，无法捕捉。这时候可以尝试使用异常断点的功能(最右➡️的那个)。倒数第二个，是用来恢复函数执行的，使断点不起作用。2⃣️：数据量过大时，可能由于某一条数据的问题导致了页面渲染问题。如果打断点的话，数据量太大了，每一次都跳到循环的处理逻辑中会很麻烦。不过断点是支持条件断点的，还可以打印我们想要的变量（在最新的 Chrome dev版本中，已单独拎出来了）。3⃣️：有时候页面加载过快，都来不及看明白页面是怎么展示的。比如跳转问题，比如模拟网速慢、电脑性能卡慢问题。（这里十有八九是并发引起的竞态问题😏）右下角 Oneline 可自选模式。4⃣️：……]]></content>
      <categories>
        <category>善事利器</category>
      </categories>
      <tags>
        <tag>Chrome</tag>
        <tag>DevTools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异步的JavaScript(Promise篇)]]></title>
    <url>%2F%E5%BC%82%E6%AD%A5%E7%9A%84JavaScript%E2%80%94%E2%80%94Promise%E7%AF%87%2F</url>
    <content type="text"><![CDATA[引言错误理解精心组织起来的异步代码还不如使用一团乱麻的回调函数。在处理异步的问题上，回调基本上能够胜任，不过这都是建立在一切正常运转的基础上。然而事与愿违，回调受到控制反转的影响，把控制权交给了第三方，这种控制转移导致了一系列的信任问题（回调调用过早、回调调用过晚、回调不被调用、回调调用次数过少或过多等问题）。同时，基于回调的异步表达又是无序性的，回调地狱的使用，让我们正确理解代码的难度加大。函数的确可以规避以上的问题，但是，毋庸置疑，这会再次加大代码的理解难度。与其交给不信任的第三方，倒不如转交给一个位于我们和第三方间的可信任的中介机制，这里就是我们要说的 Promise。回调的转变如何把回调交给 Promise， 其实很简单。使用 Promise 后我们就无需再关心大部分的信任问题和无序性。因为 Promise 机制已经为我们处理好了，我们不需要写些特定逻辑来解决一些信任问题和并发带来的竞态问题，只要我们按照 Promise 规范正确执行即可。现在，以 setTimeout 代表异步操作来进行 Promise 改造。12345678910111213// callback asyncconst callback_async = (x = Date.now(), callback) =&gt; &#123; // do something now console.log('callback_async:初始时间戳', x) setTimeout(() =&gt; &#123; // do something in the future let interval = Date.now() - x callback &amp;&amp; callback(`callback_async:在$&#123;interval&#125;毫秒后异步完成`) &#125;, 1000)&#125;callback_async(undefined, res =&gt; &#123; console.log('callback_async:', res)&#125;)在 Promise 中我们依然能够看到回调的身影，只是回调作为参数传递的位置发生了变化。我们不再把回调交给第三方，而是让 Promise 从第三方获取某些数据，然后回调作为参数传递进去。1234567891011121314const promise_async = (x = Date.now()) =&gt; &#123; return new Promise(resolve =&gt; &#123; // do something now console.log('promise_async:初始时间戳', x) setTimeout(() =&gt; &#123; // do something in the future let interval = Date.now() - x resolve(`promise_async:在$&#123;interval&#125;毫秒后异步完成`) &#125;, 1000) &#125;)&#125;promise_async(undefined).then(res =&gt; &#123; console.log(res)&#125;)不同之前的把回调直接传给第三方的做法，这次是靠着 Promise 这个中间机制来替异步任务管理着回调。错误的处理使用 Promise 后，怎么就会好了很多呢？首先说说在错误的处理上。JavaScript 代码在执行的过程中若遇到错误就不会执行下去的。作为传入第三方的回调（同步回调或异步回调），如果在此之前就已经报错了，回调压根不会执行。在这种情况下，能通过回调捕获错误，也是很有意义的。我们很自然地想到了 try...catch , 不过在异步回调中，回调函数的执行栈与原函数分离开，导致外部是无法抓住异常。不过没关系，我们就多捕捉一遍。在此，我们就用“error-first风格”模拟一下。1234567891011121314151617181920212223// callback asyncconst callback_async = (x = Date.now(), callback) =&gt; &#123; try &#123; console.log('callback_async:初始时间戳', x) // do something now // throw 'callback-outer: error' setTimeout(() =&gt; &#123; try &#123; // do something in the future // throw 'callback-inner: error' let interval = Date.now() - x callback &amp;&amp; callback(null, `callback_async:在$&#123;interval&#125;毫秒后异步完成`) &#125; catch (error) &#123; callback(error) &#125; &#125;, 1000) &#125; catch (error) &#123; callback(error) &#125;&#125;callback_async(undefined, (error, res) =&gt; &#123; error?console.log('asyncError:', error):console.log('async:', res)&#125;)依次解开注释 throw... ，我们就可以成功地捕获到错误或异常。但同时也发现，对于一个不断嵌套的异步回调，就回调地狱那样，我们会为每一个异步回调做 try...catch 的错误处理，这会使原有的代码更加混乱。“幸运”的是，Promise 已经为我们处理好了这个问题。对于错误或异常，我们只需要注册 rejected 或 catch 的回调即可。不过 Promise 也存在着和上面相同的问题，无法捕获脱离上下文环境的错误或异常，我们只能收到手动 reject。1234567891011121314151617181920const promise_async = (x = Date.now()) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; // do something now // throw 'promise-outer: error' console.log('promise_async:初始时间戳', x) setTimeout(() =&gt; &#123; try &#123; // do something in the future // throw 'promise-inner: error' let interval = Date.now() - x resolve(`promise_async:在$&#123;interval&#125;毫秒后异步完成`) &#125; catch (error) &#123; reject(error) &#125; &#125;, 1000) &#125;)&#125;promise_async(undefined).catch(error =&gt; &#123; console.log(error)&#125;)对于多个异步任务，Promise 仍然能够很好的处理错误，因为 Promise 使用的 this-then-that 的流程控制，默认处理函数只是把错误重新抛出，这使得错误可以继续沿着Promise链传播下去，直到显式的 rejected 或 catch 捕获错误。Promise化Promise 带来的好处远远不止这些。一旦 Promise 决议， 它就永远保持这个状态，这个 Promise 的 then(...) 注册的回调就会被自动调用，且只会被调用一次。这也算解决了回调调用过少、过多及不被调用的问题。即使不能解决，但也可以在此基础上再做处理。你要是问为什么，我只能说人家就是干这个的，作为一个可信任的中间协商机制。说到一旦决议就不能改变，这个很重要么，是的，真的很重要。在基于回调模式的异步处理中，JavaScript 代码执行后会一直走下去，遇到回调就直接执行了。但是 Promise 决议后，可以一直保留着这个结果，通过 .then(..) 形式添加的回调函数，甚至在异步操作完成之后才添加的回调函数，都会被执行调用。这也是上一个 Promise 里的错误只能在 Promise 链的下一个回调里捕获的原因。知道了 Promise 的好处，也知道了基于回调模式的异步处理方式，我们就可以尝试把“error-first风格”的回调 Promise 化。1234567891011// Promise Wrapvar promise_wrap = function(fn)&#123; return function() &#123; let args = Array.from(arguments); return new Promise((resolve, reject) =&gt; &#123; fn.apply(null, args.concat((error, value) =&gt; &#123; error ? reject(error): resolve(value) &#125;)) &#125;) &#125;&#125;在这里我们可以看到，为了统一处理现在和将来，我们把它们都变成了将来，即所有的操作都成了异步，同步回调也变成了异步回调。JavaScript 异常错误也是如此，在 Promise 创建过程中或查看决议结果过程中出现的异常错误，这个异常错误被捕捉都会变成异步行为。这样做减少了由函数顺序不确定性（竞态条件）带来的诸多问题。保持扁平化从回调模式跨到 Promise，总会不小心保留着原来的风格，比如嵌套。Promise 链式编程最好保持扁平化，不然不就变成另一个回调地狱了？关键是还没有返回或终止 Promise 链。1234567891011121314151617// parallel Promisevar parallel_promise = (x = Date.now()) =&gt; &#123; Promise.resolve().then(() =&gt; &#123; new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; let interval = Date.now() - x; resolve(`parallel-inner:在$&#123;interval&#125;毫秒后完成`) &#125;, 3000) &#125;).then(res =&gt; &#123; console.log(res) &#125;) &#125;).then(res =&gt; &#123; let interval = Date.now() - x; console.log(`parallel-outer:在$&#123;interval&#125;毫秒后完成; res: $&#123;res&#125;`) &#125;)&#125;parallel_promise(undefined)从上面的执行结果可以看出，parallel-outer 并非在 parallel-inner 后执行。这是没有正确将 Promise 相连接的结果。实际上，这里就是两个独立竞争的 Promise（同时在执行异步任务而不是一个接着一个）。同时我们也会注意到外层 then(...) 注册回调中 res 为 undefined，因为对于没有任何显式的决议，这个值就是 undefined。123456789101112131415161718// serial Promisevar serial_promise = (x = Date.now()) =&gt; &#123; Promise.resolve().then(() =&gt; &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; let interval = Date.now() - x; resolve(`serial-1:在$&#123;interval&#125;毫秒后完成`) &#125;, 3000) &#125;).then(res =&gt; &#123; console.log(res) return res &#125;) &#125;).then(res =&gt; &#123; let interval = Date.now() - x; console.log(`serial-2:在$&#123;interval&#125;毫秒后完成; res: $&#123;res&#125;`) &#125;)&#125;serial_promise(undefined)所以说，一个好的经验法则是总是返回或终止 Promise 链，并且一旦得到一个新的 Promise，返回它。小结用 Promise 来表达异步和管理并发无疑是种进步，它在程序的顺序性和可信任性上提供了自己的解决方案。它不是回调的替代品，只是帮着异步任务管理回调的可信任的中间机制。相对于直接粗暴的回调，Promise 并不会带来性能上的提升，但是它会让我们的程序更加健壮，也使得代码更加简洁，更加符合我们有序的思维方式。当然，Promise 也有自己的局限性。在并发 Promise.race(...) 上，我们只要第一个决议即可。当出现第一个决议的 Promise 时，其它的 Promise 就没有必要进行下去了。然而，我们没把法终止。在错误处理上，Promise 链中错误总是由下一个 Promise 捕获。如果错误发生在最后一个 Promise 呢？还有，对于嵌套的 Promise，内部 Promise 已经进行了错误处理，但是外部 Promise 却捕获不到，这样真的好么？Promise 恢复了可信任性，但我们还想让异步流程的表达风格更贴近同步的形式，链式调用不说不好，只是我们带着同步操作的惯性。还好，ES6、ES7已经给出了方案。]]></content>
      <categories>
        <category>很难么</category>
      </categories>
      <tags>
        <tag>异步</tag>
        <tag>Promise</tag>
        <tag>then</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端笔试之手写代码]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AF%95%E4%B9%8B%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[扁平化嵌套数组/flat实现描述：将嵌套多层的数组展开平铺成只有一层的数组。12let array = [1, [1, 2, 3], [1, [2, &#123;&#125;]] ]handle(array) // [1, 1, 2, 3, 1, 2, &#123;&#125;]方法一：12const handle = array =&gt; JSON.parse(`[$&#123;JSON.stringify(array).replace(/\[|]/g,'')&#125;]`)handle(array) // [ 1, 1, 2, 3, 1, 2, &#123;&#125; ]知识点：JSON.parse()/JSON.stringify()、String.prototype.replace()方法二：12const handle = array =&gt; array.reduce((accumulator, currentValue) =&gt; accumulator.concat(Array.isArray(currentValue) ? handle(currentValue): currentValue), [])handle(array) // [ 1, 1, 2, 3, 1, 2, &#123;&#125; ]知识点：Array.prototype.reduce()、Array.prototype.concat()方法三：1234567const handle = array =&gt; &#123; while(array.some(item =&gt; Array.isArray(item))) &#123; array = [].concat(...array) &#125; return array&#125;handle(array) // [ 1, 1, 2, 3, 1, 2, &#123;&#125; ]知识点：while、Array.prototype.some()、展开语法(Spread syntax)其它方法：……数组去重描述：将数组中重复的元素过滤掉。12let array = [1, 2, 1, '3', '3', 0 , 1]handle(array) // [1, 2, '3', 0]方法一：12const handle = array =&gt; [...new Set(array)]handle(array) // [ 1, 2, '3', 0 ]知识点：Set方法二：12345const handle = array =&gt; array.reduce((accumulator, currentValue) =&gt; &#123; !accumulator.includes(currentValue) &amp;&amp; accumulator.push(currentValue) return accumulator&#125;, [])handle(array) // [ 1, 2, '3', 0 ]知识点：Array.prototype.includes()方法三：12345const handle = array =&gt; &#123; let map = new Map() return array.filter(item =&gt; map.has(item) ? false : map.set(item))&#125;handle(array) // [ 1, 2, '3', 0 ]知识点：Map、Array.prototype.filter()其它方法：……模拟bind实现123456Function.prototype.bind = function () &#123; let self = this, args = Array.from(arguments), context = args.shift(); return function () &#123; return self.apply(context, args.concat(...arguments)) &#125;;&#125;;知识点：apply、call、bind模拟Call实现1234567Function.prototype.Call = function()&#123; let args = Array.from(arguments), context = args.shift(); context = Object(context); context.fn = this; let result = context.fn(...args); return (delete context.fn) &amp;&amp; result;&#125;;模拟New实现123456const handle = function() &#123; let fn = Array.prototype.shift.call(arguments) let obj = Object.create(fn.prototype) let o = fn.apply(obj, arguments) return typeof o === 'object' ? o : obj;&#125;知识点：Object.create()格式化数字123const num = 123456789;const handle = num =&gt; String(num).replace(/\B(?=(\d&#123;3&#125;)+(?!\d))/g, ',')handle(num) // 123,456,789知识点：正则表达式、String.prototype.replace()回文判断123456789const num = 123456654321;const str = 'abababababab';const handle = params =&gt; &#123; let str_1 = String(params).replace(/[^0-9A-Za-z]/g, '').toLowerCase(); let str_2 = str_1.split('').reverse().join(); return str_1 === str_2 ? true : false&#125;handle(num) // truehandle(str) // false知识点：String.prototype.split()、Array.prototype.join()函数节流定时器1234567891011const handle = (fn, interval) =&gt; &#123; let timeId = null; return function() &#123; if (!timeId) &#123; timeId = setTimeout(() =&gt; &#123; fn.apply(this, arguments) timeId = null &#125;, interval) &#125; &#125;&#125;知识点：window.setTimeout时间戳12345678910const handle = (fn, interval) =&gt; &#123; let lastTime = 0 return function () &#123; let now = Date.now(); if (now - lastTime &gt; interval) &#123; fn.apply(this, arguments) lastTime = now &#125; &#125;&#125;函数防抖123456789const handle = (fn, delay) =&gt; &#123; let timeId; return function() &#123; if (timeId) clearTimeout(timeId) timeId = setTimeout(() =&gt; &#123; fn.apply(this, arguments) &#125;, delay) &#125;&#125;函数节流、函数防抖区别：函数节流和函数防抖较容易混淆，可以这么比喻，对于函数节流，门外有人频繁敲门，但是门卫按固定时间来决定是否开门。对于函数防抖，门外有人频繁敲门，门卫按最后一次敲门来决定是否开门。知识点：window.clearTimeout深拷贝12345678910111213const handle = function deepClone(params) &#123; if (Array.isArray(params)) &#123; return params.reduce((accumulator, currentValue) =&gt; &#123; (typeof currentValue === 'object') ? accumulator.push(deepClone(currentValue)) : accumulator.push(currentValue); return accumulator; &#125;, []) &#125; else &#123; return Reflect.ownKeys(params).reduce((accumulator, currentValue) =&gt; &#123; (typeof params[currentValue] === 'object') ? accumulator[currentValue] = deepClone(params[currentValue]) : accumulator[currentValue] = params[currentValue]; return accumulator; &#125;, &#123;&#125;) &#125;&#125;发布订阅模式123456789101112131415161718192021222324252627282930class Pubsub &#123; constructor() &#123; this.handles = &#123;&#125; &#125; subscribe(type, handle) &#123; if (!this.handles[type]) &#123; this.handles[type] = [] &#125; this.handles[type].push(handle) &#125; unsubscribe(type, handle) &#123; let pos = this.handles[type].indexOf(handle) if (!handle) &#123; this.handles.length = 0 &#125; else &#123; ~pos &amp;&amp; this.handles[type].splice(pos, 1) &#125; &#125; publish() &#123; let type = Array.prototype.shift.call(arguments) this.handles[type].forEach(handle =&gt; &#123; handle.apply(this, arguments) &#125;) &#125;&#125;const pub = new Pubsub()pub.subscribe('a', function() &#123;console.log('a', ...arguments)&#125;)pub.publish('a', 1, 2, 3)// a 1 2 3]]></content>
      <categories>
        <category>写着玩</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异步的JavaScript(回调篇)]]></title>
    <url>%2F%E5%BC%82%E6%AD%A5%E7%9A%84JavaScript%2F</url>
    <content type="text"><![CDATA[唯一比不知道代码为什么崩溃更可怕的事情是，不知道为什么一开始它是工作的！在 ECMA 规范的最近几次版本里不断有新成员加入，尤其在处理异步的问题上，更是不断推陈出新。然而，我们在享受便利的同时，也应该了解异步到底是怎么一回事。现在与将来JavaScript 是单线程的，一次只能专注于一件事。如果浏览器只靠 JavaScript 引擎线程来完成所有工作，先不说能不能搞定，即使可以，那也会花费很长时间。幸好在浏览器里 JavaScript 引擎并不孤单，还有 GUI 渲染线程、事件触发线程、定时触发器线程、异步http请求线程等其它线程。这些线程之间的协作才有了我们看到的浏览器界面效果（远不止这些）。(盗了一张图)一个程序在执行过程中可能会有等待用户输入、从数据库或文件系统中请求数据、通过网络发送并等待响应，或是以固定时间间隔执行重复任务（比如动画）等情况。（这些情况，当下是无法得出结果的，但是一旦有了结果，我们知道需要去做些什么。）JavaScript 引擎不是一个人在战斗，它把以上的任务交给其它线程，并计划好任务完成后要做的事，JavaScript 引擎又可以继续做自己的事了。从这里可以看出，一个程序的运行包括两部分，现在运行和将来运行。而现在运行和将来运行的关系正是异步编程的核心。123let params = &#123;type:'asynchronous'&#125;let response = ajax(params,'http://someURL.com'); // 异步请求if (!response) throw '无数据！';以上代码肯定会抛错的，异步请求任务交出去之后，程序会继续运行下去。由于ajax(…) 是异步操作，即使立刻返回结果，当下的 response 也不会被赋值。一个是现在，一个是将来，两者本就不属于一个时空的。事件循环现在和将来是相对的，等将来的时刻到了，将来也就成为了现在。JavaScript 引擎运行在宿主环境中，宿主环境提供了一种机制来处理程序中多个块的执行，且执行每个块时调用 JavaScript 引擎，这种机制被称为事件循环。即，JavaScript 引擎本身并没有时间的概念，只是一个按需执行 JavaScript 任意代码片段的环境。“事件”（JavaScript 代码执行）调度总是由包含它的环境进行。点击图片进入或点此进入：一个 JavaScript 运行时包含了一个待处理的消息队列。每一个消息都关联着一个用以处理这个消息的函数。在事件循环期间的某个时刻，运行时从最先进入队列的消息开始处理队列中的消息。为此，这个消息会被移出队列，并作为输入参数调用与之关联的函数。123while (queue.waitForMessage()) &#123; queue.processNextMessage();&#125;一旦有事件需要进行，事件循环就会运行，直到队列清空。事件循环的每一轮称为一个 tick。用户交互，IO 和定时器会向事件队列中加入事件。(又盗了一张图)任务队列任务队列（job queue）建立在事件循环队列之上。（Promise 的异步特性就是基于任务。）最好的理解方式，它是挂在事件循环队列的每个tick之后的一个队列。在事件循环的每个tick中，可能出现的异步动作不会导致一个完整的新事件添加到事件循环队列中，而会在当前 tick 的任务队列末尾添加一个项目（一个任务）。即，由 Call Stack 生成的任务队列会紧随其后运行。1234567891011121314151617181920212223242526272829Promise.resolve().then(function promise1 () &#123; console.log('promise1');&#125;)setTimeout(function setTimeout1 ()&#123; console.log('setTimeout1'); Promise.resolve().then(function promise2 () &#123; console.log('promise2'); &#125;)&#125;, 0)setTimeout(function setTimeout2 ()&#123;console.log('setTimeout2'); Promise.resolve().then(function promise3 () &#123; console.log('promise3'); setTimeout(function setTimeout3 () &#123; console.log('setTimeout3'); &#125;) Promise.resolve().then(function promise4 () &#123; console.log('promise4'); &#125;) &#125;)&#125;, 0)// promise1// setTimeout1// promise2// setTimeout2// promise3// promise4// setTimeout3回调被作为实参传入另一函数，并在该外部函数内被调用，用以来完成某些任务的函数，称为回调函数。回调函数经常被用于继续执行一个异步完成后的操作，它们被称为异步回调。立即执行的称之为同步回调。回调函数是事件循环“回头调用”到程序中的目标，队列处理到这个项目的时候会运行它。回调是 JavaScript 语言中最基础的异步模式。生活中，我们喜欢和有条理的人打交道，因为我们的大脑习惯了这种思维模式。然而回调的使用打破了这种模式，因为代码的嵌套使得我们要在不同块间切换。嵌套越多，逻辑越复杂，我们也就越难理解和处理代码，尤其在表达异步的方式上。(又盗了一张图)除了嵌套的问题，异步回调还存在一些信任问题。回调性质的不确定调用回调方式不确定（没调用，重复调用等）……针对第一点的建议是：永远异步调用回调，即使就在事件循环的下一轮，这样，所有回调都是可预测的异步调用了。在理解这个建议之前，我们首先了解下控制反转，控制反转就是把自己程序一部分的执行控制交个某个第三方。12345let a = 0; // Athirdparty(() =&gt; &#123; console.log('a', a); // B&#125;)a++; // CA 和 C 是现在运行的，B 虽然代码是我们的，但是却受制于第三方，因为我们无法确定它是现在运行还是将来运行的。这里的回调函数可能是同步回调也可能是异步回调。a 是 0 还是 1，都有可能。12345678// 同步回调const thirdparty = cb =&gt; &#123; cb();&#125;// 异步回调const thirdparty = cb =&gt; &#123; setTimeout(() =&gt; cb(), 0);&#125;所以，永远异步调用回调，可预测。12345678910111213141516171819202122function asyncify(fn) &#123; let func = fn; let t = setTimeout(() =&gt; &#123; t = null; if (fn) fn(); &#125;, 0); fn = null; return () =&gt; &#123; if (t) &#123; fn = func.bind(this, ...arguments); &#125; else &#123; func.apply(this, arguments); &#125; &#125;&#125;let a = 0;thirdparty(asyncify(() =&gt; &#123; console.log('a', a);&#125;))a++;// 1]]></content>
      <categories>
        <category>很难么</category>
      </categories>
      <tags>
        <tag>异步</tag>
        <tag>事件循环</tag>
        <tag>任务队列</tag>
        <tag>回调</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于MVC模式简单代码实现]]></title>
    <url>%2F%E5%85%B3%E4%BA%8EMVC%E6%A8%A1%E5%BC%8F%E7%AE%80%E5%8D%95%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[经过之前的咬文嚼字说策略、在JavaScript中尝试组合模式、白话MVC/MVP/MVVM 和 较早之前的进击的观察者模式等文章的铺垫，终于可以把这些理论的东西用于实践了。废话不多说，直奔主题。GoF 并不将 MVC 引述为一种设计模式，而是把它看做是构建一个用户界面的类的集合。按照他们的观点，它实际上是三种经典设计模式的变异组合：观察者模式，策略模式和组合模式。依赖于框架中的 MVC 如何实现，它也可能会使用工厂和模板模式。GoF Book 提到这些模式在使用 MVC 工作时是非常有用的附加功能。功能示意:由一组数据展示三类表格，分别是【stuff，scale】、【stuff，salary】、【stuff，scale，salary】三组视图。另外可以修改指定 stuff 的 scale 或 salary 信息。stuffs 信息：1234567891011121314151617const stuffs = [ &#123; stuff: 'person_1', scale: '甲', salary: '6000' &#125;, &#123; stuff: 'person_2', scale: '乙', salary: '5000' &#125;, &#123; stuff: 'person_3', scale: '丙', salary: '9000' &#125;];常规的写法可以这么来：See the Pen tableOrdinary by 夜曉宸 (@yexiaochen)on CodePen.职责分配既然说了 MVC 有那么多好处，我们就用 MVC 的模式来改造下我们的代码。首先我们先划分下职责。Model 负责对数据的处理并返回目标数据，在这个场景下是筛选 stuff、修改stuff 等职责。View 负责对目标数据的渲染和处理用户的响应，在这个场景下是各个表格的渲染、change 事件的委托等职责。Control 负责协调 Model 和 View，在这个场景下是处理委托、处理数据等职责。此处的 MVC 实现是针对一个 Model 对应多个 View 的代码实现 ，也是为了把观察者模式，策略模式和组合模式模式都用起来。View【stuff，scale】、【stuff，salary】、【stuff，scale，salary】三组视图就是三个 View，每个 View 都可以独立渲染自己的一组视图。结合组合模式，我们我们造些视图的叶对象和分支对象。123456789&lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; const $APP = document.getElementById('app');&lt;/script&gt;叶对象（此处有两类视图）：123456789101112131415161718const leafView_1 = () =&gt; &#123;const renderTable = () =&gt; &#123;...&#125;; return &#123; render: renderTable() &#125;;&#125;const leafView_2 = (Control) =&gt; &#123; const $ONE = document.getElementById('one'); let $SCALE; let $SALARY; const renderSearchTable = params =&gt; &#123;...&#125;; const handleModify = e =&gt; &#123;...&#125;; const bindEvent = () =&gt; &#123;...&#125;; return &#123; render: () =&gt; &#123;...&#125; &#125;;&#125;分支对象：1234567891011121314const branchView = (Control) =&gt; &#123; let $SEARCH, $ALL; const Views = []; const addView = () =&gt; &#123;...&#125;; const render = () =&gt; &#123;...&#125;; const handleSearch = event =&gt; &#123;...&#125;; const bindEvent = () =&gt; &#123;...&#125; const initDOM = () =&gt; &#123;...&#125;; initDOM(); return &#123; render, addView, &#125;;&#125;;ModelModel 主要是将数据处理成目标数据，并提供 View 注册通知接口。1234567891011121314151617181920const Model = () =&gt; &#123; let stuffData = []; let filterData = []; let Views = &#123;&#125;; const ajaxFun = () =&gt; [...]; // 模拟后台获取数据； const setStuffData = () =&gt; &#123;&#125;; const filterStuff = () =&gt; &#123;&#125;; const setFilterStuff = () =&gt; &#123;&#125;; const findStuff = () =&gt; &#123;...&#125;; const modifyStuffData = () =&gt; &#123;...&#125;; const register = () =&gt; &#123;...&#125;; const notify = () =&gt; &#123;...&#125;; return &#123; setStuffData, setFilterStuff, modifyStuffData register, notify, &#125;;&#125;Control鉴于此处有多类视图，Model 和 View 之间，我们采用了发布订阅模式而不是观察者模式。Model 需要收集 View，然后在数据改变时候更新视图。12345678910111213const Control = () =&gt; &#123; const ModelInstance = Model(); const View_1 = () =&gt; &#123;...&#125;; const View_2 = () =&gt; &#123;...&#125;; const init = function () &#123;...&#125;; const filter = () =&gt; &#123;...&#125;; const modifyStuffInfo = () =&gt; &#123;...&#125;; return &#123; init, filter, modifyStuffInfo &#125;;&#125;;完整的 MVC 代码：See the Pen MVC by 夜曉宸 (@yexiaochen)on CodePen.后话就这么简单的一个需求，改成 MVC 模式后就多了 100 多行代码。就如上篇文章所说一样，如果是简单的需求压根没必要这么折腾。不过，改成 MVC 后，它们各自职责也就更加清晰了，对以后的维护也会好些。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>观察者模式</tag>
        <tag>MVC</tag>
        <tag>策略模式</tag>
        <tag>组合模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[白话MVC/MVP/MVVM]]></title>
    <url>%2F%E7%99%BD%E8%AF%9DMVC-MVP-MVVM%2F</url>
    <content type="text"><![CDATA[一切皆为数据（0，1），一切皆可量化不管承不承认，页面的展示都是数据的可视化。HTML 是数据，CSS 是数据，JS也是数据。只是这些数据的组合最终变成了我们想要的效果。最为直观的是，我们在开发者工具 Console 控制台中，输入任何形式的数据并点击 Enter 时，最终会在下方显示出来（前提是输入正确的数据类型和格式）。又或者，我们用某些参数从服务请求一个 JSON 文件，浏览器上就会展示文件内容。数据 =&gt; 视图，就是这么简单直接。MV然而，实际上的情况远远比这复杂。为了更好的视觉享受和用户体验，浏览器上的页面效果越来越炫，交互逻辑也越来越复杂。我们拿到的第一手数据（或来自用户，或来自服务）已经不能直接用来展示了，而是要经过相应的逻辑处理（在这里我们称第一手数据为源数据，经过逻辑处理后的数据称为目标数据）。视图上的数据就是目标数据的映射。而处理后的数据又该如何展示呢？是基于 DOM 做操作，还是基于目标数据重新渲染呢？两者都可，前者是以 jQuery 为代表，后者则是以 Vue 等新框架为主。举个例子🌰，对于某个 DOM 元素的显隐。1234567891011&lt;!-- jQuery --&gt;&lt;div id='jquery'&gt;&lt;/div&gt;$('#jquery').hide;&lt;!-- Vue --&gt;&lt;div id='jquery' v-show=&#123;id[jquery]&#125;&gt;&lt;/div&gt;data: &#123; id: &#123; jquery: fasle &#125;&#125;基于 DOM 操作， 如果我们需要对这个 DOM 随时改变显隐，就需要不断操作 DOM 来更改样式。 如果基于数据操作，我们只需要更改 jQuery 的值即可。我们再回到刚才的话题，对于复杂的交互页面，数据 =&gt; 视图 的关系已经不再像之前那么纯净了。为了应付复杂的场景，数据 和 视图 不再是狭义上的数据和视图。数据包括了数据和数据相关的操作，视图包括了视图和对视图相关的一些操作。MV*模式借用其他领域 MV* 框架模式，这里的 数据 和 视图 对应着 Model 和 View. 简单点的页面，Model - View 完全能够应付过来。但是复杂的场景，Model 和 View 会分担太多的逻辑而显得臃肿，甚至可能包含了不在自己职责范围内的逻辑。此时我们就要借助第三者来协调 Model 和 View 之间的关系。如何合作，其实也早有了相应的解决方案。比如 MVC、MVP、MVVM。因为重点始终在于协调 Model和 View，所以它们统称为 MV*。MVC (Model(模型)-View(视图)-Controller(控制器)), MVP (Model(模型)-View(视图)-Presenter(中介者)) 以及 MVVM (Model(模型)-View(视图)-ViewModel(视图模型))，是种模式也是种抽象的概念。每一种模式在实践中可能存在着不同的变体，但这不妨碍它们属于同一个模式。每一种模式的不同变体都是为了解决不同问题而产生的，所以它们没有什么优劣之分。现在我们就把三种模式拟人化来阐述不同模式的运作方式。由四节电池驱动的J-20模型:MVC公司：飞机模型制造商 =&gt; 生产的飞机模型可以自主塑形。模式：MVC飞机模型 V：由模型数据生产出的模型。职责有：由模型数据自主塑形、将收集用户反馈并转发。工程师 M：负责将客服的需求参数转换成最终的模型数据。职责有：对数据的操作、通知飞机模型更新。工程师 C：协调 M 和 V。负责响应用户、调用工程师M生成目标数据。首先我们要知道，客户提出了想要一个 60cm * 60cm 的飞机模型，这个需求到了制造商那里肯定不是给出个 60cm * 60cm 的小方块，而是根据需求计算处理生产真正的飞机模型（比如什么样的造型设计才能最大减少阻力），工程师M的工作之一就是根据原始数据并结合特定的逻辑规则给出最终的模型数据。现在，用户手里有一飞机模型V，不过这个飞机模型的飞机双翼和用户想象的不一样。于是用户根据飞机模型上提供的方式反馈了问题（比如飞机模型提供了留言功能，用来收集用户反馈）。工程师C收到了反馈后，把工程师M拉过来对数据进行处理并生成新的模型数据，并让工程师M通知到共享相同数据的飞机模型去更新数据自主调整。插一句，说到调整，我们有两种方式。一个是，我们可以针对用户不满意的地方（飞机双翼）进行调整。一个是，我们飞机模型格式化按照最新的数据模型重新初始化一下。前者可以认为就是基于 DOM 操作的方式，后者就是基于数据的处理方式。在 MVC 中，Model 和 View 之间耦合，视图的更新需要 Model 去直接通知。Model 内因为有 View 的引用才能让视图更新。MVP如果 Model 只想做数据相关的操作，把通知 View 的逻辑挪到了 Control 里，这时 Control 摇身一变称为了 Presenter。因为解耦了 Model 和 View，也使得它们的职责划分更加清晰。公司：飞机模型制造商 =&gt; 生产的飞机模型可以自主塑形。模式：MVP飞机模型 V：由模型数据生产出的模型。职责有：由模型数据自主塑形、将收集用户反馈并转发。工程师 M：负责将客服的需求参数转换成最终的模型数据。职责有：对数据的操作。工程师 P：协调 M 和 V。负责响应用户、调用工程师M生成目标数据、更新视图。在 MVP 模式中，工程师M的工作专注于数据，通知的活甩给了工程师P。和 MVC 同样的场景，工程师P接到反馈后，把工程师M拉过来处理了数据，然后又让飞机模型依据已经处理后的数据自主调整。每次数据的变化都要主动去通知视图更新。MVVM如果数据变化能够自主触发视图更新，对 Presenter 来说也会轻松不少。于是 Presenter 再次摇身一变 称为了 ViewModel。公司：飞机模型制造商 =&gt; 生产的飞机模型可以自主塑形。模式：MVVM飞机模型 V：由模型数据生产出的模型。职责有：由模型数据自主塑形、将收集用户反馈并转发。工程师 M：负责将客服的需求参数转换成最终的模型数据。职责有：对数据的操作。工程师 VM：协调 M 和 V。负责响应用户、调用工程师M生成目标数据并更新视图。在 MVVM 中，View 和 Model 的变化似乎不大。为了在数据变化后能够自动更新视图，ViewModel 进行了所谓的数据绑定。ViewModel 将 目标数据 和视图进行了绑定，在最终生成目标数据时，会触发视图的更新。在这里我们可以想象有两份数据，一份是源数据，一份是目标数据。绑定视图的是目标数据，这样，我们直接修改目标数据时会触发视图更新。如果是源数据经处理后赋给目标数据，目标数据也会改变，也会触发试图更新。总之，在 MVVM 中，视图是目标数据的可视化，通过改变视图里的数据也就等于改变了目标数据。和 MVC、MVP 同样的场景，不过科技发达了，工程师VM有个自动化处理程序。用户反馈了问题，工程师VM的这个自动处理程序接到反馈自动处理并将结果发给飞机模型让其自主调整。以下是Vue的MVVM示意图：MVC、MVP和MVVM大致就是如此，根据三种模式以及不同场景，最终演变出了不同的变体。但是，不同的变体是针对不同问题的解决方案，指不定后来还会有 MVA、MVB…, 谁知道呢]]></content>
      <categories>
        <category>这个想法不一定对</category>
      </categories>
      <tags>
        <tag>MVC</tag>
        <tag>MVVM</tag>
        <tag>MVP</tag>
        <tag>MV*</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在JavaScript中尝试组合模式]]></title>
    <url>%2F%E5%9C%A8JavaScript%E4%B8%AD%E5%B0%9D%E8%AF%95%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[组合模式就是用小的子对象来构建更大的对象, 将对象组合成树形结构, 以表示 “部分-整体” 的层次结构. 位于底层最小的对象, 我们在这里称为叶对象, 由叶对象组成的组合对象我们称为分支对象, 位于最顶层的根对象在这里我们也称为分支对象. 不过它们只是结构上呈现出父子关系. 组合模式最大的好处可以一致性地对待分支对象和叶对象, 这也就要求了它们有着相同的接口.在咬文嚼字说策略中, 我们对员工进行考核, 划分了甲乙丙三个等级. 现在, 公司决定结合等级以资鼓励.以下所有代码参见compositeMode.开销的占比现有考核人员:考核项目\考核人等级月薪person_1甲6kperson_2乙9kperson_3乙4kperson_4乙5kperson_5丙6kperson_6丙5kperson_7丙6kperson_8丙4kperson_9甲8k123456789101112const persons = [ &#123;scale:'甲', salary: 6000, company: 'JavaScript'&#125;, &#123;scale:'乙', salary: 9000, company: 'JavaScript'&#125;, &#123;scale:'乙', salary: 4000, company: 'JavaScript'&#125;, &#123;scale:'乙', salary: 5000, company: 'JavaScript'&#125;, &#123;scale:'丙', salary: 6000, company: 'JavaScript'&#125;, &#123;scale:'丙', salary: 5000, company: 'JavaScript'&#125;, &#123;scale:'丙', salary: 6000, company: 'JavaScript'&#125;, &#123;scale:'丙', salary: 4000, company: 'JavaScript'&#125;, &#123;scale:'丙', salary: 9000, company: 'JavaScript'&#125;, &#123;scale:'甲', salary: 6000, company: 'JavaScript'&#125;,]等级与月薪相关, 分别为3倍月薪、2倍月薪、1倍月薪.等级甲乙丙月薪倍率32112345const scaleMap = &#123; '甲': 3, '乙': 2, '丙': 1&#125;到底需要拿出多少钱奖励呢? 甲乙丙三组人分别占比多少呢? 针对这样的需求, 我们尝试着用组合模式计算一下.叶对象与分支对象上面也提到了, 组合模式中有两类对象. 一个是分支对象, 一个是叶对象. 分支对象是叶对象的集合, 保存着叶对象的引用, 可以操作叶对象(比如添加, 执行). 而叶对象只要暴露接口即可.现在我们从简单的开始, 造一个生产叶对象的函数.12345678const leaf = params =&gt; &#123; return &#123; ...params, expense() &#123; return scaleMap[params.scale]*params.salary &#125; &#125;&#125;;分支对象就稍微麻烦些了, 因为需要管理叶对象.1234567891011121314const branch = params =&gt; &#123; return &#123; ...params, members: [], add(item) &#123; this.members.push(item) &#125;, expense() &#123; return this.members.reduce((sum, item) =&gt; &#123; return sum + item.expense() &#125;, 0) &#125; &#125;&#125;;expense() 的方法不论是在分支对象还是叶对象上, 或者说不清楚是分支对象还是叶对象, 我们都可以得到相应的结果. 在分支对象里, 保存着叶对象的引用, 我们可以对叶对象进行任何操作.从JSON数据到树形结构组合模式就是这么简单, 剩下的就是如何 JSON 数据转换成层次分明的结构了.123456789101112131415161718192021222324const convertData = array =&gt; &#123; const branchList = []; const branchObjs = []; array.forEach(item =&gt; &#123; let leafObj = leaf(item); if (!branchList.includes(item.scale))&#123; let params = &#123; scale: item.scale &#125; let branchObj = branch(params) branchObjs.push(branchObj) branchList.push(item.scale) &#125; branchObjs.filter(obj =&gt; obj.scale == item.scale)[0].add(leafObj); &#125;) return branchObjs;&#125;console.log('branchObjs', convertData(persons))const scaleA = convertData(persons)[0];const scaleB = convertData(persons)[1];const scaleC = convertData(persons)[2];console.log('甲', scaleA.expense())console.log('乙', scaleB.expense())console.log('丙', scaleC.expense())最终结果展示如果我们想知道公司的总支出, 也可以把 scaleA, scaleB, scaleC 组合在一起作为公司的一子集.12345const company = branch();company.add(scaleA);company.add(scaleB);company.add(scaleC);company.expense()不难发现, 我们可以随意组装对象而不会影响到其它节点, 任何一个集合或个体都能够单独运行. 我们也可以根据需要去组合更复杂的结构. 但是, 如果通过组合模式创建了太多的对象, 那么这些对象可能会让系统负担不起.小结组合模式对象形式上至少有两种, 分支对象和叶对象.分支对象和叶对象拥有相同的接口, 且对一组叶对象操作具有同步一致性.组合模式是 HAS-A (聚合)关系, 不是 IS-A.]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>组合模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[咬文嚼字说策略]]></title>
    <url>%2F%E5%92%AC%E6%96%87%E5%9A%BC%E5%AD%97%E8%AF%B4%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[设计模式是: 在面向对象软件过程中针对特定问题的简洁而优雅的解决方案. 通过对封装、继承、多态、组合等技术的反复利用, 提炼出可重复使用面向对象的设计技巧.JavaScript 可以模拟实现传统面向对象语言的设计模式. 然而仅仅是生搬硬套, 未免会失去 JavaScript 的灵活性. 不如溯本求源, 看看这些设计模式到底在传达什么, 然后遵循此点.策略模式定义策略模式: 定义一系列的算法, 把它们一个个封装起来, 并且使它们可以相互替换.字面意思, 就是定义封装多种算法, 且各个算法相互独立. 当然, 也不仅仅是算法. 只要定义一些规则, 经处理后输出我们想要的结果就成. 在此我们称单个封装后的算法为一个策略. 一系列封装后的算法称为一组策略.一个基于策略模式的程序至少由两部分组成. 第一部分是一组策略类, 策略类封装了具体的算法, 并负责具体的计算过程. 第二部分是环境类 Context, Context 接受客户的请求, 随后把请求委托给某一个策略类.这是面向传统面向对象语言中的说法. 在面向对象思想中, 通过对组合, 多态等技术的使用来实现一个策略模式. 在 JavaScript 中, 对于一个简单的需求来说, 这么做就有点大材小用了.所以, 上面的那句话, 我们换种说法就是, 策略模式需要至少两部分, 一部分是保存着一组策略. 另一部分则是如何分配这些策略, 即如何把请求委托给某个/些策略. 其实这也是策略模式的目的, 将算法的使用与算法的实现分离.评级快到年底了, 公司打算制定一个标准用来给员工评级发福利.考核项目\等级甲乙丙A100&gt;a&gt;=9090&gt;a&gt;=8080&gt;a&gt;=70B100&gt;b&gt;=9090&gt;b&gt;=8080&gt;b&gt;=70以A、B考核项目来评定甲乙丙等级.现有考核人员:考核项目\考核人person_1person_2person_3A809392B85709012345const persons = [ &#123;A: 80, B: 85&#125;, &#123;A: 93, B: 70&#125;, &#123;A: 92, B: 90&#125;]在策略模式中一部分, 我们提到的分配策略. 要想分配策略, 首先就要知道所有的策略, 只有这样我们才能针对性的委托给某个/些策略. 这, 也是策略模式的一个缺点.常规操作甲乙丙等级对 A、B 的分值要求是不一样的. 所以我们可以这么做:1234567891011121314151617181920function rating(person) &#123; let a = person.A; let b = person.B; if (a &gt;= 90 &amp;&amp; b &gt;= 90) &#123; return '甲'; &#125; else if (a &gt;= 80 &amp;&amp; b &gt;= 80) &#123; return '乙'; &#125; else if (a &gt;= 70 &amp;&amp; b &gt;= 70) &#123; return '丙' &#125; else &#123; console.log('凭啥级, 还不赶紧卷铺走人'); &#125;&#125;persons.forEach(person =&gt; &#123; person.rate = rating(person);&#125;)// &gt; persons// [ &#123; A: 80, B: 85, rate: '乙' &#125;,// &#123; A: 93, B: 70, rate: '丙' &#125;,// &#123; A: 92, B: 90, rate: '甲' &#125; ]策略模式下的评级如果换成策略模式, 第一部分就是保存一组策略. 现在我们以甲乙丙三种定级标准来制定三种策略, 用对象来存贮策略. 考虑到以后可能有 D、E、F 等考核项目的存在, 我们稍微改一下:1234567891011121314151617181920const strategies = &#123; '甲': (person, items) =&gt; &#123; const boolean = items.every(item =&gt; &#123; return person[item] &gt;= 90; &#125;); if (boolean) return '甲'; &#125;, '乙': (person, items) =&gt; &#123; const boolean = items.every(item =&gt; &#123; return person[item] &gt;= 80; &#125;); if (boolean) return '乙'; &#125;, '丙': (person, items) =&gt; &#123; const boolean = items.every(item =&gt; &#123; return person[item] &gt;= 70; &#125;); if (boolean) return '丙'; &#125;&#125;策略就制定好了. 对象的键对应着策略的名称, 对象的值对应着策略的实现. 然而, 我们发现, 任何一个策略都不能单独完成等级的评定. 可是, 我们有说一组策略只能选择其中一个么? 为了达成某个目的, 策略组封装了一组相互独立平等替换的策略. 一个策略不行, 那就组合呗. 这也是策略模式另一部分存在的意义, 即如何分配策略.123456789101112function rating(person, items) &#123; return strategies['甲'](person, items) || strategies['乙'](person, items) || strategies['丙'](person, items)&#125;persons.forEach(person =&gt; &#123; person.rate = rating(person, ['A', 'B'])&#125;)// &gt; persons// [ &#123; A: 80, B: 85, rate: '乙' &#125;,// &#123; A: 93, B: 70, rate: '丙' &#125;,// &#123; A: 92, B: 90, rate: '甲' &#125; ]逻辑的转移所有的设计模式都遵循一条原则. 即 “找出程序中变化的地方, 并将变化封装起来”.将不变的隔离开来, 变化的封装起来. 策略模式中, 策略组对应着程序中不变的地方. 将策略组制定好存贮起来, 然后想着如何去分配使用策略.当然, 如何制定策略和如何分配策略之间的关系十分紧密, 可以说两者相互影响.再次看看制定的策略, “找出程序中变化的地方, 并将变化封装起来”, 我们可以再次改造一下.1234567891011121314151617181920212223242526const strategies = &#123;'甲': 90,'乙': 80,'丙': 70,&#125;function rating(person, items)&#123; const level = value =&gt; &#123; return (person, items) =&gt; &#123; const boolean = items.every(item =&gt; &#123; return person[item] &gt;= strategies[value]; &#125;); if (boolean) return value; &#125; &#125; return level('甲')(person, items) || level('乙')(person, items) || level('丙')(person, items)&#125;persons.forEach(person =&gt; &#123; person.rate = rating(person, ['A', 'B'])&#125;)// &gt; persons// [ &#123; A: 80, B: 85, rate: '乙' &#125;,// &#123; A: 93, B: 70, rate: '丙' &#125;,// &#123; A: 92, B: 90, rate: '甲' &#125; ]在上面的这种做法中, 我们把制定策略的逻辑挪到了分配策略里了. 所以说, 如何制定策略和如何分配策略, 依情况而定.不过回头在看一看这段代码, 是不是和平时用对象映射的做法很相似.当然, 策略模式的用法还有很多, 最常见的是规则校验.小结总结一下:策略模式至少包括两部分, 制定策略和分配策略.策略模式的目的在于, 将策略制定和策略分配隔离开来.策略制定和策略分配关系密切, 相互影响.]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>策略模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初始化空对象数组]]></title>
    <url>%2F%E5%88%9D%E5%A7%8B%E5%8C%96%E7%A9%BA%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[初始化空对象数组在给对象设置属性时, 如果对象不存在很容易报错.有些场景, 在对对象数组处理时, 设置对象属性前判断对象是否存在. 与其这样, 还不如直接初始化为空对象数组.9个考生就来了6个考试时, 每个考生都有自己位置. 考生对照着可以很容易在考场里找到自己的座位. 秉着公平、公正、公开的原则, 考生被稀疏地散布在考场的各个角落. 假设考场 3*3 排列, 考生的信息:123456[&#123;"row":1,"col":1,"name":"Ada"&#125;, &#123;"row":3,"col":3,"name":"Aaron"&#125;, &#123;"row":1,"col":2,"name":"Aditi"&#125;, &#123;"row":3,"col":2,"name":"Aditi"&#125;, &#123;"row":1,"col":3,"name":"Aditi"&#125;, &#123;"row":3,"col":1,"name":"Abbott"&#125;]将考场位置做成一个表格, 对考生位置按排统计, 来标注考生出勤情况.123[&#123;"row":1,"col_1":"Ada","col_2":"Aditi","col_3":"Aditi"&#125;, &#123;&#125;, &#123;"row":3,"col_3":"Aaron","col_2":"Aditi","col_1":"Abbott"&#125;](为嘛没有第二排? 自知考不过, 缺考了呗🙁)开发中, 对原始数据进行处理是一件很平常的事. so, 这个数据的处理应该很简单…吧😅Array(3).fill({}) 试一波如何初始化空对象数组?原始数据是以学生个体的信息存储展示的, 现在则按排为单位对数据进行处理. 理所当然的会想到先初始化三个空对象数组.123let studentRow = Array(3).fill(&#123;&#125;)// &gt; studentRow// [ &#123;&#125;, &#123;&#125;, &#123;&#125; ]动作很快姿势很帅. 不过, 这样真的可以么? 长得倒是像那么一回事, 可实际上完全行不通. Array.prototype.fill() 的用法是, 指定某个值来填充数组.也就是说, {} 在 studentRow 里复制了三次. 如果是简单类型值倒也罢了, 但是换做复杂类型值, 修改每一个 {} , 都会影响其它的 {}. 因为它们都是对同一个对象的引用.1234567891011121314151617let studentRow = Array(3).fill(&#123;&#125;);studentRow[0].name = 'tony';// &gt; studentRow// [ &#123; name: 'tony' &#125;,// &#123; name: 'tony' &#125;,// &#123; name: 'tony' &#125; ]// 等同于let obj = &#123;&#125;;let studentRow = Array(3).fill(obj);// &gt; studentRow// &#123;obj, obj, obj&#125;studentRow[0].name = 'tony';// &gt; studentRow// [ &#123; name: 'tony' &#125;,// &#123; name: 'tony' &#125;,// &#123; name: 'tony' &#125; ]知识点:将一个值赋予变量时, 解析器必须确定这个值是基本类型值还是复杂类型值.当是复杂类型值时, 变量里保存的是该复杂类型值在堆中的一个指针. 复制的是变量的指针, 操作的却是实际的对象.Array(3) 和 map(() =&gt; {}) 结合有问题Array(3).fill({}) 行不通. 那么, Array(3).map(() =&gt; {})?如果说 Array(3).fill({}) 不可行, 是因为三个空对象是对同一个对象的引用. 那么我们就设法返回三个不同的空对象.123let studentRow = Array(3).map(() =&gt; &#123;&#125;);// &gt; studentRow// [ &lt;3 empty items&gt; ]结果很失望, 这个表达式就干了两件事, Array(3) 和 map(() =&gt; {}). 所以问题很好排查.123let arr = Array(3);// &gt; arr// [ &lt;3 empty items&gt; ]对于数组中并不存在的单元, map() 也是束手无策.我说: 肚里要有货🙏肚里没货, 我们就造一些. Array.prototype.fill() 又有出头之日了.123let studentRow = Array(3).fill(undefined);// &gt; studentRow// [ undefined, undefined, undefined ]警告:如若一个数组没有任何单元, 但它的 length 属性中却显示有单元数量, 这样奇特的数据结构会导致一些怪异的行为. 我们将包含至少一个 “空单元” 的数组称之为 “稀疏数组”. undefined 单元非 “空单元”.永远不要创建和使用空单元数组.箭头函数中的 return你以为 Array(3).fill(undefined).map(() =&gt; {}) 就完事了? 图样图森破 👼123let studentRow = Array(3).fill(undefined).map(() =&gt; &#123;&#125;);// &gt; studentRow// [ undefined, undefined, undefined ]哦, 我知道了, 你没有 return 啊额, 这和 return 没有关系. 不信你可以加一个试试😏其实, {} 在这里被视作语法块了, 没有任何意义. 可恨就可恨在, 它和空对象长得一摸一样.既然这样, 那我们就不用字面量定义一个空对象了.1234let studentRow = Array(3).fill(undefined).map(() =&gt; Object.create(null));studentRow[0].name = 'tony';// &gt; studentRow// [ &#123; name: 'tony' &#125;, &#123;&#125;, &#123;&#125; ]这样就达到初始化对象数组的目的了. 可是, Array(3).fill(undefined).map(() =&gt; {}) 为什么行不通, 如何补救?规避问题在某种意义上不等于解决问题.{...} 里面的代码会被解析为一系列语句. {} 也因此不能达到我们预期的结果. 所以, 我们可以用 (...) 将 {} 包装成表达式, 即 ({}).1234let studentRow = Array(3).fill(undefined).map(() =&gt; (&#123;&#125;));studentRow[0].name = 'tony';// &gt; studentRow// [ &#123; name: 'tony' &#125;, &#123;&#125;, &#123;&#125; ]知识点:若函数体的表达式个数多于一个, 或者函数题包含非表达式语句的时候才需要用 {...} 包裹.如果只有一个表达式, 并且省略了 {...} 的话, 则附加一个隐式 return. 若在块体内需要指定返回值, 则需要明确的 return.箭头函数提供了简练的语法, 但不是普通函数的替代品. 箭头函数的主要设计目的是改变 this 的行为. 普通函数内的 this 是动态绑定, this 指向谁取决于调用者. 而箭头函数里的 this 是基于作用域的, 是可预测的.(可参考从游戏角度说作用域).令人绝望的Array.prototype.fill()你以为结束了, 其实才刚刚开始这是真正的开始, 没看错, 是的, 我们之前所做的可能都是无用功.是的, IE 是魔鬼. 费尽了周折, 才发现一切都是徒劳.难道就这么放弃了?‘放弃’能吃么? 能吃就吃了它, 啥? 不能吃?!? 提它作甚!!!Array.prototype.fill() 方便之处就是能够简便填充数组. 此法不行, 另寻他法.Function.prototype.apply() 了解一下Function.prototype.apply() 入参有两个. 第一个参数是 函数方法 的调用者, 第二个参数是 函数方法 的入参(要区分入参和入参的不同). 函数方法 的入参可以是数组也可以是类数组. 我们的目的就是填充数组, 所以我们要在类数组上做文章. 就拿 console.log 做例子🌰. (直接复制我之前的博客内容😌).1234567891011121314151617function log_1(arg) &#123;console.log(arg)&#125;log_1(1);log_1(1,2,3);// 1// 1// 改造下function log_2() &#123; const log = console.log; log.apply(null, arguments)&#125;log_2(1);log_2(1, 2, 3)// 1// 1 2 3这是 Function.prototype.apply() 使用的方法. 如果我们把 log_2 里的 arguments 换成 {length: 3},123456function log_2() &#123; const log = console.log; log.apply(null, &#123;length: 3&#125;)&#125;log_2()// undefined undefined undefined{length: 3} 和 [undefined, undefined, undefined] 在传入 apply(null;...) 后, 在参数的处理上, 最后的结果是一样的.那么, Array(3).fill(undefined).map(() =&gt; ({})) 可改造成,1234let studentRow = Array.apply(null, &#123;length: 3&#125;).map(() =&gt; (&#123;&#125;));studentRow[0].name = 'tony';// &gt; studentRow// [ &#123; name: 'tony' &#125;, &#123;&#125;, &#123;&#125; ]在这里 Array 作为普通函数调用, 以上等同于123let studentRow = Array(undefined, undefined, undefined);// &gt; studentRow// [ undefined, undefined, undefined ]收尾只是初始化一个空对象数组, 结果整出这么多幺蛾子.处理数据其实就那么几行代码. 大致长这模样,12345678function handleData(params) &#123; const studentRow = Array.apply(null, &#123;length: 3&#125;).map(() =&gt; (&#123;&#125;)); params.forEach(item =&gt; &#123; studentRow[item.row-1][`row`] = item.row; studentRow[item.row-1][`col_$&#123;item.col&#125;`] = item.name; &#125;) return studentRow;&#125;]]></content>
      <categories>
        <category>天坑也填坑</category>
      </categories>
      <tags>
        <tag>空对象数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从游戏角度说作用域]]></title>
    <url>%2F%E4%BB%8E%E6%B8%B8%E6%88%8F%E8%A7%92%E5%BA%A6%E8%AF%B4%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[作用域作用域是 JavaScript 里的一个非常重要和基础的概念. 很多人认为自己理解了作用域, 但是在遇到闭包时却说不出个所以然, 甚至不能识别出来.闭包也是个非常重要, 且经常被误解的概念. 然而闭包就是基于作用域书写代码时所产生的自然结果. 倘若抛开作用域讲闭包, 那都是耍流氓. 闭包可以说在平时的代码里随处可见, 但真正让闭包发挥积极作用的做法是隔离作用域、模块函数等.作用域机制是不能直接查看的, 我们首先模拟一个场景来尽可能的说明作用域这套规则, 然后通过代码片段和开发者工具进行验证.游戏存档想必大家都有玩过游戏的经验. 刚开始的时候, 也就是第一关, 难度比较简单. 到了第二关的时候, 就在第一关的基础上加些难缠的角色, 难度相应地加大了. 关卡越是往后, 难缠的角色也就会越来越多.可在游戏的时候, 由于各种原因, 往往我们不可能一下子通过所有的关卡, 所以游戏提供了存档的功能. 下次再玩的时候可以从存档里续上. 如果不想这样, 完全可以从头玩起.为什么我们能从存档里直接跳到上次的关卡, 很显然, 这里是有记录存储的. 比如第一关有个场景食人花和海王, 第二关又多了个邪恶人等等. 每个关卡都会记录该关卡新增的角色或场景同时也会存储之前关卡的记录. 这样就保证了不同的存档的独立性, 无论在哪个关卡存档, 下次也定会续上之前的地方. 当然了, 我们也可以回到上一个关卡.(海王之雄风&amp;敌人之邪恶)几个知识点结合上面的场景, 我们再回头看看以下几个知识点.标识符: 变量、函数、属性的名字, 或者函数的参数.每个函数都有自己的执行环境. 当执行流进入一个函数时, 函数的环境就会被推入一个环境栈中. 而在函数执行后, 栈将其环境弹出, 把控制权返回之前的执行环境.执行环境定义了变量或函数有权访问的其它数据. 每个执行环境都有一个与之关联的变量对象, 环境中定义的所有变量和函数都保存在这个对象中. 某个执行环境中的所有代码执行完毕后, 该环境被销毁, 保存在其中的所有变量和函数定义也随之销毁.当代码在一个环境中执行时, 会创建变量对象的一个作用域链.作用域链是保证对执行环境有权访问的所有变量和函数的有序访问. 作用域的前端始终都是当前执行的代码所在的变量对象. 如果这个环境是函数, 则将其活动对象作为变量对象. 活动对象在最开始只包含一个变量, 即 arguments 对象. 作用域链中的下一个变量对象来自包含(外部)环境. 全局执行环境的变量对象始终都是作用域链的最后一个对象.当某个环境中为了读取或写入而引入一个标识符时, 必须通过搜索来确定该标识符来确定该标识符实际代表什么. 搜索过程从作用域链的前端开始, 向上逐级查询与给定名字匹配的标识符. 如果在局部环境中找到了该标识符, 搜索过程停止, 变量就绪. 如果在局部环境中没有找到该变量名, 则继续沿作用域链向上搜索. 搜索过程将一直追溯到全局环境的变量对象. 如果在全局环境中也没有找到这个标识符, 则意味着该变量尚未声明.作用域链本质上时一个指向变量对象的指针列表, 它只引用但实际不包含变量对象.如果我们把以上的几个知识点串起来, 这就是所谓的作用域链规则了. 上图解释一波.(arguments 应该加到变量对象里的, 图中没体现, 疏忽)现在我们从最后两行说起,12var outer = outerFn(10);var inner = outer(10);执行 outer = outerFn(10) 后, outer 拥有了返回函数的引用. outer(10) 在执行的时候它会创建 属于它自己 的作用域链, 这里包含函数所处外部环境的变量对象.在读取 initial 变量时, 在 Inner 变量对象中没有检索到, 它会沿着作用域链向上搜索, 在 outer 变量对象里找到了该标识符, 搜索过程停止, 变量就绪.函数在定义的时候就已经决定了之后执行时, 作用域里将包含什么. 这也解释了, 即使我们把定义在函数内部的函数扔在外边执行也能访问到函数内部的变量. 这和内部函数在哪执行没有半毛钱关系.为什么强调 属于它自己 的呢?12345678910111213function outer() &#123; var num = 0; return function inner() &#123; return num++; &#125;&#125;let innerFn_1 = outer();let a_1 = innerFn_1()let innerFn_2 = outer();let a_2 = innerFn_2();let a_1_1 = innerFn_1();let a_2_2 = innerFn_2();innerFn_1 和 innerFn_2 都属于自己的作用域链, 而 a_1 和 a_2 则分别在 innerFn_1 和 innerFn_2 上创建了属于自己的作用域链. 所以它们函数里的 num 是属于不同作用域链里的变量. 但对于 a_1 和 a_1_1 来说它们都是基于 innerFn_1, 拥有同一 outer 变量对象, num 自然也是同一个, 所以会累加. 同理 a_2 和 a_2_2.如果理解了这个, 那么面试常考的一题就小菜一碟了.12345for(var i = 1; i &lt;= 5; i++) &#123; setTimeout(function timer() &#123; console.log(i); &#125;, i*1000)&#125;重点是执行的时候才会创建变量对象的一个作用域链.闭包是什么?如果理解了以上的概念, 就会觉得闭包是作用域埋的一个彩蛋, 用的好就是惊喜, 用的不好就成惊吓了.当函数可以记住并访问所在的作用域, 即使函数是在当前作用域之外执行, 这时就产生了闭包. 这就和之前提到的游戏存档差不多.好了, 扔几个闭包出来巩固一下.12345678910function outer_1() &#123; var a = 'hello world'; function inner() &#123; console.log(a) &#125; outer_2(inner)&#125;function outer_2(fn) &#123; fn()&#125;这里也有闭包.12345678var a = new array(99999999);function b() &#123; console.log(b)&#125;b()body.addEventListener('click', function() &#123; console.log('hello world')&#125;)还有开头所说的可以结合开发者工具直观地看一下, 一张动态图解释一切.内存泄漏闭包之所以能成为闭包, 是因为它记录了函数所在的作用域. 现主流的自动垃圾收集机制正因为闭包的这个特点而不能释放内存. 闭包的滥用会导致导致内存能分配的空间变少, 最终崩溃.正常来说, 函数在执行的过程中, 局部变量会被分配相应的内存空间, 以便存储它们的值, 直至函数执行结束. 此时局部变量占有的空间会被释放以供将来使用.常说的回收机制之一, 标记清除, 它的工作原理是, 当变量进入执行环境时, 储存在内存中的所有变量都会被加上标记(至于什么标记我们不关心), 然后找到 环境中的变量 以及 被环境中引用的变量, 把它们之前加的标记给去掉. 而剩下的被标记的变量将被视为 准备 删除的变量. 最后, 垃圾收集器找出不再继续使用的变量, 释放其占用的内存. 所以, 一旦数据不再被需要, 应解除引用, 将其值设置为null.12outer = null;inner = null;内部函数的执行环境会保存着外部环境活动对象的引用, 内部函数被扔出去后, 就意味着外部环境不能被销毁了.this执行环境里记录的不只是这些, 它也记录了函数调用栈、函数调用方式等. this 和作用域有关系, 但不是你们想象的那种关系. 每个函数在被调用时都会自动取得两个特殊变量: this 和 arguments. 内部函数在搜索这两个变量时, 只会搜索到其活动对象为止(即当前变量对象). 因此永远不可能直接访问到外部函数中的这两个变量. 除非我们把外部作用域中的 this 对象保存在一个闭包能够访问到的变量里.123456789// 很常见是不是😂let obj = &#123; a: function() &#123; var self = this; return function() &#123; console.log(self) &#125; &#125;&#125;函数内部的 this 在函数执行时才正式被赋予相应的值, 所以说函数的调用位置很关键. 可以这么说, 谁 直接 调用了这个函数, this 就指向了谁. 如果不是对象在直接调用这个函数, 我们可统统认为是 undefined, 非严格模式浏览器环境下就是 window. 如果真想知道为什么, 可以直接看规范(神烦).1234567891011121314151617181920'use strict'function a() &#123; console.log(this)&#125;var b = &#123; a: function() &#123; console.log(this); &#125;, b: function() &#123; return a; &#125;&#125;let b_a = b.a;a(); //1. undefined;b_a(); //2. undefined;b.a(); //3. &#123;a: f, b: f&#125;;b.b()(); //4. undefined;(true &amp;&amp; b.a)() //5. undefined;new a(); //6. &#123;&#125;b.call(b); //7. &#123;a: f, b: f&#125;;从 1~6, 我们看看哪个对象直接调用了该函数. 第 1 个没找到调用对象, 就是个普通函数调用. 第 2 个经过 b_a = b.a 赋值操作后, 返回的就是那个普通函数, 就是一普通的函数调用. 第 3 个很直接, 就是 b 这个对象了. 第 4 个是个闭包, 首先 this 只在当前活动对象里找 this 对象, 不知道是哪个对象, 但肯定不会是 b. 第 5 个和第 2 个是一个道理. 第 6 个吧, 貌似不算是函数调用了吧, 不过我们知道, this 是指向新创建的空对象. 第 7个就更直接了, 人家都指名道姓就差喊出来了.this 绑定对象的几条准则貌似在我这里就只剩一条了😌.]]></content>
      <categories>
        <category>很难么</category>
      </categories>
      <tags>
        <tag>闭包</tag>
        <tag>作用域</tag>
        <tag>this</tag>
        <tag>内存泄漏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Object原型方法]]></title>
    <url>%2FObject%E5%8E%9F%E5%9E%8B%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[ObjectObject 构造函数用来包装成对象.概述Object 构造函数为给定值创建一个对象包装器. 如果给定值是 null 或 undefined, 将会创建并返回一个空对象. 否则, 将返回一个与给定值对应类型的对象.当以非构造函数形式被调用时, Object 等同于 new Object().原型方法Object.prototype.hasOwnProperty()描述 : 判断自身属性中是否有指定的属性.语法 :target.prototype.hasOwnProperty(prop)target : 目标对象.prop : 要检测的属性.123456789101112function Person(name) &#123; this.name = name&#125;Person.prototype.age = 18let person = new Person('yexiaochen')let boolean_1 = person.hasOwnProperty('name')let boolean_2 = person.hasOwnProperty('age')// &gt; boolean_1// true// &gt; boolean_2// falseObject.prototype.isPrototypeOf()描述 : 判断一个对象是否在另一个对象的原型链上.语法 :prototypeObject.isPrototypeOf(obj)obj : 提供原型链的对象.prototypeObject : 待检测的对象.123456789101112function Person() &#123;&#125;function Man()&#123;&#125;Man.prototype = Object.create(Person.prototype)let man = new Man()let boolean_1 = Person.prototype.isPrototypeOf(man)let boolean_2 = Man.prototype.isPrototypeOf(man)// &gt; boolean_1// true// &gt; boolean_2// trueObject.prototype.propertyIsEnumerable()描述 : 判断对象的指定属性是否可枚举. 原型链上继承来的属性除外. 如果对象没有指定的属性，则此方法返回false语法 :target.propertyIsEnumerable(prop)target : 目标对象.sources : 待检测的属性.123456789101112function Person(name) &#123; this.name = name&#125;Person.prototype.age = 18let person = new Person('yexiaochen')let boolean_1 = person.propertyIsEnumerable('name')let boolean_2 = person.propertyIsEnumerable('age')// &gt; boolean_1// true// &gt; boolean_2// falseObject.prototype.toString()描述 : 一个表示该对象的字符串语法 :target.toString()target : 目标对象.1234567891011function Person() &#123;&#125;let person = new Person()let str_1 = person.toString();let str_2 = Object.prototype.toString.call(person)let str_3 = Object.prototype.toString.call(Person)// &gt; str_1// '[object Object]'// &gt; str_2// '[object Object]'// &gt; str_3// '[object Function]'Object.prototype.valueOf()描述 : 对象转换为原始值. 如果对象没有原始值, 返回对象本身.语法 :target.valueOf()target : 目标对象.123456789101112131415161718192021222324let str = new String('hello world')let num = new Number(0)let boolean = new Boolean(true)let arr = [1,2,3]let func = function a()&#123;&#125;let obj = &#123;a: 'hello'&#125;str.valueOf()num.valueOf()boolean.valueOf()arr.valueOf()func.valueOf()obj.valueOf()// &gt; str.valueOf()// 'hello world'// &gt; num.valueOf()// 0// &gt; boolean.valueOf()// true// &gt; arr.valueOf()// [ 1, 2, 3 ]// &gt; func.valueOf()// [Function: a]// &gt; obj.valueOf()// &#123; a: 'hello' &#125;]]></content>
      <categories>
        <category>API总结</category>
      </categories>
      <tags>
        <tag>Object</tag>
        <tag>对象原型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对象属性的属性]]></title>
    <url>%2F%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E7%9A%84%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[引子vue 的大行其道, 使得 Object.defineProperty 被更多人所认识. vue 利用 Object.defineProperty 提供的特性实现了数据绑定. 我们也可以据此动手实现一个简单的数据绑定(可参照进击的观察者模式).难道 Object.defineProperty 能做的只有这些么? 很显然不是.属性描述符The Property Descriptor type is used to explain the manipulation and reification of Object property attributes.属性描述符到底是什么? 说白了就是对象属性的属性解释与具化, 就是对象属性本身具有哪些属性.平时我们创建一个对象并为对象添加属性时, 可以这样12let obj = new Object()obj.a = 'hello world'有了对象字面量后, 想要达到同样的效果就更加省事了. 现在也都提倡使用字面量来创建对象.123let obj = &#123; a: 'hello world'&#125;所以说程序员都是懒人嘛, 怎么简单怎么来. 通过 Object.defineProperty 为对象添加属性的方式也就淡出人们的视野.同样是为对象添加属性, 它们有什么区别呢?程序员身体可以懒, 但脑子要勤快, 要始终保持一颗好奇心.其实不论是通过赋值, 还是通过字面量, 还是通过 Object.defineProperty, 最终还是殊途同归.讲真, 平时的开发中, 使用对象字面量创建对象并添加属性时,压根就不会考虑到对象属性非个人意愿的改变了. 在我们看来, 对象就是存储着键值、键值映射用的. 我们可以任意添加, 删除, 更改对象属性, 我们认为这是理所当然的. 现实也的确如此, 你有对它为所欲为的权利.添加属性的差异可是为什么呢?🧐😠你哪来的那么多为什么? 你为什么为什么呢!!!😠如果你稍微对 Object.defineProperty 有点了解, 应该知道通过这种方式定义的繁琐. 你也应该知道对象属性的操作也是有限制的. 想要放开权限, 我们需要这样做1234567let obj = &#123;&#125;Object.defineProperty(obj, 'a', &#123; value: 'hello world', configurable: true, enumerable: true, writable: true&#125;)对象字面量添加属性只是默认都为 true. 所以我们才可以为所欲为. 不相信么? 我们可以通过 Object.getOwnPropertyDescriptor 验证一下12345678let obj = &#123;&#125;obj.a = 'hello world'let property = Object.getOwnPropertyDescriptor(obj, 'a')// &gt; property// &#123; value: 'hello world',// writable: true,// enumerable: true,// configurable: true &#125;通过 Object.getOwnPropertyDescriptor 添加的属性, 可以自由灵活地设置属性描述符. 如果我不想配置的话, 它也有自己的默认值. 需要注意的是, 这里的默认值和对象字面量添加属性与赋值属性不同, 默认值为 false.12345678910let obj = &#123;&#125;Object.defineProperty(obj, 'a', &#123; value: 'hello world'&#125;)let property = Object.getOwnPropertyDescriptor(obj, 'a')// &gt; property// &#123; value: 'hello world',// writable: false,// enumerable: false,// configurable: false &#125;属性描述符等位数据描述符和访问描述符. 以上说的都是数据描述符.传闻中的Vue优化方案道理我都懂, 那你这句话是啥个意思?压根就不会考虑到对象属性非个人意愿的改变了.在 Vue 的 data 选项中，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 中的访问描述符 get/set 访问描述符重新定义一遍. 再结合观察者模式, 每次属性变化时都会收到通知, 从而达到数据绑定的效果. 显然并不是所有的属性都需要被转换监听.对于展示型的数据, 就没有必要也不会出现数据内部属性的变化, 所以没必要做以上的处理. Object.freeze (用法可见Object构造函数)处理后的对象, 就可以使得对象属性添加、修改等操作失效. 这样不去转换也不用去监听, 性能自然也就提高了.属性描述符键值枯燥的描述开始…数据描述符和访问描述符同事具有的键值configurable : 若为 false, 不能删除该属性, 不能切换属性描述符(数据描述符切到访问描述符,或访问描述符切到数据描述符), 不能更改该属性的属性(对于数据描述符来说, value 属性除外, Writable 属性从 true 置为 false 除外). 说白了就是属性描述符的开关, 管理着该属性的属性.123456789101112131415161718192021222324252627282930313233let obj = &#123;&#125;Object.defineProperty(obj, 'a', &#123; value: 'hello world', configurable: false, enumerable: true, writable: true&#125;)Object.defineProperty(obj, 'a', &#123; value: 'hi world',&#125;)let property_1 = Object.getOwnPropertyDescriptor(obj, 'a')Object.defineProperty(obj, 'a', &#123; value: 'hi world', writable: false&#125;)let property_2 = Object.getOwnPropertyDescriptor(obj, 'a')// &gt; property_1// &#123; value: 'hi world',// writable: true,// enumerable: true,// configurable: false &#125;// &gt; property_2// &#123; value: 'hi world',// writable: false,// enumerable: true,// configurable: false &#125;Object.defineProperty(obj, 'a', &#123; value: 'hi world', configurable: false, enumerable: false&#125;)// TypeErrorenumerable : 若为 true, 则在 for…in 枚举中可被枚举到.1234567891011let obj = &#123; a: 'hello world', b: 'hi world'&#125;Object.defineProperty(obj, 'c', &#123; value: 'hey world', enumerable: false&#125;)let propertyArray = Object.keys(obj)// &gt; propertyArray// [ 'a', 'b' ]仅数据描述符具有的键值value : 对象的该属性对应的值. 可以为任何有效的 JavaScript 值.writable : 若为false, 更改 value 将会失败.12345678910111213141516171819202122let obj = &#123;&#125;Object.defineProperty(obj, 'a', &#123; value: 'hello world', writable: false, configurable: true&#125;)obj.a = 'hi world'let property_1 = Object.getOwnPropertyDescriptor(obj, 'a')Object.defineProperty(obj, 'a', &#123; value: 'hey world'&#125;)let property_2 = Object.getOwnPropertyDescriptor(obj, 'a')// &gt; property_1// &#123; value: 'hello world',// writable: false,// enumerable: false,// configurable: true &#125;// &gt; property_2// &#123; value: 'hey world',// writable: false,// enumerable: false,// configurable: true &#125;从运行结果可以看出, 通过赋值更改属性值时, 会更改无效.但是通过 Object.defineProperty 更改时, 将会成功更改属性值. 对此, 规范有提到, 当可配置不可写时更改属性值,会有 Writable 置为 true, =&gt; 设置 value =&gt; Writable 置为 false.Step 8.b allows any field of Desc to be different from the corresponding field of current if current’s [[Configurable]] field is true. This even permits changing the [[Value]] of a property whose [[Writable]] attribute is false. This is allowed because a true [[Configurable]] attribute would permit an equivalent sequence of calls where [[Writable]] is first set to true, a new [[Value]] is set, and then [[Writable]] is set to false.通过赋值和 Object.defineProperty 方式修改 value, 可以看出它们内部操作还是存在着差异.仅访问描述符具有的键值get : 访问该属性时, 该方法都会被执行.set : 修改该属性时, 该方法都会被执行.vue 就是利用了访问描述符的这些特性, 实现了数据绑定.12345678910111213141516171819202122let obj = &#123;&#125;let valObject.defineProperty(obj, 'a', &#123; set(value) &#123; val = value console.log('set =&gt; value', val) &#125;, get() &#123; console.log('get =&gt; value', val) return val &#125;, configurable: true, enumerable: true&#125;)// &gt; obj// &#123; a: [Getter/Setter] &#125;// &gt; obj.a = 'hello world'// set =&gt; value hello world// 'hello world'// &gt; obj.a// get =&gt; value hello world// 'hello world']]></content>
      <categories>
        <category>API总结</category>
      </categories>
      <tags>
        <tag>属性描述符</tag>
        <tag>defineProperty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Object构造函数]]></title>
    <url>%2FObject%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[ObjectObject 构造函数用来包装成对象.概述Object 构造函数为给定值创建一个对象包装器. 如果给定值是 null 或 *undefined, 将会创建并返回一个空对象. 否则, 将返回一个与给定值对应类型的对象.当以非构造函数形式被调用时, Object 等同于 new Object().构造函数方法Object.keys()描述 :获取给定对象自身可枚举属性(字符串)组成的数组.Object.keys(target)target : 目标对象.12345678910111213141516171819let obj = &#123; a: 'hello'&#125;Object.defineProperty(obj, 'b', &#123;value: 'world'&#125;)let property_1 = Object.getOwnPropertyDescriptor(obj, 'a')let property_2 = Object.getOwnPropertyDescriptor(obj, 'b')let propertyArray = Object.keys(obj);// &gt; property_1// &#123; value: 'hello',// writable: true,// enumerable: true,// configurable: true &#125;// &gt; property_2// &#123; value: 'world',// writable: false,// enumerable: false,// configurable: false &#125;// &gt; propertyArray// [ 'a' ]Object.values()描述 :获取给定对象自身可枚举属性值组成的数组.Object.values(target)target : 目标对象.12345678910111213141516171819202122let obj = &#123; a: 'hello', b: () =&gt; &#123; console.log('hello') &#125;&#125;Object.defineProperty(obj, 'c', &#123;value: 'world'&#125;)let property_1 = Object.getOwnPropertyDescriptor(obj, 'a')let property_2 = Object.getOwnPropertyDescriptor(obj, 'c')let valuesArray = Object.values(obj);// &gt; property_1// &#123; value: 'hello',// writable: true,// enumerable: true,// configurable: true &#125;// &gt; property_2// &#123; value: 'world',// writable: false,// enumerable: false,// configurable: false &#125;// &gt; valuesArray// [ 'hello', [Function: b] ]Object.entries()描述 :由给定对象自身可枚举属性的键值对数组组成的数组. 属性的顺序与通过 for...in 循环对象的属性值所给出的顺序相同.语法 :Object.entries(target)target : 目标对象.1234567891011let obj_1 = &#123; a: 'hello', b: 'word'&#125;let obj_2 = Object.entries(obj_1)// &gt; obj_2// [ [ 'a', 'hello' ], [ 'b', 'word' ] ]let map = new Map(obj_2)// &gt; map// Map &#123; 'a' =&gt; 'hello', 'b' =&gt; 'word' &#125;Object.create()描述 :创建一个新对象, 并将内部属性 [[Prototype]] 指向源对象.语法 :Object.create(sources[, Properties])sources : 提供原型的源对象.Properties : 为新对象添加属性, 规则如同 Object.defineProperties(obj, Prototype).1234567let obj_1 = &#123; a: 'hello', b: 'word'&#125;let obj_2 = Object.create(obj_1, &#123;name: &#123;value: 'obj_2'&#125;&#125;)&gt;obj_2// &#123;name: 'obj_2', _proto_: &#123;a: 'hello', b: 'word'&#125;&#125;Object.assign()描述 :将源目标(一个或多个)对象中的所有可枚举属性值复制到目标对象中. 如果目标对象和源对象中存在相同的属性(键), 后者的属性将覆盖前者的属性. 最终返回目标对象.语法 :Object.assign(target, ..sources)target : 目标对象.sources : 源对象.1234567891011121314151617181920212223let obj_1 = &#123; a: 'hello', b: 'word'&#125;let copy = Object.assign(&#123;&#125;, obj)// &gt; copy// &#123; a: 'hello', b: 'word' &#125;// &gt; obj_1// &#123; a: 'hello', b: 'word' &#125;// &gt; copy === obj_1// falselet obj_2 = &#123; a: 'hi', b: 'world'&#125;let obj_3 = &#123; a: 'hello', b: 'world'&#125;Object.assign(obj_2, obj_3)// &gt; obj_2// &#123; a: 'hello', b: 'world' &#125;Object.defineProperty()描述 :为对象定义一个新属性或修改现有属性.语法 :Object.defineProperty(target, prop, descriptor)target : 要在其上定义或修改属性的目标对象.prop : 要定义或修改的属性属性名称.descriptor : 将被定义或修改的属性描述符.123456789101112131415let obj = &#123;&#125;Object.defineProperty(obj, 'a', &#123; value: 'hello world', configurable: false, enumerable: true, writable: true&#125;)let property = Object.getOwnPropertyDescriptor(obj, 'a')// &gt; obj// &#123; a: 'hello world' &#125;// &gt; property// &#123; value: 'hello world',// writable: true,// enumerable: true,// configurable: false &#125;Object.defineProperties()描述 :为对象定义一个新属性或修改现有属性.语法 :Object.defineProperties(target, propsDescriptor)target : 要在其上定义或修改属性的目标对象.propsDescriptor : 将被定义或修改的属性描述符对象.1234567891011121314151617181920212223242526272829let obj = &#123;&#125;Object.defineProperties(obj, &#123; 'a': &#123; value: 'hello world', configurable: false, enumerable: true, writable: true &#125;, 'b': &#123; value: 'hi world', configurable: false, enumerable: true, writable: true &#125;&#125;)let property_a = Object.getOwnPropertyDescriptor(obj, 'a')let property_b = Object.getOwnPropertyDescriptor(obj, 'b')// &gt; obj// &#123; a: 'hello world', b: 'hi world' &#125;// &gt; property_a// &#123; value: 'hello world',// writable: true,// enumerable: true,// configurable: false &#125;// &gt; property_b// &#123; value: 'hi world',// writable: true,// enumerable: true,// configurable: false &#125;Object.getOwnPropertyDescriptor()描述 :获取指定对象上某个自有属性对应的属性描述符.(自有属性即直接赋予该对象的属性, 非原型链继上查找到的属性)语法 :Object.getOwnPropertyDescriptor(target, prop)target : 目标对象.prop : 目标对象的属性名称.123456789101112131415161718192021let obj_1 = &#123; a: 'hello', b: &#123; c: 'world' &#125;, get c() &#123; return 'c' &#125;&#125;let obj_2 = Object.getOwnPropertyDescriptor(obj_1, 'a')let obj_3 = Object.getOwnPropertyDescriptor(obj_1, 'c')// &gt; obj_2// &#123; value: 'hello',// writable: true,// enumerable: true,// configurable: true &#125;// &gt; obj_3// &#123; get: [Function: get c],// set: undefined,// enumerable: true,// configurable: true &#125;Object.getOwnPropertyNames()描述 :获取指定对象的所有自有属性的属性名(包括不可枚举属性但不包括 Symbol 值作为名称的属性)组成的数组.语法 :Object.getOwnPropertyNames(target)target : 目标对象.prop : 目标对象的属性名称.123456789101112let obj_1 = &#123; a: 'hello', b: &#123; c: 'world' &#125;, get c() &#123; return 'c' &#125;&#125;let arr = Object.getOwnPropertyNames(obj_1)// &gt; arr// [ 'a', 'b', 'c' ]Object.getOwnPropertySymbols()描述 :获取给定对象所有的 Symbol 属性的数组.语法 :Object.getOwnPropertyNames(target)target : 目标对象.123456let obj = &#123;&#125;let a = Symbol('a')obj[a] = 'hello'var arr = Object.getOwnPropertySymbols(obj)// &gt; arr// [ Symbol(a) ]Object.preventExtensions()描述 :使得对象变得不可扩展. 即设置对象内部 [[Extensible]] 值为 false.Object.preventExtensions(target)target : 目标对象.12345678910111213141516171819202122232425let obj_1 = &#123; a: 'hello', b: &#123; c: 'world' &#125;&#125;let property_1 = Object.getOwnPropertyDescriptor(obj_1, 'a')let boolean_1 = Object.isExtensible(obj_1)Object.preventExtensions(obj_1)let property_2 = Object.getOwnPropertyDescriptor(obj_1, 'a')let boolean_2 = Object.isExtensible(obj_1)// &gt; property_1// &#123; value: 'hello',// writable: true,// enumerable: true,// configurable: true &#125;// &gt; property_2// &#123; value: 'hello',// writable: true,// enumerable: true,// configurable: true &#125;// &gt; boolean_1// true// &gt; boolean_2// falseObject.seal()描述 :使得对象变得不可扩展. 即设置对象内部 [[Extensible]] 值为 false. 对象属性的 [[Configurable]] 为 false.Object.seal(target)target : 目标对象.12345678910111213141516171819202122232425let obj_1 = &#123; a: 'hello', b: &#123; c: 'world' &#125;&#125;let property_1 = Object.getOwnPropertyDescriptor(obj_1, 'a')let boolean_1 = Object.isExtensible(obj_1)Object.seal(obj_1)let property_2 = Object.getOwnPropertyDescriptor(obj_1, 'a')let boolean_2 = Object.isExtensible(obj_1)// &gt; property_1// &#123; value: 'hello',// writable: true,// enumerable: true,// configurable: true &#125;// &gt; property_2// &#123; value: 'hello',// writable: true,// enumerable: true,// configurable: false &#125;// &gt; boolean_1// true// &gt; boolean_2// falseObject.freeze()描述 :冻结一个对象, 将不能向该对象添加新的属性, 不能修改、删除已有属性, 以及不能修改已有属性的可枚举性、可配置性、可写性. 如果属性是对象, 除非被冻结, 否则也是可以修改的. 数组作为对象, 被冻结后, 元素不可被修改. [[Extensible]] 内部属性为 false. 对象属性的 [[Configurable]] 为 false. 若是对象属性描述符为数据描述符, 则对象属性的 [[Writable]] 为 false.语法 :Object.freeze(target)target : 目标对象.1234567891011121314151617181920212223242526272829let obj_1 = &#123; a: 'hello', b: &#123; c: 'world' &#125;&#125;let property_1 = Object.getOwnPropertyDescriptor(obj_1, 'a')let boolean_1 = Object.isExtensible(obj_1)Object.freeze(obj_1)let property_2 = Object.getOwnPropertyDescriptor(obj_1, 'a')let boolean_2 = Objct.isExtensible(obj_1)obj_1.a = 'hi'obj_1.b.c = '世界'// &gt; obj_1// &#123; a: 'hello', b: &#123; c: '世界' &#125; &#125;// &gt; property_1// &#123; value: 'hello',// writable: true,// enumerable: true,// configurable: true &#125;// &gt; property_2// &#123; value: 'hello',// writable: false,// enumerable: true,// configurable: false &#125;// &gt; boolean_2// true// &gt; boolean_2// falseObject.isExtensible()描述 :判断一个对象是否可扩展的. 即是否可添加新的属性. 新对象 [[Extensible]] 默认为 true . Object.preventExtensions(target), Object.seal(target) 或 Object.freeze(target) 可将目标对象内部属性 [[Extensible]] 置为 false.语法 :Object.isExtensible(target)target : 目标对象.12345678let obj = &#123;&#125;let boolean_1 = Object.isExtensible(obj)Object.freeze(obj)let boolean_2 = Object.isExtensible(obj)// &gt; boolean_1// true// &gt; boolean_2// falseOObject.isSealed()描述 :判断一个对象是否被密封. 若对象的内部属性 [[Extensible]] 为 false, 返回 true. 若对象属性的 [[Configurable]] 为 true, 返回 false. 否则, 返回 false.语法 :Object.isSealed(target)target : 目标对象.123456789101112let obj = &#123;&#125;let boolean_1 = Object.isFrozen(obj)Object.defineProperty(obj, 'a', &#123;configurable: false&#125;)let boolean_2 = Object.isFrozen(obj)Object.preventExtensions(obj)let boolean_3 = Object.isFrozen(obj)// &gt; boolean_1// false// &gt; boolean_2// false// &gt; boolean_3// trueObject.isFrozen()描述 :判断一个对象是否被冻结. 若对象的内部属性 [[Extensible]] 为 false, 返回 true. 若对象属性的 [[Configurable]] 为 true, 返回 false. 若是对象属性描述符为数据描述符, 对象属性的 [[Writable]] 为 true, 返回 false. 否则, 返回 false.语法 :Object.isFrozen(target)target : 目标对象.12345678910111213141516171819202122232425let obj = &#123;&#125;let boolean_1 = Object.isFrozen(obj)Object.freeze(obj)let boolean_2 = Object.isFrozen(obj)// &gt; boolean_1// true// &gt; boolean_2// falselet obj = &#123;&#125;let boolean_1 = Object.isFrozen(obj)Object.defineProperty(obj, 'a', &#123;writable: false&#125;)let boolean_2 = Object.isFrozen(obj)Object.defineProperty(obj, 'a', &#123;configurable: false&#125;)let boolean_3 = Object.isFrozen(obj)Object.preventExtensions(obj)let boolean_4 = Object.isFrozen(obj)// &gt; boolean_1// false// &gt; boolean_2// false// &gt; boolean_3// false// &gt; boolean_4// trueObject.setPrototypeOf()描述 :使得对象变得不可扩展. 即设置对象内部 [[Extensible]] 值为 false. 对象属性的 [[Configurable]] 为 false.Object.setPrototypeOf(target, prototype)target : 目标对象.prototype : 原型对象(对象或 null).123456let obj_1 = &#123;a: 1&#125;let obj_2 = &#123;b: 2&#125;Object.setPrototypeOf(obj_2, obj_1)let proto_1 = Object.getPrototypeOf(obj_2)// &gt; proto_1// &#123; a: 1 &#125;Object.getPrototypeOf()描述 :获取给定对象的原型(内部 [[Prototype]] 属性的值). 若没有即成属性, 则返回 null.语法 :Object.getOwnPropertyNames(target)target : 目标对象.12345678910111213function Person() &#123;&#125;let person = new Person()let a = Object.getPrototypeOf(person)// &gt; a// Person &#123;&#125;let obj = &#123;&#125;let obj_1 = Object.create(obj)let obj_2 = Object.getPrototypeOf(obj_1)// &gt; obj_2// &#123;&#125;// &gt; obj_2 === obj// trueObject.is()描述 :判断两个值是否相等. 规则和抽象相等、严格相等不一样.语法 :Object.is(target1, target2)target : 需要比较的两个值.1234567Object.is(undefined, undefined) // trueObject.is(null, null) // trueObject.is(true, true) // trueObject.is(false, false) // trueObject.is(+0, +0) // trueObject.is(NaN, NaN) // true *Object.is(-0, -0) //true]]></content>
      <categories>
        <category>API总结</category>
      </categories>
      <tags>
        <tag>构造函数</tag>
        <tag>Object</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记不住的继承方式]]></title>
    <url>%2F%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[记不住的继承方式都说程序员是这个世界上最懒的人, 能躺着绝不坐着, 全干着复制黏贴的活.‘什么, 你说这套逻辑之前写过?!?! 速速把代码呈上来!!!’.最懒的人往往信奉着‘拿来主义’. 若只是简单的复制黏贴, 就会显得没有逼格.在 JavaScript 中, 重复用到的逻辑我们会用函数包装起来, 在合适且需要的情况下, 调用该函数即可. 而 apply, call, new 等方法也拓宽了函数的使用场景.除了这种借来的, 我们还有继承来的. 这就是常说的原型继承. 当对象本身没有要查询的属性或方法时, 它会沿着原型链查找, 找到了就会拿来使用. 这种’无’中生有的事, 不妨了解一下.预备知识默认情况下, 所有的原型对象都会自动获得一个 constructor (构造函数)属性, 这个属性是一个指向 prototype 属性所在函数的指针. 构造函数的原型 prototype 上 constructor 的初始值是构造函数本身. 即,1Function.prototype.constructor === Function // true由构造函数构造出来的实例本身没有 constructor 属性, 不过可以通过原型链继承这个属性.1234567// 以下person的constructor属性继承自Person.prototypefunction Person() &#123;&#125;Person.prototype.constructor === Person // truelet person = new Person();person.constructor === Person // trueperson.hasOwnProperty('constructor') === false // trueperson_1.constructor === Person.prototype.constructor // true简单数据类型和复杂数据类型赋值传参的区别.JavaScript 中变量不可能成为只想另一个变量的引用. 引用指向的是值. 复杂数据类型的引用指向的都是同一个值.它们相互之间没有引用/指向关系. 一旦值发生变化, 指向该值的多个引用将共享这个变化.new, apply, call 的函数调用模式.三者的共同点都是都是指定调用函数的 this 值. 这使得同一个函数可以在不同的语境下正确执行. new 更为复杂一些. 可大致模拟为,12345function new(constructor, arguments) &#123; let instance = Object.create(constructor.prototype) // 姑且称之为 new 的特性一 constructor.apply(instance, arguments) // 姑且称之为 new 的特性二 return instance&#125;很明显, new 的操作中包涵了 apply, call 要做的事. 在此大胆猜测一下, 在实现继承的过程中, 一旦同时出现 new 和 apply 或 call, 就会有重复交集的可能, 这时就需要想想是否有可以改进的地方.不着痕迹的拿来主义‘各单位请注意, 下面到我表演地时候了’‘上道具!’12345function Animal(name) &#123; this.name = name&#125;Animal.prototype.species = 'animal'function Leo() &#123;&#125; // 我是头小狮子想要无中生有, 那是不可能的😏, 所以我们准备了模板 Animal. Animal 有的东西, Leo 也想拥有.而且 Animal 能用地东西也同样适用于 Leo.所以, 我们期待 Leo 最终长成这个样子.1234function Leo(name) &#123; this.name = name&#125;Leo.prototype.species = 'animal'‘就长这副熊样!? 这和简单的复制黏贴有什么区别!? 这和咸鱼又有什么区别!？ 说好的逼格呢！？’观察一下 Leo, Leo 构造函数内部逻辑和 Animal 构造函数的内部逻辑如出一辙. 既然都是一样的, 为什么不能借来用用呢? 改造一下,12345678function Animal(name) &#123; this.name = name&#125;Animal.prototype.species = 'animal'function Leo(name) &#123; Animal.call(this, name)&#125;这种在构造函数内部借函数而不借助原型继承的方式被称之为 借用构造函数式继承.把属性和方法放在构造函数内部的定义, 使得每个构造出来的实例都有自己的属性和方法. 而对一些需要实例间共享的属性或方法却是没辙.当然了, 我们本来就没打算止步于此. 构造函数内部可以靠借, 那原型上呢? 如何让 Leo 的原型上能和 Animal 的原型保持一致呢?‘这不是废话么? 我除了会借, 我还会继承啊, 原型继承啊!!!’关于原型链, 我们已经知道是怎么一回事了(不知道的可参考从Function入手原型链).原型继承就是通过原型链实现了对象本身没有的属性访问和方法调用. 利用这个特性, 我们可以在原型上做些手脚.思路一: 可以使得 Leo 的 prototype 直接指向 Animal 的 prototype.123456789function Animal(name) &#123; this.name = name&#125;Animal.prototype.species = 'animal'function Leo(name) &#123; Animal.call(this, name)&#125;Leo.prototype = Animal.prototype这里有一点需要注意的, Leo.prototype = Animal.prototype 这种写法就等于完全覆写了 Leo 的原型, Leo.prototype.constructor 将和 Animal.prototype.constructor 保持一致, 这会使得一些等式显得诡异.不信, 请看:1Leo.prototype.constructor === Animal.prototype.constructor === Animal针对这种情况, 我们往往会做一些修正:123// 接上例代码省略Leo.prototype = Animal.prototypeLeo.prototype.constructor = Leo即使修正好了, 可是还有个大问题.那就是, 如果想给 Leo 原型添加属性或方法, 将会影响到 Animal, 进而会影响到所有 Animal 的实例. 毕竟它们的原型之间已经画了等号.1234567// 接上例代码省略let Dog = new Animal('dog')Dog.sayName // undefinedLeo.prototype.sayName = function() &#123; console.log(this.name)&#125;Dog.sayName() // dog‘我只想偷个懒, 没想过要捣乱啊😲!!!’为了消除这种影响, 我们需要一个中间纽带过渡. 还好我们知道 new 可以用来修改原型链.思路二: Leo 的 prototype 指向 Animal 的实例.12345678910function Animal(name) &#123; this.name = name&#125;Animal.prototype.species = 'animal'function Leo(name) &#123; Animal.call(this, name)&#125;Leo.prototype = new Animal()Leo.prototype.contructor = Leo这种在构造函数内部借函数同时又借助原型继承的方式被称之为 组合继承. Leo 换个角度其实长这样:12345678function Leo(name) &#123; this.name = name&#125;Leo.prototype = &#123; constructor: Leo, name: undefined, __proto__: Animal.prototype&#125;在这种继承模式中, Leo 的实例可以有自己的属性和方法, 实例之间又可以通过 prototype 来共享属性和方法却不会影响 Animal, 还可以通过 _proto_ 追溯到 Animal.prototype.一切都很完美👏. 不过还记得文章开始时所说的么在实现继承的过程中, 一旦同时出现 new 和 apply 或 call, 就会有重复交集的可能, 这时就需要想想是否有可以改进的地方.Animal 被调用了两次, 第一次是 Leo 构造函数内部作为一个普通函数被调用, 第二次是被作为构造函数构造一个实例充当 Leo 的原型.Animal 内部定义的属性和方法同时出现在 Leo 的原型和 Leo 的实例上. 实例上有的东西就不会再到原型上查找. 反之, 实例上没有的东西才会到原型上查找. 显然, 有多余的存在.‘这不是最优解, 我要最好的! 下一个!’思路三: 既然有重复, 那就去其一呗. 既然 new 比 call 和 apply 厉害, 那就留着 new 吧.12345678function Animal(name) &#123; this.name = name&#125;Animal.prototype.species = 'animal'function Leo(name) &#123;&#125;Leo.prototype = new Animal()Leo.prototype.contructor = Leo这种在构造函数内部不借函数只借助原型继承的方式被称之为 原型链继承.经过这么一折腾, 发现不好的地方有增无减. 实例没了自己的属性和方法了, 连 Animal 构造函数内部定义的属性方法都可以在实例间共享了(思路二也存在这个问题), 而且参数也不给传了.‘我要的不多, 能轻点折腾不, 心脏不好’回到 思路二, 那就删了 new 吧.思路四: 接上 思路二, 删了 new, 那只能在原型上做调整了.我们从一开始就只是希望 Leo 的 prototype 指向 Animal 的 prototype, 不多不少且不会出现 思路一 的坏影响.既然不能直接在两者之间画等号, 就造一个过渡纽带呗. 能够关联起原型链的不只有 new, Object.create() 也是可以的.创建一个 _proto_ 指向 Animal.prototype 的对象充当 Leo 的原型不就解决问题了么.12345678910function Animal(name) &#123; this.name = name&#125;Animal.prototype.species = 'animal'function Leo(name) &#123; Animal.call(this, name)&#125;Leo.prototype = Object.create(Animal.prototype)Leo.prototype.contructor = Leo这种在构造函数内部借函数同时又间接借助原型继承的方式被称之为 寄生组合式继承.这种模式完美解决了 思路二 的弊端. 算是较为理想的继承模式吧.‘确认过眼神, 你才我想要的!’以上还是只是构造函数间的继承, 还有基于已存在对象的继承, 譬如, 原型式继承 和 寄生式继承等.讲真, 说了辣么多, 我还真没记住 借用构造函数式继承, 组合继承, 原型链继承, 寄生组合式继承, 原型式继承, 寄生式继承等.‘你没记住这么多模式, 那你都记住什么了’答曰: 要想很好得继承, 一靠朋友, 二靠拼爹.‘这孩子是不是傻? 这都什么年代了? 再说了, 就没人告诉你你家里有矿???’思路五: ES6 引入了 Class（类）这个概念，通过 class 关键字，可以定义类, Class 实质上是 JavaScript 现有的基于原型的继承的语法糖. Class 可以通过extends关键字实现继承. 我们可以对 思路四 来个华丽变身.123456789101112class Animal &#123; constructor(name) &#123; this.name = name &#125;&#125;Animal.prototype.species = 'animal'class Leo extends Animal &#123; constructor(name) &#123; super(name) &#125;&#125;经过这么一处理后行为上和 思路四 基本没什么区别, constructor(){} 充当了之前的构造函数, super() 作为函数调用扮演着 Animal.call(this, name) 的角色(还可以表示父类). 最重要的是 Leo 的 _proto_ 也指向了 Animal.‘矿多基因好, 啧啧啧, 我都快要喜欢上我自己了😏’]]></content>
      <categories>
        <category>很难么</category>
      </categories>
      <tags>
        <tag>JavaScript继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[让Python漫步在浏览器上]]></title>
    <url>%2F%E8%AE%A9Python%E6%BC%AB%E6%AD%A5%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8A%2F</url>
    <content type="text"><![CDATA[随着人工智能技术的普及，越来越多的前端程序员开始关注相关技术。Python 作为人工智能领域最常用的语言，与前端程序员日常使用的语言 JavaScript 同属脚本语言，且在两者发展过程中，社区也多有相互借鉴之处，因此有很多相似。一个熟悉 JavaScript 语言的前端程序员，通过掌握了他们之间的不同之处，可以快速上手 Python.如何快速上手? 对于一个前端程序员来说, 如果能够在熟悉的浏览器环境下学习, 最好不过了. 所以, 那就手撸一个 Pathon 在线编程. 而本文的重点则是本地文件的操作, 以下所有代码可见在线demo.File APIFileReader将 File 和 Blob 类型的文件或数据异步读入内存.InstanceOfFileReader PropertiesinstanceOfFileReader.error(只读) : 在读取时的出现的错误.instanceOfFileReader.readyState(只读) : 提供读取操作时的状态.Value(readyState)State(FileReader)Description0EMPTY未加载任何数据1LOADING加载数据中2DONE已完成数据读取instanceOfFileReader.result(只读) : 读取的结果, 要么是 String, 要么是 ArrayBuffer, 这取决于读取的方法, 且仅在 load 事件触发后可用.InstanceOfFileReader MethodsinstanceOfFileReader.abort() : 终止读取操作.instanceOfFileReader.readAsArrayBuffer() : 以 ArrayBuffer 类型为输出结果进行读取.instanceOfFileReader.readAsDataURL() : 以 Data URLs 类型为输出结果进行读取.instanceOfFileReader.readAsText() : 以 String 类型为输出结果进行读取.InstanceOfFileReader Eventsonloadstart/loadstart : 在读取操作开始时触发.onprogress/progress : 在读取过程中触发以汇报当前读取进度.onload/load : 在读取操作成功完成时触发.onabort/abort : 因调用 abort() 而终止读取时触发.onerror/error : 在读取时遇到错误时触发.onloadend/loadend : 在读取操作完成时触发(无论成功或失败).12&lt;!-- html --&gt;&lt;input type='file' onchange='openFile(event)'&gt;123456789101112131415161718192021222324252627282930313233343536373839404142// jsconst stateNames = &#123; [FileReader.EMPTY] : 'EMPTY', [FileReader.LOADING] : 'LOADING', [FileReader.DONE] : 'DONE'&#125;;let openFile = function(event) &#123; let input = event.target; let reader = new FileReader(); // 打开注解即可查看隐藏属性 // reader.onloadstart = function() &#123; // reader.abort(); // &#125;; reader.onprogress = function(e) &#123; console.log('Event: ', e.type) &#125;; reader.onload = function(e) &#123; console.log('Event: ', e.type) &#125;; reader.onloadend = function(e) &#123; console.log('Event: ', e.type) console.log(reader.error.message); &#125;; reader.onabort = function(e) &#123; console.log('Event: ', e.type) &#125; reader.onerror = function(e) &#123; console.log('Event: ', e.type) console.log(reader.error.message); &#125; reader.onload = function()&#123; let dataURL = reader.result; console.log('ReadyState: ' + stateNames[reader.readyState]); console.log('Result: ', dataURL) &#125;; console.log('ReadyState: ' + stateNames[reader.readyState]); // 打开注解即可查看隐藏属性 // reader.readAsDataURL(input.files[0]); // reader.readAsArrayBuffer(input.files[0]) reader.readAsText(input.files[0]) console.log('ReadyState: ' + stateNames[reader.readyState]);&#125;;Blob原始数据的不可变对象. File 就是衍生于 Blob.当 Blob 作为构造函数时, new Blob(blobParts, blobPropertyBag) 接受两个参数 :=&gt; blobParts : ArrayBuffer, ArrayBufferView, Blob, 或 String 对象类型之一.=&gt; blobPropertyBag({type, endings}) : type=&gt; MIME类型. endings(transparent|native) =&gt; 用于指定包含行结束符 \n 的字符串如何被写入.InstanceOfBlob PropertiesinstanceOfBlob.size(只读) : 所包含数据的大小(以字节为单位).instanceOfBlob.type(只读) : 所包含数据的MIME类型, 如果类型未知，则该值为空字符串.InstanceOfBlob MethodsinstanceOfBlob.slice([start, [end, [contentType]]]) : 创建基于原 Blob 对象指定字节范围内的数据的新 Blob 对象, 并赋予新 Blob 对象指定类型. 异于 Array.slice() 和 String.slice()12345678// jslet blob = new Blob( new String('hello world'), &#123;type: 'plain/text',endings: 'native'&#125;);let reader_1 = new FileReader();reader_1.onload = function() &#123; let result = reader_1.result; console.log('result: ', result, 'type: ', blob.type, 'size: ', blob.size)&#125;reader_1.readAsText(blob);FileFile 是 Blob 的一种特殊类型, 所以适用 Blob 的场景也同样适用于 File.File 对象可以是来自用户在一个 &lt;input&gt; 元素上选择文件后返回的 FileList 对象, 也可以来自拖放操作生成的 DataTransfer 对象, 还可以是来自在一个 HTMLCanvasElement 上执行 mozGetAsFile() 方法后返回结果.当 File 作为构造函数时, 较类似于 Blob.new File(fileParts[, name[, filePropertyBag]]) 接受两个参数 :=&gt; fileParts : ArrayBuffer, ArrayBufferView, Blob, 或 String 对象类型之一.=&gt; name : 文件名称或文件路径.=&gt; blobPropertyBag({type, endings}) : type=&gt; MIME类型. endings(transparent|native) =&gt; 用于指定包含行结束符 \n 的字符串如何被写入.InstanceOfFile PropertiesinstanceOfFile.lastModified(只读) : 当前文件最后修改时间, 自 1970年1月1日0:00 以来的毫秒数.instanceOfFile.lastModifiedDate(只读) : 当前文件最后修改时间.instanceOfFile.name(只读) : 当前文件的名称.instanceOfFile.webkitRelativePath(只读) : 当前文件的路径.instanceOfFile.size(只读) : 当前文件的大小(以字节为单位).instanceOfFile.type(只读) : 当前文件的MIME类型.InstanceOfFile Methods继承使用 Blob 的方法.FileReaderSync以同步的方式读取 File 或 Blob 对象中的内容, 仅在 workers 里可用, 因为在主线程里进行同步 I/O 操作可能会阻塞用户界面. 有着和 FileReader 相同的读取方法.URL提供了将 Blob 生成 url 的方法, 可使本地内容生成 url 传给接受 url 的 API.URL MethodsURL.createObjectURL() : 为指定的 File 或 Blob 或 MediaSource 对象创建一个新的 url.Lifetime of blob URLsURL.revokeObjectURL() : 释放之前生成的 url.123&lt;!-- html --&gt;&lt;input type='file' accept='image/*' onchange='uploadPicture(event)'&gt;&lt;div id='picture'&gt;&lt;/div&gt;12345678910111213141516171819202122232425262728293031323334// jslet picture = document.getElementById('picture');let uploadPicture = function(event) &#123;let target = event.target;let file = target.files[0];// URLlet img = document.createElement('img');let url = URL.createObjectURL(file);img.width = 300;img.src = url;img.onload = function() &#123; URL.revokeObjectURL(url);&#125;;picture.appendChild(img);// Auto downloadlet downLink = document.createElement('a');let downUrl = URL.createObjectURL(file, &#123; type: 'image/*' &#125;);downLink.download = `picture.png`;downLink.href = downUrl;downLink.click();URL.revokeObjectURL(downUrl);// FileReaderlet reader_3 = new FileReader();reader_3.onload = function() &#123; let result = reader_3.result; let img = document.createElement('img'); img.width = 300; img.src = result; picture.appendChild(img);&#125;reader_3.readAsDataURL(file);&#125;]]></content>
      <categories>
        <category>API总结</category>
      </categories>
      <tags>
        <tag>File API</tag>
        <tag>FileReader</tag>
        <tag>Blob</tag>
        <tag>URL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Function原型方法]]></title>
    <url>%2FFunction%E5%8E%9F%E5%9E%8B%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[FunctionFunction 作为构造函数用来创建一个新的 Function 对象.概述详见从Function入手原型链. Function 用来创建函数对象, 而 Function 本身也是函数, 所以有一个让很多人困扰的地方.1Object.getPrototypeOf(Function) === Function.prototype // true原型方法Function.prototype.toString()描述 :返回一个表示当前函数源代码的字符串.语法 :function.toString()在内置函数或由 Function.prototype.bind 返回的函数上调用该方法, 则有:1234567891011String.toString()// "function String() &#123; [native code] &#125;"Number.toString()// "function Number() &#123; [native code] &#125;"String.bind(null).toString()// "function () &#123; [native code] &#125;"Number.bind(null).toString()// "function () &#123; [native code] &#125;"普通函数调用该方法, 则有:123456(function() &#123;&#125;).toString()// "function() &#123;&#125;"function man(params) &#123;console.log(params)&#125;man.toString()// "function man(params) &#123;console.log(params)&#125;"非 Function 对象调用该方法, 会抛出 TypeError.12Function.prototype.toString.call(&#123;&#125;)// TypeError: Function.prototype.toString requires that 'this' be a FunctionFunction.prototype.apply()描述 :为调用的函数指定 this 值, 即 this 的执行上下文, 并以数组的形式传入参数.语法 :function.apply(thisArg, argArray)thisArg : 用于改变函数体内部 this 指向的 context. 当 argArray 为 undefined 或 null 时, thisArg 将替换成全局对象. 为基本类型值时, 将会被包装成相应的对象. 否则将不会做任何改变.argArray : 数组或类数组对象. argArray 里的元素将逐个放入参数列表中. 若检测 argArray 不是对象, 将会抛出 TypeError 错误.123456789101112131415161718192021222324252627282930313233343536373839const man = &#123; age: 18, sex: 'man', saySex() &#123; console.log(`I am a $&#123;this.sex&#125;`) &#125;&#125;const women = &#123; age: 16, sex: 'women'&#125;man.saySex.apply(women)// I am a women------------------------------function log_1(arg) &#123; console.log(arg)&#125;log_1(1);log_1(1,2,3);// 1// 1function log_2() &#123; const log = console.log; log.apply(null, arguments)&#125;log_2(1);log_2(1, 2, 3)// 1// 1 2 3------------------------------let a = ['h','e','l','l','o'];let b = ['w','o','r','l','d'];let push = Array.prototype.push;push.apply(a, b);console.log(a);// [ 'h', 'e', 'l', 'l', 'o', 'w', 'o', 'r', 'l', 'd' ]Function.prototype.call()描述 :为调用的函数指定 this 值, 即 this 的执行上下文, 并以列表的形式传入参数.语法 :function.call(thisArg[ , arg1 [ , arg2, …, argN]])thisArg : 用于改变函数体内部 this 指向的 context. 当 argArray 为 undefined 或 null 时, thisArg 将替换成全局对象. 为基本类型值时, 将会被包装成相应的对象. 否则将不会做任何改变.argN : 入参将从左到右的顺序加入到参数列表中.123456789101112131415161718function Person(name, age) &#123; this.name = name; this.age = age;&#125;function Man(name, age) &#123; Person.call(this, name, age); this.sex = 'man';&#125;const Adam = new Man('Adam', 18);console.log(Adam)// Man &#123; name: 'Adam', age: 18, sex: 'man' &#125;------------------------------let a = ['h','e','l','l','o'];let push = Array.prototype.push;push.call(a, 'w','o','r','l','d');console.log(a);// [ 'h', 'e', 'l', 'l', 'o', 'w', 'o', 'r', 'l', 'd' ]Function.prototype.bind()描述 :创建一个新的绑定函数, 为函数指定 this 值, 即 this 的执行上下文, 并以列表的形式传入参数.语法 :function.bind(thisArg[ , arg1 [ , arg2, …, argN]])thisArg : 调用绑定函数时作为this参数传递给目标函数的值.argN : 当目标函数被调用时，预先添加到绑定函数的参数列表中的参数.1234567891011121314151617for(var i = 0; i &lt;= 3; i++) &#123; setTimeout((function(i) &#123; console.log('i', i) &#125;).bind(null, i), 1000)&#125;// 0// 1// 2// 3------------------------------// 类数组转数组let argArray = Array.prototype.slice.call(arguments);// 或let slice = Array.prototype.slice;let boundSlice = Function.prototype.call.bind(slice);boundSlice(arguments);]]></content>
      <categories>
        <category>API总结</category>
      </categories>
      <tags>
        <tag>Function</tag>
        <tag>Function原型</tag>
        <tag>apply</tag>
        <tag>call</tag>
        <tag>bind</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从Function入手原型链]]></title>
    <url>%2F%E4%BB%8EFunction%E5%85%A5%E6%89%8B%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[FunctionFunction 是函数? 是构造函数? 还是函数对象? 在翻阅 ECMA 规范时, 这几个名词也是无缝切换中, 稍不留神就可能跑偏了.都应该知道, 构造函数是用来打造具有相同属性和行为事物的模具.在作为构造函数之前, 它首先是个函数, 函数是可以被调用的(这也是区别于其它对象的因素). 它是由一系列语句组成, 并最终返回一个值. 每一个函数被创建的时候, 都有一个 prototype 属性.普通函数能够变成构造函数, 那都是 new 将函数的 prototype 和生成的实例关联起来了. 换句话说, 每个普通函数都有称为构建函数的潜质.12345678910111213141516// 常见的构造函数模式function Man(name) &#123; this.name = name; this.sex = 'man';&#125;Man.prototype.sayHi = function() &#123; console.log('hello', this.name)&#125;let man_1 = new Man('夜曉宸');// 我是普通函数function man(name) &#123; console.log('hello', name)&#125;// 只要经过 new 调教后, 我也可以被称为构造函数了let man_2 = new man('夜曉宸');Function和内置函数都说函数是 JavaScript 里的头等对象, 这话一点不假. 在 为强制类型转换正名 里已经提到过, JavaScript 里的数据类型除了基本数据类型, 就是复杂数据类型. 而这些复杂数据类型都和 Function 有着密切关系.Function构造函数函数的身影在 JavaScript 中随处可见, 有造字符串类型的 String 函数, 有造数值类型的 Number 函数, 除了这些内置函数, 还有上面我自己写的 Man 和 man 函数. JavaScript 的作者在写 JavaScript 语言的时候, 可能知道有且需要 String, Number 这样的函数处理写数据, 于是有了内置函数这么一说. 那么内置函数满足不了我们的需求呢, 如何去创建一个函数呢? 其实, 在没有这些内置函数之前, 就有了这么一个东西. 那就是为创建函数而生的函数 —— Function. 等会儿, 有点绕😵, 创建函数的函数? 那岂不是把自己也给创建了🤔? 是的, 没错, 就是这么一个奇葩的存在.The Function constructor is the %Function% intrinsic object and the initial value of the Functionproperty of the global object. When Functionis called as a function rather than as a constructor, it creates and initializes a new Function object. Thus the function call Function(…)is equivalent to the object creation expression new Function(…)with the same arguments.所以说, 包括这些内置函数, 它们都是由 Function 构建函数造出来的. 如何去验证函数是不是函数造出来的呢?new操作符All ordinary objects have an internal slot called [[Prototype]]. The value of this internal slot is either null or an object and is used for implementing inheritance.每个普通对象都有一个 [[Prototype]], 这个属性就是用来实现原型继承用的.上面👆也提到了, 在用构造函数造 new 出实例对象时, 实例对象内部的 [[Prototype]] 会关联到构造函数的 prototype 所指向的对象. new 主要做以下两件事:将实例对象的 [[Prototype]] 关联到构造函数的 prototype 上.将 this 绑定到新创建的实例对象上, 并调用构造函数(就是将函数体里的语句执行一遍).类似于:1234567function New(func) &#123; const obj = &#123;&#125;; // _proto_ 和 [[Prototype]] 不是同一个东西, 后者是内部使用的. ojb._proto_ = func.prototype; func.call(obj); return obj;&#125;Object.getPrototypeOf() 是用来检测指定对象内部 [[Prototype]] 属性的值.对于上面👆的 Man 和 man_1 关系, 试一波.1Object.getPrototypeOf(man_1) === Man.prototype // true;Function和函数回头再看看 String, Number, Boolean, Array, Object, Function, RegExp, Date, Error, Symbol 这些内置函数和 Function 构造函数的关系(注意包含了 Function 自身). 这里是把这些内置函数作为由 Function 构造出来的实例对象对待的. (函数也是对象的一子类型)1234567891011121314151617181920212223Object.getPrototypeOf(String) === Function.prototype // trueObject.getPrototypeOf(Number) === Function.prototype // trueObject.getPrototypeOf(Boolean) === Function.prototype // trueObject.getPrototypeOf(Array) === Function.prototype // trueObject.getPrototypeOf(Object) === Function.prototype // trueObject.getPrototypeOf(Function) === Function.prototype // trueObject.getPrototypeOf(RegExp) === Function.prototype // trueObject.getPrototypeOf(Date) === Function.prototype // trueObject.getPrototypeOf(Error) === Function.prototype // trueObject.getPrototypeOf(Symbol) === Function.prototype // trueObject.getPrototypeOf(Man) === Function.prototype // true 👀👆🌰Object.getPrototypeOf(man_1) === Function.prototype // false 👀👆🌰在之前的 为强制类型转换正名 已经知道了, JavaScript 里的对象类型基本上也就是那么多. 以上函数的原型链, 最终会指向 Function.prototype (仅为目前, 后面还有 Object.prototype 和 null ). 这也是解释了为什么任何一个普通函数都可以调用 call , apply 等 Functon.prototype 上的方法.Function和原型所有的函数的原型链里都将会出现 Functon.prototype, 由构造函数 new 出来的实例对象的 [[Prototype]] 会关联到构造函数 prototype 上.1234let num = new Number(0);Object.getPrototypeOf(num) === Number.prototype // trueObject.getPrototypeOf(Man) === Function.prototype // true 👀👆🌰到目前为止, 任何函数或对象都可以追溯到 Functon.prototype 和 构造函数的 prototype 上. 那么接下来, 又如何沿着原型链再往后找呢?The Function prototype object is the intrinsic object %FunctionPrototype%. The Function prototype object is itself a built-in function object.这句话告诉我们, Function 的原型是一个函数对象. 可我们也知道, 所有的函数都应该来自于 Function. 由此可推导, Function.prototype 内部属性 [[Prototype]] 应指向 Function.prototype. 实际上并不是这样. 同样情况的还有 Array.1Object.getPrototypeOf(Function.prototype) === Function.prototype // falseECMA 规范也给出了解释, 不知是不是解释这个的.It does not have a [[Construct]] internal method so it is not a constructor.NOTE The Function prototype object is specified to be a function object to ensure compatibility with ECMAScript code that was created prior to the ECMAScript 2015 specification.以上推导可忽略. 所以呢,The value of the [[Prototype]] internal slot of the Function prototype object is the intrinsic object %ObjectPrototype%.1Object.getPrototypeOf(Function.prototype) === Object.prototype // true其它的构造函数也是一样.1234567891011121314151617181920212223242526// true String.prototype is an ordinary object.Object.getPrototypeOf(String.prototype) === Object.prototype// true String.prototype is an ordinary object.Object.getPrototypeOf(Number.prototype) === Object.prototype// true String.prototype is an ordinary object.Object.getPrototypeOf(Boolean.prototype) === Object.prototype// true String.prototype is an Array exotic objects.Object.getPrototypeOf(Array.prototype) === Object.prototype// true String.prototype is an ordinary object.Object.getPrototypeOf(Function.prototype) === Object.prototype// true String.prototype is a built-in function object.Object.getPrototypeOf(RegExp.prototype) === Object.prototype// true String.prototype is an ordinary object.Object.getPrototypeOf(Date.prototype) === Object.prototype// true String.prototype is an ordinary object.Object.getPrototypeOf(Error.prototype) === Object.prototype// true String.prototype is an ordinary object.Object.getPrototypeOf(Symbol.prototype) === Object.prototype所有的函数或对象的原型链都会追溯到 Object.prototype 上, 难道这里就是终点么? 不是的, 还有个 null . 所以, 最终,1Object.getPrototypeOf(Object.prototype) === null // true总结一波:Function 是构造函数的地方, 构造函数是函数, 内建函数也是函数.被构造出来的实例对象内部属性 [[Prototype]] 会关联到构造函数的 prototype 所指向的对象.prototype chain 的走向为:instance =&gt; constructor.prototype =&gt; Object.prototype =&gt; null. (构造函数造出的实例对象走向)function =&gt; Function.prototype =&gt; Object.prototype =&gt; null.(函数走向)…上图说明一切.]]></content>
      <categories>
        <category>很难么</category>
      </categories>
      <tags>
        <tag>构造函数</tag>
        <tag>Function</tag>
        <tag>函数</tag>
        <tag>new操作符</tag>
        <tag>原型链</tag>
        <tag>prototype</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为强制类型转换正名]]></title>
    <url>%2F%E4%B8%BA%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%AD%A3%E5%90%8D%2F</url>
    <content type="text"><![CDATA[强制类型转换引子强制类型转换是JavaScript开发人员最头疼的问题之一, 它常被诟病为语言设计上的一个缺陷, 太危险, 应该束之高阁.作为开发人员, 往往会遇到或写过涉及到类型转换的代码, 只是我们从来没有意识到. 因为我们基本碰运气.猜猜看😏:作为基本类型值, 为什么我们可以使用相关的属性或方法? eg: &#39;hello&#39;.charAt(0) (内置类型和内建函数的关系)a &amp;&amp; (b || c) 这波操作我们知道, 那么 if (a &amp;&amp; (b || c)), 这里又做了哪些操作? (||和&amp;&amp;)if (a == 1 &amp;&amp; a== 2) { dosomething }, dosomething竟然执行了, 什么鬼? (ToPrimitive)[] == ![] =&gt; true ?; false == [] =&gt; true ?; &quot;0&quot; == false =&gt; true ?(抽象相等)if (~indexOf(&#39;a&#39;)), 这波操作熟悉不? (+/-/!/~)在String, Number, Boolean类型之间比较时, 进行的强制类型转换又遵循了哪些规则? (抽象操作)下面就要学会用实力碰运气.类型内置类型JavaScript 有七种内置类型. 空值: null, 未定义: undefined, 布尔值: boolean, 数字: number, 字符串: string, 对象: object, 符号: symbol. 除 对象:object, 为复杂数据类型, 其它均为基本数据类型.内建函数常用的内建函数: String(), Number(), Boolean(), Array(), Object(), Function(), RegExp(), Date(), Error(), Symbol().内置类型和内建函数的关系为了便于操作基本类型值, JavaScript提供了封装对象(内建函数), 它们具有各自的基本类型相应的特殊行为. 当读取一个基本类型值的时候, JavaScript引擎会自动对该值进行封装(创建一个相应类型的对象包装它)从而能够调用一些方法和属性操作数据. 这就解释了问题 1.类型检测typeof =&gt; 基本类型的检测均有同名的与之对应. null 除外(不同的对象在底层都表示为二进制, 在JavaScript中二进制前三位都为 0 会被判断为 Object 类型, null 的二进制表示为0, 前三位自然为0, 所以执行 typeof 时会返回 &#39;object&#39;.), null是假值, 也是唯一一个typeof检测会返回 &#39;object&#39; 的基本数据类型值.1234typeof null // "object"let a = null;(!a &amp;&amp; typeof a === 'object') // true复杂数据类型typeof检测返回 &#39;object&#39;, function(函数)除外. 函数因内部属性 [[Call]] 使其可被调用, 其实属于可调用对象.1typeof function()&#123;&#125; // "function"Object.prototype.toString =&gt; 通过typeof检测返回&#39;object&#39;的对象中还可以细分为好多种, 从内建函数就可以知道.它们都包含一个内部属性[[Class]], 一般通过Object.prototype.toString(…)来查看.1234567891011const str = new String('hello');const num = new Number(123);const arr = new Array(1, 2, 3);console.log(Object.prototype.toString.call(str))console.log(Object.prototype.toString.call(num))console.log(Object.prototype.toString.call(arr))// [object String]// [object Number]// [object Array]抽象操作在数据类型转换时, 处理不同的数据转换都有对应的抽象操作(仅供内部使用的操作), 在这里用到的包括 ToPrimitive, ToString, ToNumber, ToBoolean. 这些抽象操作定义了一些转换规则, 不论是显式强制类型转换, 还是隐式强制类型转换, 无一例外都遵循了这些规则(显式和隐式的命名叫法来自《你不知道的JavaScript》). 这里就解释了问题 5和问题 6.ToPrimitive该抽象操作是将传入的参数转换为非对象的数据. 当传入的参数为 Object 时, 它会调用内部方法[[DefaultValue]] 遵循一定规则返回非复杂数据类型, 规则详见DefaultValue. 故 ToString, ToNumber, ToBoolean在处理Object时, 会先经过ToPrimitive处理返回基本类型值.[[DefaultValue]](hint)语法:[[DefaultValue]]的规则会依赖于传入的参数hint, ToString传入的 hint 值为 String, ToNumber传入的 hint 值为 Number.[[DefaultValue]](String) =&gt; 若 toString 可调用, 且 toString(Obj) 为基本类型值, 则返回该基本类型值. 否则, 若 valueOf 可调用, 且 valueOf(Obj) 为基本类型值, 则返回该基本类型值. 若以上处理还未得到基本类型值, 则抛出 TypeError.[[DefaultValue]](Number) =&gt; 该规则正好和上规则调用 toString, valueOf 的顺序相反. 若 valueOf 可调用, 且 valueOf(Obj) 为基本类型值, 则返回该基本类型值. 否则, 若 toString 可调用, 且 toString(Obj) 为基本类型值, 则返回该基本类型值. 若以上处理还未得到基本类型值, 则抛出 TypeError.[[DefaultValue]]() =&gt; 未传参时, 按照 hint值为 Number 处理. Date 对象除外, 按照hint值为 String 处理.现在我们就用以上的知识点来解释问题 3是什么鬼.12345678910let i = 1;Number.prototype.valueOf = () =&gt; &#123; return i++&#125;;let a = new Number("0"); // 字符串强制转换为数字类型是不执行Toprimitive抽象操作的.console.log('a_1:', a);if(a == 1 &amp;&amp; a == 2) &#123; console.log('a==1 &amp; a==2', 'i:', i);&#125;// a==1 &amp; a==2 i: 3我们改写了内建函数 Number 原型上的 valueOf 方法, 并使得一个字符串转换成 Number 对象, 第一次 Object 类型和 Number 类型做比较时, Object 类型将进行 ToPrimitive 处理(抽象相等), 内部调用了 valueOf, 返回 2. 第二次同样的处理方式, 返回 3.ToString该抽象操作负责处理非字符串到字符串的转换.typeresultnull“null”undefined“undefined”booleantrue =&gt; “true”; false =&gt; “false”string不转换numberToString Applied to the Number TypeObject先经ToPrimitive返回基本类型值, 再遵循上述规则ToNumber该抽象操作负责处理非数字到数字的转换.typeresultnull+0undefinedNaNbooleantrue =&gt; 1; false =&gt; 0stringToNumber Applied to the String Typenumber不转换Object先经ToPrimitive返回基本类型值, 再遵循上述规则常见的字符串转换数字:字符串是空的 =&gt; 转换为0.字符串只包含数字 =&gt; 转换为十进制数值.字符串包含有效的浮点格式 =&gt; 转换为对应的浮点数值.字符串中包含有效的十六进制格式 =&gt; 转换为相同大小的十进制整数值.字符串中包含除以上格式之外的符号 =&gt; 转换为 NaN.ToBoolean该抽象操作负责处理非布尔值到布尔值转换.typeresultnullfalseundefinedfalseboolean不转换string“” =&gt; false; 其它 =&gt; truenumber+0, −0, NaN =&gt; false; 其它 =&gt; trueObjecttrue真值 &amp; 假值假值(强制类型转换false的值) =&gt; undefined, null, false, +0, -0, NaN, &quot;&quot;.真值(强制类型转换true的值) =&gt; 除了假值, 都是真值.特殊的存在假值对象 =&gt; documen.all 等. eg: Boolean(window.all) // false隐式强制类型转换+/-/!/~+/- 一元运算符 =&gt; 运算符会将操作数进行ToNumber处理.! =&gt; 会将操作数进行ToBoolean处理.~ =&gt; (~x)相当于 -(x + 1) eg: ~(-1) ==&gt; 0; ~(0) ==&gt; 1; 在if (…)中作类型转换时, 只有-1时, 才为假值.+加号运算符 =&gt; 若操作数有String类型, 则都进行ToString处理, 字符串拼接. 否则进行ToNumber处理, 数字加法.条件判断if (...), for(;;;), while(...), do...while(...)中的条件判断表达式.? : 中的条件判断表达式.|| 和 &amp;&amp; 中的中的条件判断表达式.以上遵循ToBoolean规则.||和&amp;&amp;返回值是两个操作数的中的一个(且仅一个). 首先对第一个操作数条件判断, 若为非布尔值则进行ToBoolean强制类型转换.再条件判断.|| =&gt; 条件判断为true, 则返回第一个操作数; 否则, 返回第二个操作数. 相当于 a ? a : b;&amp;&amp; =&gt; 条件判断为true, 则返回第二个操作数; 否则, 返回第一个操作数, 相当于 a ? b : a;结合条件判断, 解释下问题 21234567let a = true;let b = undefined;let c = 'hello';if (a &amp;&amp; (b || c)) &#123; dosomething()&#125;a &amp;&amp; (b || c) 返回 'hello', if语句中经Toboolean处理强制类型转换为true.抽象相等这里的知识点是用来解释 问题 4 的, 也是考验人品的地方. 这下我们要靠实力拼运气.同类型的比较.1234+ 0 == -0 // truenull == null // trueundefined == undefined // trueNaN == NaN // false, 唯一一个非自反的值null 和 undefined 的比较.12null == undefined // trueundefined == null // trueNumber 类型和 String 类型的比较. =&gt; String 类型要强制类型转换为 Number 类型, 即 ToNumber(String).(参见ToNumber)Boolean 类型和其它类型的比较. =&gt; Boolean 类型要强制类型转换为 Number 类型, 即 ToNumber(Boolean).(参见ToNumber)Object 类型和 String 类型或 Number 类型. =&gt; Object 类型要强制转换为基本类型值, 即 ToPrimitive(Object).(参见ToPrimitive)其它情况, false.回头看看问题 4中的等式. [] == ![], false == [], &quot;0&quot; == false.[] == ![] =&gt; ! 操作符会对操作数进行ToBoolean处理, [] 是真值, !true 则为 false. 再遵循第 4 点, Boolean 类型经过 ToNumber 转换为 Number类型, 则为数值 0. 再遵循第 5 点, 对 [] 进行 ToPrimitive 操作, 先后调用 valueOf(), toString()直到返回基本类型, 直到返回 &quot;&quot;. (先[].valueOf() =&gt; [], 非基本类型值; 再[].toString() =&gt; “”, 基本类型值, 返回该基本类型值.). 再遵循第 3 点, 对 &quot;&quot; 进行 ToNumber处理, 则为数值 0. 到此, 0 == 0, 再遵循第 1 点(其实没写全😌, 详见The Abstract Equality Comparison Algorithm), return true, 完美!😏.false == [] =&gt; 同理 [] == ![].&quot;0&quot; == false =&gt; 同理 [] == ![].123[] == ![] // truefalse == [] // true"0" == false // true运气是留给有准备的人, 所以呢, 我要准备买彩票了.😏]]></content>
      <categories>
        <category>很难么</category>
      </categories>
      <tags>
        <tag>强制类型转换</tag>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String原型方法]]></title>
    <url>%2FString%E5%8E%9F%E5%9E%8B%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[StringString全局对象是一个用于字符串或一个字符序列的构造函数.概述除 Object 以外的所有类型都是不可变的(值本身无法被改变). JavaScript 中字符串是不可变的「JavaScript 中对字符串的操作一定返回了一个新字符串, 原始字符串并没有被改变」.字符串字面量(通过单引号或双引号定义)和直接调用 String 方法(没有通过 new 生成字符串对象实例)的字符串都是基本字符串. JavaScript 会自动将基本字符串转换为字符串对象, 只有将基本字符串转化为字符串对象之后才可以使用字符串对象的方法.123456789101112131415let a = 'Hello, World';let b = String('Hello, World');let c = new String('Hello, World');console.log('a', a);console.log('b', b);console.log('c', c);// a Hello, World// b Hello, World/* c String =&#123; 0: "H", 1: "e",2: "l", 3: "l", 4: "o", 5: ",", 6: " ", 7: "W", 8: "o", 9: r", 10: "l", 11: "d", length: 12 &#125; */// 可以看到String构造出来的是一个类数组, 这样就可以通过.或[]来取值.当基本字符串需要调用一个字符串对象才有的方法或者查询值的时候(基本字符串是没有这些方法的「原始值」)，JavaScript 会自动将基本字符串转化为字符串对象并且调用相应的方法或者执行查询「JavaScript会自动将字符串字面值转换为一个临时字符串对象，调用该方法，然后废弃掉那个临时的字符串对象」.原型方法(部分)String.prototype.charAt()描述 :从一个字符串中返回指定索引位置的字符.语法 :str.charAt(index)index(可选) : 介于 0 ~ (str.length - 1) 的整数. 若无, 默认值为 0. 超过指定范围数值, 则返回空字符串.12345678910var anyString = "Hello World";console.log("The character at index 0 is '" + anyString.charAt() + "'");console.log("The character at index 1 is '" + anyString.charAt(1) + "'");console.log("The character at index 2 is '" + anyString.charAt(2) + "'");console.log("The character at index 11 is '" + anyString.charAt(11) + "'");// The character at index 0 is 'H'// The character at index 1 is 'e'// The character at index 2 is 'l'// The character at index 11 is ''String.prototype.concat()描述 :将原字符串与多个字符串拼接成新的字符串.语法 :str.concat(string[, string1, ..., stringN])stringN : 要拼接的字符串.1234let 你好世界 = 'Hello'.concat(' World');console.log('你好世界 = ', 你好世界);// 你好世界 = Hello WorldString.prototype.trim()描述 :将字符串的两端空白字符删除.语法 :str.trim()123456let str_1_length = ' Hello World ! '.length;let str_1 = ' Hello World ! '.trim();console.log('str_1_length', str_1_length, 'str_1', str_1, str_1.length);// str_1_length 24 str_1 Hello World ! 13String.prototype.replace()描述 :在字符串中匹配并替换指定字符串.语法 :str.replace(regexp|string, newString|function)regexp : 一个 RegExp 对象或者其字面量.string : 待匹配的字符串, 仅仅是第一个匹配会被替换.newString : 用于取代的字符串.function : 每次匹配都要调用的函数.12345678910111213141516171819let str_1 = '521521521521'.replace('521', '我爱你');let str_2 = '521521521521'.replace(/521/g, '我爱你');let str_3 = '521521521521'.replace(/(521)/g, function(a, b, c, d)&#123; console.log('arguments', arguments); if (c === 0) return a; return '我爱你';&#125;);console.log('str_1', str_1);console.log('str_2', str_2);console.log('str_3', str_3);// arguments &#123; '0': '521', '1': '521', '2': 0, '3': '521521521521' &#125;// arguments &#123; '0': '521', '1': '521', '2': 3, '3': '521521521521' &#125;// arguments &#123; '0': '521', '1': '521', '2': 6, '3': '521521521521' &#125;// arguments &#123; '0': '521', '1': '521', '2': 9, '3': '521521521521' &#125;// str_1 我爱你521521521// str_2 我爱你我爱你我爱你我爱你// str_3 521我爱你我爱你我爱你String.prototype.split()描述 :在字符串中指定分隔符, 并在分隔符处分割字符串.语法 :str.split([separator[, limit]])separator : 字符串或正则表达式. 若省略, 则返回的数组包含一个由整个字符串组成的元素.limit : 限定返回的分割片段数量.123456789101112131415161718192021let str_1 = 'Hello World'.split();let str_2 = 'Hello World'.split('');let str_3 = 'Hello World'.split(' ');let str_4 = 'Hello World, Hello World, Hello World'.split(',', 2);let str_5 = 'He5llo 2Worl1d'.split(/\d/);let str_6 = 'He5llo 2Worl2d'.split(/(\d)/);console.log('str_1',str_1);console.log('str_2',str_2);console.log('str_3',str_3);console.log('str_4',str_4);console.log('str_5',str_5);console.log('str_5',str_6);// str_1 [ 'Hello World' ]// str_2 [ 'H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd' ]// str_3 [ 'Hello', 'World' ]// str_4 [ 'Hello World', ' Hello World' ]// str_5 [ 'He', 'llo ', 'Worl', 'd' ]// str_5 [ 'He', '5', 'llo ', '2', 'Worl', '2', 'd' ]String.prototype.slice()描述 :提取字符串的一部分.语法 :str.slice(begin[, end])begin(可选) : 起始索引, 默认值为0. 如果是负数, 则开始索引会被自动计算成为 str.length + start.end : 终止索引, 默认值 str.length. 不包括end位置. 如果是负数时, 规则如上.1234567891011let str_1 = '0123456789'.slice();let str_2 = '0123456789'.slice(-1);let str_3 = '0123456789'.slice(1, -1);console.log('str_1', str_1);console.log('str_2', str_2);console.log('str_3', str_3);// str_1 0123456789// str_2 9// str_3 12345678String.prototype.substring()描述 :提取字符串的一部分.语法 :str.substring(begin[, end])begin : 起始索引.end : 终止索引.1234567891011let str_1 = '0123456789'.substring();let str_2 = '0123456789'.substring(0, 7);let str_3 = '0123456789'.substring(7, 0);console.log('str_1', str_1);console.log('str_2', str_2);console.log('str_3', str_3);// str_1 0123456789// str_2 0123456// str_3 0123456String.prototype.substr()描述 :提取字符串的一部分.语法 :str.substr(start[, length])start(可选) : 起始索引, 默认值为0. 如果是负数, 则开始索引会被自动计算成为 str.length + start.length : 提取的字符数.1234567891011let str_1 = '0123456789'.substr();let str_2 = '0123456789'.substr(-3);let str_3 = '0123456789'.substr(0, 6);console.log('str_1', str_1);console.log('str_2', str_2);console.log('str_3', str_3);// str_1 0123456789// str_2 789// str_3 012345String.prototype.includes()描述 :判断字符串中是否有指定字符串. 依条件返回 true 或 false.语法 :str.includes(string[, position])string : 需要查询的字符串.position : 指定查询起始位置, 默认为 0.1234567let boolean_1 = 'Hello World'.includes('World');let boolean_2 = 'Hello World'.includes('你好世界');console.log('boolean_1 = ', boolean_1);console.log('boolean_2 = ', boolean_2);// boolean_1 = true// boolean_2 = falseString.prototype.startsWith()描述 :判断字符串是否以指定字符串开头. 依条件返回 true 或 false.语法 :str.startsWith(string[, position])string : 需要查询的字符串.position : 指定字符串开头的位置, 默认值为 0.1234567891011let boolean_1 = '123456789'.startsWith(1);let boolean_2 = '123456789'.startsWith(3, 4);let boolean_3 = '123456789'.startsWith(7, 6);console.log('boolean_1', boolean_1);console.log('boolean_2', boolean_2);console.log('boolean_3', boolean_3);// boolean_1 true// boolean_2 false// boolean_3 trueString.prototype.endsWith()描述 :判断字符串是否以指定字符串结尾. 依条件返回 true 或 false.语法 :str.endsWith(string[, position])string : 需要查询的字符串.position : 指定字符串结尾的位置(字符串的长度), 默认值为 str.length.1234567891011let boolean_1 = '123456789'.endsWith(9);let boolean_2 = '123456789'.endsWith(9, 8);let boolean_3 = '123456789'.endsWith(7, 7);console.log('boolean_1', boolean_1);console.log('boolean_2', boolean_2);console.log('boolean_3', boolean_3);// boolean_1 true// boolean_2 false// boolean_3 trueString.prototype.indexOf()描述 :查询指定字符串在字符串中首次出现的索引位置. 若未查询到, 则返回 -1.语法 :str.indexOf(string[, position])string : 需要查询的字符串.position : 首次被找到的元素在数组中的索引位置, 默认值为 0.1234567891011let pos_1 = '0123456789'.indexOf(8);let pos_2 = '0123456789'.indexOf(8, 9);let pos_3 = '0123456789'.indexOf(8, 8);console.log('pos_1', pos_1);console.log('pos_2', pos_2);console.log('pos_3', pos_3);// pos_1 8// pos_2 -1// pos_3 8String.prototype.lastIndexOf()描述 :从字符串的后面向前查找, 查询指定字符串在字符串中首次出现的索引位置. 若未查询到, 则返回 -1.语法 :str.lastIndexOf(string[, position])string : 需要查询的字符串.position : 逆向查找起始索引, 默认值 str.length - 1.1234567891011let pos_1 = '0123456789'.lastIndexOf(9);let pos_2 = '0123456789'.lastIndexOf(9, 9);let pos_3 = '0123456789'.lastIndexOf(9, 8);console.log('pos_1', pos_1);console.log('pos_2', pos_2);console.log('pos_3', pos_3);// pos_1 9// pos_2 9// pos_3 -1String.prototype.match()描述 :字符串检索匹配正则表达式.语法 :str.match(regexp)regexp : 正则表达式对象, 如果传入一个非正则表达式对象, 则会隐式地使用 new RegExp(obj) 将其转换为一个 RegExp. 如果你未提供任何参数, 直接使用 match(), 那么你会得到一个包含空字符串的 Array : [&quot;&quot;].返回值 : 如果字符串匹配到了表达式, 会返回一个数组, 数组的第一项是进行匹配完整的字符串, 之后的项是用圆括号捕获的结果. 如果没有匹配到, 返回null.1234567891011let pos_1 = '0123456789'.match(9);let pos_2 = '0123456789'.match(/8\d+/);let pos_3 = '0123456789'.match(/7\d&#123;1&#125;/);console.log('pos_1', pos_1);console.log('pos_2', pos_2);console.log('pos_3', pos_3);// pos_1 [ '9', index: 9, input: '0123456789' ]// pos_2 [ '89', index: 8, input: '0123456789' ]// pos_3 [ '78', index: 7, input: '0123456789' ]String.prototype.search()描述 :字符串检索匹配正则表达式.语法 :str.search(regexp)regexp : 正则表达式对象, 如果传入一个非正则表达式对象, 则会隐式地使用 new RegExp(obj) 将其转换为一个 RegExp. 如果你未提供任何参数, 直接使用 match(), 那么你会得到一个包含空字符串的 Array : [&quot;&quot;].返回值 : 如果匹配成功, 则 search() 返回正则表达式在字符串中首次匹配项的索引. 否则, 返回 -1.1234567891011let pos_1 = '0123456789'.search(9);let pos_2 = '0123456789'.search(/8\d+/);let pos_3 = '0123456789'.search(/7\d&#123;1&#125;/);console.log('pos_1', pos_1);console.log('pos_2', pos_2);console.log('pos_3', pos_3);// pos_1 9// pos_2 8// pos_3 7String.prototype.toLowerCase()描述 :将字符串转换成小写形式.语法 :str.toLowerCase()12345let str_1 = 'Hello World !'.toLowerCase();console.log('str_1', str_1);// str_1 hello world !String.prototype.toUpperCase()描述 :将字符串转换成大写形式.语法 :str.toUpperCase()12345let str_1 = 'Hello World !'.toUpperCase();console.log('str_1', str_1);// str_1 HELLO WORLD !String.prototype.toString()描述 :将指定对象转换成字符串形式.语法 :str.toString()12345let str_1 = new String('Hello World !');console.log('str_1', str_1, 'str_1.toString()', str_1.toString());// str_1 [String: 'Hello World !'] str_1.toString() Hello World !(不同浏览器展现效果可能不同)String.prototype.valueOf()描述 :返回一个String对象的原始值（primitive value）.语法 :str.valueOf()123456let str = new String('Hello World!');let str_1 = str.valueOf();console.log('str_1', str_1);// str_1 Hello World!String.prototype[@@iterator]()描述 :返回一个String对象的原始值（primitive value）.语法 :str.valueOf()12345678910111213141516171819202122let str = 'Hello World!';let str_1 = str[Symbol.iterator]();console.log('str_1', str_1.next());// str_1 &#123; value: 'H', done: false &#125;for(let item of str) &#123; console.log('item', item);&#125;// item H// item e// item l// item l// item o// item// item W// item o// item r// item l// item d// item !]]></content>
      <categories>
        <category>API总结</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>字符串原型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VS Code使用基础]]></title>
    <url>%2FVS-Code%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[工欲善其事, 必先利其器. 作为一个前端程序猿打造一个好看好用的编辑器, 对于工作效率的提高有很大的帮助.主题字体字体选用的FiraCode, 下载安装然后参见VS Code Instructions相关设置. 其它好看的字体还有Source Code Pro等.颜色主题和文件图标主题颜色主题选用的是One Dark Pro. 编辑器内置了几款颜色主题, 如果没有喜欢的就在扩展主题里找找.文件图标主题配置同颜色主题配置.用户设置Commonly Used控制字段控制内容files.autoSave自动保存editor.tabSize制表符的空格数editor.renderWhitespace空白字符显示方式editor.wordWrap换行方式files.exclude配置排除的文件和文件夹的 glob 模式. 不需要关心的文件或文件夹在此排除.files.associations配置语言的文件关联. eg:&quot;**.jsp&quot;: &quot;javascript&quot;files.trimTrailingWhitespace启用后，将在保存文件时剪裁尾随空格workbench.editor.labelFormat控制编辑器标签的格式window.openFilesInNewWindow控制是否在新窗口中打开文件terminal.integrated.shell.osx终端在 macOS 上使用的 Shell 的路径breadcrumbs.enabled启用/禁用导航路径(面包屑)emmet.includeLanguages在默认不支持 Emmet 的语言中启用 Emmet 缩写功能. eg:&quot;vue-html&quot;: &quot;html&quot;, &quot;javascript&quot;: &quot;javascriptreact&quot;编辑器控制字段控制内容editor.formatOnType控制编辑器在键入一行后是否自动格式化该行editor.minimap.enabled是否显示小地图editor.mouseWheelZoom按住 Ctrl 键并滚动鼠标滚轮时对编辑器字体大小进行缩放editor.parameterHints.enabled在输入时显示含有参数文档和类型信息的小面板files.exclude配置排除的文件和文件夹的 glob 模式. 不需要关心的文件或文件夹在此排除.files.associations配置语言的文件关联. eg:`”.jsp”: “javascript”`*快捷键关键字快捷键删除行cmd + D合并行ctrl + J光标后退ctrl + _光标前进ctrl + shift + _向下面插入行cmd + enter向上面插入行cmd + shift + enter转到文件cmd + P显示所有命令cmd + shift + P文件查找cmd + F全局搜索cmd + shift + F切换行注释cmd + /切换块注释shift + alt + A撤销cmd + Z恢复撤销cmd + shift + Z缩进tab缩进shift + tab移动到行尾cmd + right移动到行首cmd + left向上移动行cmd + up向下移动行cmd + down保持打开状态(workbench.action.keepEditor)cmd + K enter打开集成终端ctrl + `集成终端清屏cmd + K格式化文件shift + alt + F常见操作窗口code命令VS Code快速打开文件夹或文件,可以将其直接拖至VS Code图标上. 或cmd + shift + P打开命令面板, 向Path添加code, 用code命令操作.文件对比工作区可以将其它项目与当前项目置于同一工作区, 在同一个窗口查看编辑.自定义终端在Mac终端改造里, 已经打造好了个性化的终端了. 在VS Code里只需要换个路径即可.在用户设置里用以下配置覆盖.1"terminal.integrated.shell.osx": "/bin/zsh",添加自定义snippetVS Code内置了自定义snippet功能, 用户可以根据自己的需求去添加自己想要的代码段, 灵活且方便, 这样就完全没有必要去安装类似的插件了. 细节可参考[VS Code]跟我一起在Visual Studio Code 添加自定义snippet（代码段），附详细配置.插件Chinese (Simplified) Language Pack for VS Code此中文（简体）语言包为 VS Code 提供本地化界面.Bookmarks在代码中做标记, 可以在不同的标记中快速便捷的切换.Auto Rename Tag修改HTML/XML标签时, 首尾标签会自动同步更改.ESLint一个开源的 JavaScript 代码检查插件, 可以在编写或保存文件时对文件进行检测. 根据规则配置文件对文件进行检测提示, 并可以自动修复部分不符合规则的部分.&quot;eslint.options&quot;: { &quot;configFile&quot;: &quot;**/**/**&quot; } : 本地的配置文件地址路径.eslint.validate: 可被识别的文件类型.eslint.autoFixOnSave: 保存时自动修复.Debugger for Chrome在代码里断点, 就是相对地知道文件在哪里吧, Chrome里打断点还是挺好用地. Debugger for Chrome 配置可参见官网例子.插件什么的真的不见得能提高多少效率, 讲真, 颜值才是正义, 颜值才是王道🤔.]]></content>
      <categories>
        <category>善事利器</category>
      </categories>
      <tags>
        <tag>编辑器</tag>
        <tag>Visual Studio Code</tag>
        <tag>VS Code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[观察者模式再次进阶]]></title>
    <url>%2F%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E5%86%8D%E6%AC%A1%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[发布/订阅者模式发布/订阅模式概念说起观察者模式, 往往会牵扯到发布/订阅模式. 两者存在着很多的相似之处, 它们都是维护着一个列表, 然后都可以对列表的对象进行增删和通知. 不同的地方可能就在于处理添加和通知的方式上吧.发布/订阅模式使用了一个主题/事件通道, 这个通道介于希望接到通知的对象(订阅者)和激活事件的对象(发布者)之间. 该事件系统允许代码定义应用程序的特定事件, 这些事件可以传达自定义参数, 自定义参数包含订阅者所需的值. 其目的是避免订阅者和发布者之间产生依赖关系. ———《设计模式: 可复用面向对象软件基础》戏说发布/订阅模式模式以下所有代码参见publish/subscribe.既然和观察者模式类似, 那么在从观察者模式说起提到的小故事, 就可以接着往下续了.subject1带着那么一拨人回去复命, 经过一段时间的磨合实践, 效果也是很明显. 附近的公司听到风声后, 也纷纷组织派遣员工前来学习. 人多了, 需求也变多了, 这么多人肯定不能再呆在一起学习了. 原来只是一个公司的人呆在一间屋子里学习, 得到命令后大家开始各司其职. 现在, 各个公司的学习内容不同, 它们理应独立开来. 因为各个公司动作可以不同步, 但公司内部一定要同步起来. 为了区别对待, 每个公司都有能和别人区分的令牌, 有了令牌同一个公司的人就可以进入与令牌相对应的房间了(当然一个人也可以有很多令牌, 商业间谍吧😂).1234567// 我是Pubsub, 我负责管理这拨人.class Pubsub &#123; constructor() &#123; // 维护事件列表, 这里将以对象的形式出现, key: value, key: 令牌, value: 同一公司员工列表. this. handles = &#123;&#125; &#125;&#125;现在, 不同公司的人前来学习的时候, 需要告诉Pubsub他们公司的令牌号, 进而引领到令牌对应的房间.12345678910class Pubsub &#123; // 省略 // 注册事件. 如果是公司第一次派人过来, 那就新开一间. subscribe(type, handle) &#123; if (!this.handles[type]) &#123; this.handles[type] = [] &#125; this.handles[type].push(handle) &#125;&#125;如果某个房间的某个人, 或整个房间的人都不打算来了, 也需要Pubsub将其注销.12345678910111213class Pubsub &#123; // 省略 // 注销事件. 公司个人或整体注销. unsubscribe(type, handle) &#123; let pos = this.handles[type].indexOf(handle) if (!handle) &#123; // 不传handle, 则默认注销所有和type事件相关的事件处理函数. this.handles.length = 0 &#125; else &#123; ~pos &amp;&amp; this.handles[type].splice(pos, 1) &#125; &#125;&#125;不同的团体做出了区分, 算是万事具备. 想要哪个房间里的人动起来, 有了令牌号, 只要对着吼一嗓子即可.123456789101112class Pubsub &#123; // 省略 // 通知事件 publish() &#123; // 执行所有和type事件相关的处理函数. let type = Array.prototype.shift.call(arguments) this.handles[type].forEach(handle =&gt; &#123; // 箭头函数不绑定Arguments对象 handle.apply(this, arguments) &#125;) &#125;&#125;让我们看看效果如何.12345678910111213141516171819202122232425let handle1 = (...rest) =&gt; &#123;document.write('handle1', JSON.stringify(rest), '&lt;br/&gt;')&#125;let handle2 = (...rest) =&gt; &#123;document.write('handle2', JSON.stringify(rest))&#125;let ps = new Pubsub()ps.subscribe('notify-1', handle1)ps.subscribe('notify-1', handle2)ps.subscribe('notify-2', handle2)ps.unsubscribe('notify-1', handle2)ps.publish('notify-1', 'hahaha', 'heiheihei', [], &#123;&#125;)ps.publish('notify-2', 'hehehehehe')// 结果:handle1["hahaha","heiheihei",[],&#123;&#125;]handle2["hehehehehe"]不难发现, 我们的Pubsub老师只认令牌😅.]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>观察者模式</tag>
        <tag>发布/订阅模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac终端改造]]></title>
    <url>%2FMac%E7%BB%88%E7%AB%AF%E6%94%B9%E9%80%A0%2F</url>
    <content type="text"><![CDATA[平时Mac使用的shell使bash, 它虽然能满足我们的需要, 但是使用起来不是很方便. zsh可配置性强, 用户可以自定义配置, 个性化强.更换shell查看当前使用的shellecho $SHELL1/bin/bash查看系统当前内置的shellcat /etc/shells123456/bin/bash/bin/csh/bin/ksh/bin/sh/bin/tcsh/bin/zsh如果没有发现/bin/zsh, 就需要手动安装Zsh.替换shellchsh -s /bin/zsh12Changing shell for **.Password for **: your password重启echo $SHELL1/bin/zsh替换成功!安装oh-my-zshoh-my-zsh用来管理Zsh配置的.安装sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;.1234567891011121314Looking for an existing zsh config...Using the Oh My Zsh template file and adding it to ~/.zshrc __ ______ / /_ ____ ___ __ __ ____ _____/ /_/ __ \/ __ \ / __ `__ \/ / / / /_ / / ___/ __ \/ /_/ / / / / / / / / / / /_/ / / /_(__ ) / / /\____/_/ /_/ /_/ /_/ /_/\__, / /___/____/_/ /_/ /____/ ....is now installed!Please look over the ~/.zshrc file to select plugins, themes, and options.p.s. Follow us at https://twitter.com/ohmyzsh.p.p.s. Get stickers and t-shirts at https://shop.planetargon.com.更改配置vim ~/.zshrc12345678910111213141516171819202122232425# Set name of the theme to load --- if set to "random", it will# load a random theme each time oh-my-zsh is loaded, in which case,# to know which specific one was loaded, run: echo $RANDOM_THEME# See https://github.com/robbyrussell/oh-my-zsh/wiki/ThemesZSH_THEME="robbyrussell"# Uncomment the following line to disable bi-weekly auto-update checks.# DISABLE_AUTO_UPDATE="true"# Uncomment the following line to enable command auto-correction.ENABLE_CORRECTION="true"# Uncomment the following line to display red dots whilst waiting for completion.COMPLETION_WAITING_DOTS="true"# Which plugins would you like to load?# Standard plugins can be found in ~/.oh-my-zsh/plugins/*# Custom plugins may be added to ~/.oh-my-zsh/custom/plugins/# Example format: plugins=(rails git textmate ruby lighthouse)# Add wisely, as too many plugins slow down shell startup.plugins=(git)source $ZSH/oh-my-zsh.sh以上是部分配置, 需将#删除才能生效. 键入i进入编辑模式, 修改后esc退出编辑模式, 键入:wq保存退出. oh-my-zsh有支持的主题和插件, 可以自由配置.插件推荐zsh-syntax-highlighting安装zsh-syntax-highlightinggit clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting修改配置(zsh-syntax-highlighting)vim ~/.zshrc123plugins=( git zsh-syntax-highlighting)让修改生效(zsh-syntax-highlighting)source ~/.zshrczsh-autosuggestions安装zsh-autosuggestionsgit clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions修改配置(zsh-autosuggestions)vim ~/.zshrc123plugins=( git zsh-autosuggestions zsh-syntax-highlighting)让修改生效(zsh-autosuggestions)source ~/.zshrc好了, 打完收工!]]></content>
      <categories>
        <category>善事利器</category>
      </categories>
      <tags>
        <tag>Mac终端</tag>
        <tag>oh-my-zsh</tag>
        <tag>zsh</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进击的观察者模式]]></title>
    <url>%2F%E8%BF%9B%E5%87%BB%E7%9A%84%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[商品信息改变带来的烦恼Talk is cheap. Show me the code. (译: 屁话少说, 放码过来)以下所有代码参见Design pattern transformation.12345678910111213141516171819202122232425// 商品的信息: 价格 &amp; 折扣const data = &#123; price: 100, discount: 0.8&#125;// 顾客信息: 是否为会员 &amp; 购买数量 &amp; 总消费 &amp; 购买时间戳const customer = &#123; "VIP": true, "quantity": 10, "total": 0,&#125;// 总消费计算方式total = (info) =&gt; &#123; if(!info.VIP) &#123; info.total = data.price * info.quantity; &#125; else &#123; info.total = data.price * data.discount * info.quantity; &#125;&#125;total(customer);console.log('customer', customer);// customer &#123; VIP: true, quantity: 10, total: 800 &#125;从代码中很容易看得出来, 我们就是想实现一个简单的计费功能. 可现实中, 商品的价格可能并不是一成不变的.data.price = 200价格变动后, 我们需要及时地获取总消费, 那么就必须重新调用下 total 计费.123total(customer);console.log('customer', customer);// customer &#123; VIP: true, quantity: 10, total: 1600 &#125;这是一个大数据时代, 任何数据都有价值. 现在, 我们还想要每次购买时的时间点.12345678910 const customer = &#123; "VIP": true, "quantity": 10, "total": 0,+ "timeStamp": 0 &#125; // 获取购买时间 purchaseTime = (info) =&gt; &#123; info.timeStamp = Date.now(); &#125;于是, 我们需要执行的函数就多了一个.1234total(customer)purchaseTime(customer)console.log('customer', customer)// &#123; VIP: true, quantity: 10, total: 1600, timeStamp: 1542293676297 &#125;如果我们的需求还有很多, 而且不知一个customer呢. 那么, 每次价格变化我们需要执行很多步骤, 每次啊, 麻烦得很.1234567891011121314151617181920+ const customer1 = &#123;+ "VIP": false,+ "quantity": 8,+ "total": 0,+ "timeStamp": 0+ &#125; total(customer) purchaseTime(customer) func(customer) ... funcN(customer1) total(customer1) purchaseTime(customer1) func(customer1) ... funcN(customer) ... funcN(customerN)现在我们就对上面的代码进行观察者模式改造.用观察者模式改造从上面的例子中🌰🀄️不难看出, 每次价格变化时, 我们都需要重复调用满足需求的方法. 不妨想想, 如果我们把这些方法存储起来, 等到价格变化时再去统一调用, 岂不是很方便. 那么问题来了, 这和之前所说的观察者模式(从观察者模式说起)有什么区别呢? 在此, 我们试着用观察者模式改造下.首先观察者模式都是一个套路. 先一个类维护一个列表, 对列表有增删和通知更新功能. 另一个类则是提供了更新接口.123456789101112131415161718192021// 观察目标类class Subject &#123; constructor() &#123; this.observerList = [] &#125; addObserver(observer) &#123; this.observerList.push(observer) &#125; notify(params) &#123; this.observerList.forEach(observer =&gt; &#123; observer.update(params) &#125;) &#125;&#125;// 观察者类class Observer &#123; constructor(fn) &#123; this.update = fn &#125;&#125;接着, 把我们想要调用的方法包装一下, 存储起来.12345678// 将要重复使用的包装一下observer1 = new Observer(total)observer2 = new Observer(purchaseTime)// 存起来let subject = new Subject()subject.addObserver(observer1)subject.addObserver(observer2)每次价格改变时, 只需要通知一下即可.1234// 调整商品价格data.price = 100subject.notify(customer)subject.notify(customer1)改造结束. 初看起来, 可能变得繁琐了. 但是, 遇到复杂的情况, 这不失是一个好办法. 接下来, 我们看看结合Objec.defineProperty会有什么惊喜.与Objec.defineProperty结合支付宝的花呗都可以自己还钱了🤣, 我们为什么还要别人管着😏. 大家都知道经过Objec.defineProperty处理的对象, 在设置和获取对象属性的时候, 会自动触发响应set和get方法. 利用这一点, 我们就可以做到生活自理了. 熟悉的配方, 熟悉的味道. 熟悉的套路我们不妨再走一遍.123456789101112131415161718192021// 观察目标类class Dependency &#123; constructor() &#123; this.watcherList = [] &#125; addObserver(observer) &#123; this.watcherList.push(observer) &#125; notify(params) &#123; this.watcherList.forEach(watcher =&gt; &#123; watcher.update(params) &#125;) &#125;&#125;// 观察类class Watcher &#123; constructor(fn) &#123; this.update = fn &#125;&#125;我们此行的目的, 是要在data.price 或data.discount改变时, 程序能够自动触发, 得到我们想要的结果. 换句话说, 通知更新的时机是在设置data.price或data.discount的时候.12345678910111213 Object.keys(data).forEach(key =&gt; &#123; let value = data[key] const dep = new Dependency() Object.defineProperty(data, key, &#123; set(newVal) &#123; value = newVal dep.notify() &#125;, get() &#123; return value &#125; &#125;)&#125;)对象的每个属性都给了一个依赖实例, 管理自己的依赖. 考虑到customer有很多个, 需要通知到位. 另外, 添加依赖和管理依赖, 前者是因, 后者是果. 在管理之前我们需要想好怎么添加依赖. 回头看一看.123456789101112 // 总消费计算方式 total = (info) =&gt; &#123; if(!info.VIP) &#123; info.total = data.price * info.quantity; &#125; else &#123; info.total = data.price * data.discount * info.quantity; &#125; &#125; // 获取购买时间purchaseTime = (info) =&gt; &#123; info.timeStamp = Date.now();&#125;我们发现, total 函数依赖于data.price或data.discount的. 如果我们在获取属性时去添加依赖倒是一个好时机.1234567891011121314151617181920212223242526272829303132333435 class Dependency &#123; // 省略 &#125;+ Dependency.targey = null;class Watcher &#123; constructor(fn, key) &#123; this.update = fn+ this.key = key+ this.value = this.getter() &#125;+ getter() &#123;+ Dependency.targey = this;+ // 触发下面的get()+ this.value = data[this.key];+ Dependency.targey = null;+ &#125;&#125;Object.keys(data).forEach(key =&gt; &#123; let value = data[key] const dep = new Dependency() Object.defineProperty(data, key, &#123; set(newVal) &#123; value = newVal dep.notify() &#125;, get() &#123;+ if (Dependency.targey) &#123;+ dep.addObserver(Dependency.targey)+ &#125; return value &#125; &#125;)&#125;)然而 purchaseTime 方法里并没有data.price或data.discount可以设置. 所以这个方法行不通. 那么, 干脆紧接着依赖实例去添加依赖吧. 同时考虑到多个customer, 我们封装下.1234567891011121314151617181920212223// 与defineProperty结合function defineReactive(data, watcherList, funcList) &#123; Object.keys(data).forEach(key =&gt; &#123; let value = data[key] const dep = new Dependency() funcList.forEach(func =&gt; &#123; dep.addObserver(new Watcher(func)) &#125;) Object.defineProperty(data, key, &#123; set(newVal) &#123; value = newVal watcherList.forEach(watcher =&gt; &#123; dep.notify(watcher) &#125;) &#125;, get() &#123; return value &#125; &#125;) &#125;)&#125;defineReactive(data, [customer, customer1], [total, purchaseTime])大功告成, 价格变动时, 我们就会自动获取到想要的结果了. 我都能自理了, 你花呗为嘛还不能自己还钱呢😒]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>观察者模式</tag>
        <tag>Object.defineProperty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从观察者模式说起]]></title>
    <url>%2F%E4%BB%8E%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E8%AF%B4%E8%B5%B7%2F</url>
    <content type="text"><![CDATA[观察者模式观察者模式的定义Observer(观察者)是一种设计模式, 其中, 一个对象(称为 subject) 维持一系列依赖于它的观察者对象, 将有关状态的任何变更自动通知给观察者.当一个目标(subject)需要告诉观察者发生了什么有趣的事情, 它会向观察者广播一个通知. 当我们不再希望某个特定的观察者获得其注册目标(subject)发出的改变通知时, 该目标可以将它从观察者列表中删除.“一个或多个观察者对目标的状态感兴趣, 它们通过将自己依附在目标对象上以便注册所感兴趣的内容. 目标状态发生改变并且观察者可能对这些改变感兴趣, 就会发送一个通知消息, 调用每个观察者的更新方法. 当观察者不再对目标状态感兴趣时, 它们可以简单地将自己从中分离.” ———《设计模式: 可复用面向对象软件基础》观察者模式的理解从观察者模式的定义中可以对观察者模式有个大体的了解. 观察者模式中有两类, 一类被称为目标(Subject), 一类被称为观察者(Observer). Subject的工作是维护一系列的Observer, 可以对它们进行添加、删除和通知的操作. Observer的工作则是为Subject状态发生变化需要获得通知的对象提供更新接口.戏说观察者模式先不管观察者模式是什么, 我们可以试着想想如何从观察者模式的定义去实现这些功能. 下面我们从一个小故事说起.从前有个人. 凭着天资聪颖再加上闯荡江湖多年, 无论从事什么行业都能称为行业翘楚, 算是有名气的人物.1class Subject &#123;&#125; // 我是有个人. Subject是江湖送我的绰号.有一天, 有一个初创公司慕名前来拜访, 探讨如何在现在这个激烈的竞争环境下赢得一席之地.1class Observer &#123;&#125; // 我是一家初创公司, Observer是我公司的名字.两人见面直奔主题.‘你可以派些人来, 我给他们做培训. ’, Subject如此说道. Observer点头同意.‘可是我如何才能让他们服从并执行呢?’, Subject问到. ‘我们可以向你提供统一的对接方式’, Observer回答到.‘行, 谁要有兴趣谁就过来吧’12345678/* update是我们的对接方式, fn是我们的职能.只需要走update这个流程, 我们会各司其职.下面这是个我们的模子, 每个走出去的人都大体这样.*/class Observer &#123; constructor(fn) &#123; this.update = fn &#125;&#125;为了后续的开展, 夜曉宸也做了准备. 为随后要来的人腾出了空间, 并想好了如何接待每个人.12345678class Subject &#123; constructor() &#123; this.observesList = []; // 这里是为参与者腾出的空间. &#125; addObserver(observer) &#123; this.observerList.push(observer); // 招待每一个参与者, 就是引导参与者进入腾出的空间. &#125;&#125;不日, Observer派人带着各自本职职务过来了.123const observer1 = new Observer(() =&gt; &#123;document.write(`$&#123;order&#125;: 我是财务, 我要开始算绩效发工资了&lt;br/&gt;`));const observer2 = new Observer(() =&gt; &#123;document.write(`$&#123;order&#125;: 我是后勤客服, 有什么事情需要帮助的?&lt;br/&gt;`));const observer3 = new Observer(() =&gt; &#123;document.write(`$&#123;order&#125;: 我是人事, 我要招人了&lt;br/&gt;`));既然人来了, 那就接待.1234const subject = new Subject(); // 事务繁忙, 派了一个影分身.subject.addObserver(observer1); // 引导observer1进入房间.subject.addObserver(observer2); // 引导observer2进入房间.subject.addObserver(observer3); // // 引导observer3进入房间.‘既然来到了这个房间, 就要明确一点, 那就是你们得听我指令, 到时我会使用你们公司统一的对接方式’1234567class Subject &#123; // 省略 notify(context) &#123; // 由公司提供的统一对接方式，向在场的每一个Observer传达并让其执行. this.observerList.forEach(observer =&gt; observer.update(context)); &#125;&#125;‘如果你们不想呆下去了, 可以和我说, 我可以引导你们出去’12345678class Subject &#123; // 省略 removeObserver(observer) &#123; // 对于不再感兴趣的Observer，可以将其剔除，其不会再收到任何来自Subject的通知. let pos = this.observerList.indexOf(observer); this.observerList.splice(pos, 1); &#125;&#125;‘现在, 要下达指令了!’12// 省略subject.notify('描述下各自的职能');‘好了, 这些就是我们培训的内容, 就是这么简单’‘就这么简单?!?, 既然这样, 就送我出去吧, 我不想再呆下去了 ’, observer2说到.12// 省略subject.removeObserver(observer2);到此故事告一段落了, Observer模式在线Demo.再看观察者模式我们从几段对话中, 稀里糊涂的完成了本文开头观察者模式所定义的那样. 有负责管理一系列依赖的对象, 有提供更新接口的对象. 我们可以看到, 当subject1发出通知时, 每个observe都能去执行. observer们的行为依赖于subject1的. 为什么能够做到这一点, 那是因为observe们的行为作为自身的一部分寄存在了subject1, subject1就可以在需要的时候去自己腾出的小屋子里通知observer们执行.如果subject1 带着这么一波参加过培训的observer们回去交差, 肯定会被笑话. subject1和observer们的这种协作方式, 被称做观察者模式. 这不过是一个模式, 何时存储何种东西, 何时又去执行存储的东西那才是关键. 如果放到上面的小故事里, 那就是何时需要何种人, 何时开始去做事, 这都需要审时度势. 只有这样公司才能在激烈的竞争环境中赢得一席之地. 只有这样, 观察者模式才能发挥它最大的作用.]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>观察者模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Array原型之迭代方法]]></title>
    <url>%2FArray%E5%8E%9F%E5%9E%8B%E4%B9%8B%E8%BF%AD%E4%BB%A3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[ArrayArray对象是用于构造数组的全局对象.概述数组对象是一个有序的数据(原始类型或对象类型)集合, 是一种类列表对象,它的原型提供了数组操作的方法.数组只能用整数作为数组元素的索引,而不是字符串,且从0开始,第一个元素的索引为0.使用非整数并通过[]或.来访问数组或设置数组元素时,所操作的并不是数组列表的元素,而是数组对象属性集合上的变量.数组对象的属性和数组元素列表是分开存储的,并且数组的遍历和修改操作也不能作用于这些命名属性.123456var arr = [];arr['zero'] = 'zero';arr[0] = 0;arr.forEach(item =&gt; console.log(item))// 0原型方法迭代方法Array.prototype.forEach()语法 :array.forEach(callback(currentValue[, index[, array]]){ // do something }[, thisArg])callback : 数组中每个元素都会执行的回调函数.currentValue : 数组中正在被处理的当前元素.index : 数组中正在被处理的当前元素的索引.array : 调用该方法的数组.thisArg : 执行回调函数时this对应的对象. 如果省略了 thisArg 参数, 或者赋值为 null 或 undefined, 则 this 指向全局对象.返回值 :123456789101112let obj = &#123;name: 'obj'&#125;;let arr0 = [3, 2, 1];let arr00 = arr0.forEach(function(currentValue, index, array)&#123; console.log('arr0:', arr0,'currentValue:', currentValue, 'index:', index, 'array:', array, 'thisArg:', this);&#125;, obj);console.log('arr00:', arr00);// arr0: [ 3, 2, 1 ] currentValue: 3 index: 0 array: [ 3, 2, 1 ] thisArg: &#123;name: 'obj' &#125;;// arr0: [ 3, 2, 1 ] currentValue: 2 index: 1 array: [ 3, 2, 1 ] thisArg: &#123;name: 'obj' &#125;;// arr0: [ 3, 2, 1 ] currentValue: 1 index: 2 array: [ 3, 2, 1 ] thisArg: &#123;name: 'obj' &#125;;// arr00: undefined;Array.prototype.map()语法 :array.map(callback(currentValue[, index[, array]]){ // do something }[, thisArg])callback : 数组中每个元素都会执行的回调函数.currentValue : 数组中正在被处理的当前元素.index : 数组中正在被处理的当前元素的索引.array : 调用该方法的数组.thisArg : 执行回调函数时this对应的对象. 如果省略了 thisArg 参数, 或者赋值为 null 或 undefined, 则 this 指向全局对象.返回值 : 由每个数组元素调用callback后的返回值组成的新数组.1234567891011121314let obj = &#123;name: 'obj'&#125;;let arr0 = [3, 2, 1];let arr00 = arr0.map(function(currentValue, index, array)&#123; let newVal = currentValue * 2; console.log('arr0:', arr0, 'currentValue:', currentValue, 'index:', index, 'array:', array, 'newVal:', newVal, 'thisArg:', this); return newVal;&#125;, obj);console.log('arr00:', arr00);// arr0: [ 3, 2, 1 ] currentValue: 3 index: 0 array: [ 3, 2, 1 ] newVal: 6 thisArg: &#123; name: 'obj' &#125;;// arr0: [ 3, 2, 1 ] currentValue: 2 index: 1 array: [ 3, 2, 1 ] newVal: 4 thisArg: &#123; name: 'obj' &#125;;// arr0: [ 3, 2, 1 ] currentValue: 1 index: 2 array: [ 3, 2, 1 ] newVal: 2 thisArg: &#123; name: 'obj' &#125;;// arr00: [ 6, 4, 2 ]Array.prototype.every()语法 :array.every(callback(currentValue[, index[, array]]){ // do something }[, thisArg])callback : 数组中每个元素都会执行的回调函数.currentValue : 数组中正在被处理的当前元素.index : 数组中正在被处理的当前元素的索引.array : 调用该方法的数组.thisArg : 执行回调函数时this对应的对象. 如果省略了 thisArg 参数, 或者赋值为 null 或 undefined, 则 this 指向全局对象.返回值 : 布尔值. 由数组中每个元素调用callback后, 当所有的元素都符合条件(真值)才返回true. 否则, 返回false. 另外, 对于放在空数组上的任何条件, 此方法返回 true.1234567891011121314151617181920212223242526272829303132let obj = &#123; name: 'obj'&#125;let arr0 = [3, 2, 1];let arr00 = arr0.every(function(currentValue, index, array)&#123; let newVal = currentValue * 3; console.log('arr0:', arr0, 'currentValue:', currentValue, 'index:', index, 'array:', array, 'newVal:', newVal, 'thisArg:', this); return newVal &gt; 2;&#125;, obj)console.log('arr00:', arr00);// arr0: [ 3, 2, 1 ] currentValue: 3 index: 0 array: [ 3, 2, 1 ] newVal: 9 thisArg: &#123; name: 'obj' &#125;// arr0: [ 3, 2, 1 ] currentValue: 2 index: 1 array: [ 3, 2, 1 ] newVal: 6 thisArg: &#123; name: 'obj' &#125;// arr0: [ 3, 2, 1 ] currentValue: 1 index: 2 array: [ 3, 2, 1 ] newVal: 3 thisArg: &#123; name: 'obj' &#125;// arr00: true;let obj = &#123; name: 'obj'&#125;let arr0 = [3, 2, 1];let arr00 = arr0.every(function(currentValue, index, array)&#123; let newVal = currentValue * 3; console.log('arr0:', arr0, 'currentValue:', currentValue, 'index:', index, 'array:', array, 'newVal:', newVal, 'thisArg:', this); return newVal &gt; 6;&#125;, obj)console.log('arr00:', arr00);// arr0: [ 3, 2, 1 ] currentValue: 3 index: 0 array: [ 3, 2, 1 ] newVal: 9 thisArg: &#123; name: 'obj' &#125;;// arr0: [ 3, 2, 1 ] currentValue: 2 index: 1 array: [ 3, 2, 1 ] newVal: 6 thisArg: &#123; name: 'obj' &#125;;// arr00: false;Array.prototype.some()语法 :array.some(callback(currentValue[, index[, array]]){ // do something }[, thisArg])callback : 数组中每个元素都会执行的回调函数.currentValue : 数组中正在被处理的当前元素.index : 数组中正在被处理的当前元素的索引.array : 调用该方法的数组.返回值 : 布尔值. 由数组中每个元素调用callback后, 当有元素符合条件(真值)就返回true. 否则, 返回false. 另外, 对于放在空数组上的任何条件, 此方法返回 false.12345678910111213141516171819202122232425262728293031let obj = &#123; name: 'obj'&#125;let arr0 = [3, 2, 1];let arr00 = arr0.some(function(currentValue, index, array)&#123; let newVal = currentValue * 3; console.log('arr0:', arr0, 'currentValue:', currentValue, 'index:', index, 'array:', array, 'newVal:', newVal, 'thisArg:', this); return newVal &gt; 6;&#125;, obj)console.log('arr00:', arr00);// arr0: [ 3, 2, 1 ] currentValue: 3 index: 0 array: [ 3, 2, 1 ] newVal: 9 thisArg: &#123; name: 'obj' &#125;;// arr00: true;let obj = &#123; name: 'obj'&#125;let arr0 = [3, 2, 1];let arr00 = arr0.some(function(currentValue, index, array)&#123; let newVal = currentValue * 3; console.log('arr0:', arr0, 'currentValue:', currentValue, 'index:', index, 'array:', array, 'newVal:', newVal, 'thisArg:', this); return newVal &gt; 9;&#125;, obj)console.log('arr00:', arr00);// arr0: [ 3, 2, 1 ] currentValue: 3 index: 0 array: [ 3, 2, 1 ] newVal: 9 thisArg: &#123; name: 'obj' &#125;;// arr0: [ 3, 2, 1 ] currentValue: 2 index: 1 array: [ 3, 2, 1 ] newVal: 6 thisArg: &#123; name: 'obj' &#125;;// arr0: [ 3, 2, 1 ] currentValue: 1 index: 2 array: [ 3, 2, 1 ] newVal: 3 thisArg: &#123; name: 'obj' &#125;;// arr00: false;Array.prototype.filter()语法 :arr.filter(callback(currentValue[, index[, array]])[, thisArg])callback : 数组中每个元素都会执行的回调函数.currentValue : 数组中正在被处理的当前元素.index : 数组中正在被处理的当前元素的索引.array : 调用该方法的数组.返回值 : 数组中每个元素调用callback后, 由符合条件的数组元素组成的新数组.如果没有符合条件的元素, 则返回空数组.12345678910111213141516let obj = &#123; name: 'obj'&#125;let arr0 = [3, 2, 1];let arr00 = arr0.filter(function(currentValue, index, array)&#123; let boolean = currentValue &gt; 1 ? true : false; console.log('arr0:', arr0, 'currentValue:', currentValue, 'index:', index, 'array:', array, 'thisArg:', this); return boolean;&#125;, obj)console.log('arr00:', arr00);// arr0: [ 3, 2, 1 ] currentValue: 3 index: 0 array: [ 3, 2, 1 ] thisArg: &#123; name: 'obj' &#125;// arr0: [ 3, 2, 1 ] currentValue: 2 index: 1 array: [ 3, 2, 1 ] thisArg: &#123; name: 'obj' &#125;//arr0: [ 3, 2, 1 ] currentValue: 1 index: 2 array: [ 3, 2, 1 ] thisArg: &#123; name: 'obj' &#125;// arr00: [ 3, 2 ];Array.prototype.find()语法 :arr.find(callback(currentValue[, index[, array]])[, thisArg])callback : 数组中每个元素都会执行的回调函数.currentValue : 数组中正在被处理的当前元素.index : 数组中正在被处理的当前元素的索引.array : 调用该方法的数组.返回值 : 数组中每个元素调用callback后, 返回第一个符合条件的元素. 否则返回 undefined.1234567891011121314let obj = &#123; name: 'obj'&#125;let arr0 = [3, 2, 1];let arr00 = arr0.find(function(currentValue, index, array)&#123; let boolean = currentValue &gt; 1 ? true : false; console.log('arr0:', arr0, 'currentValue:', currentValue, 'index:', index, 'array:', array, 'thisArg:', this); return boolean;&#125;, obj)console.log('arr00:', arr00);// arr0: [ 3, 2, 1 ] currentValue: 3 index: 0 array: [ 3, 2, 1 ] thisArg: &#123; name: 'obj' &#125;;// arr00: 3;Array.prototype.findIndex()语法 :arr.findIndex(callback(currentValue[, index[, array]])[, thisArg])callback : 数组中每个元素都会执行的回调函数.currentValue : 数组中正在被处理的当前元素.index : 数组中正在被处理的当前元素的索引.array : 调用该方法的数组.返回值 : 数组中每个元素调用callback后, 返回第一个符合条件的元素索引. 否则返回 -1.1234567891011121314let obj = &#123; name: 'obj'&#125;let arr0 = [3, 2, 1];let arr00 = arr0.findIndex(function(currentValue, index, array)&#123; let boolean = currentValue &gt; 1 ? true : false; console.log('arr0:', arr0, 'currentValue:', currentValue, 'index:', index, 'array:', array, 'thisArg:', this); return boolean;&#125;, obj)console.log('arr00:', arr00);// arr0: [ 3, 2, 1 ] currentValue: 3 index: 0 array: [ 3, 2, 1 ] thisArg: &#123; name: 'obj' &#125;;// arr00: 0;Array.prototype.reduce()语法 :arr.reduce(callback(accumulator[, currentValue[, index[, array]]])[, initialValue])callback : 数组中每个元素都会执行的回调函数.accumulator : 上一个元素调用回调函数后的返回值. 回调函数第一次执行时, 若提供了initialValue,则accumulator取值为initialValue. 若没有提供initialValue, 则accumulator取值为数组中第一个元素.currentValue : 数组中正在被处理的当前元素. 回调函数第一次执行时, 若提供了initialValue, 则currentValue取值为数组中第一个元素. 若没有提供initialValue, 则currentValue取值为数组中第二值.index : 数组中正在被处理的当前元素的索引.array : 调用该方法的数组.返回值 : 数组中每个元素调用callback后, 将上一次回调函数执行结果作为下一次回调函数参数, 并最终返回单个结果值.1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253let arr0 = [3, 2, 1];let arr00 = arr0.reduce(function(accumulator, currentValue, index, array) &#123; console.log('arr0', arr0, 'accumulator:', accumulator, 'currentValue:', currentValue, 'index:', index, 'array:', array); return accumulator + currentValue;&#125;, 0);console.log('arr00:', arr00);// arr0 [ 3, 2, 1 ] accumulator: 0 currentValue: 3 index: 0 array: [ 3, 2, 1 ];// arr0 [ 3, 2, 1 ] accumulator: 3 currentValue: 2 index: 1 array: [ 3, 2, 1 ];// arr0 [ 3, 2, 1 ] accumulator: 5 currentValue: 1 index: 2 array: [ 3, 2, 1 ];// arr00: 6;let arr0 = [3, 2, 1];let arr00 = arr0.reduce(function(accumulator, currentValue, index, array) &#123; console.log('arr0', arr0, 'accumulator:', accumulator, 'currentValue:', currentValue, 'index:', index, 'array:', array); return accumulator + currentValue;&#125;);console.log('arr00:', arr00);// arr0 [ 3, 2, 1 ] accumulator: 3 currentValue: 2 index: 1 array: [ 3, 2, 1 ];// arr0 [ 3, 2, 1 ] accumulator: 5 currentValue: 1 index: 2 array: [ 3, 2, 1 ];// arr00: 6;let arr0 = [1, 2, 3, 44, 5, 3, 2, 53, 1, 2, 3, 5, 44, 53, 55];const reducer = (accumulator, currentValue) =&gt; &#123; console.log('arr0', arr0, 'accumulator', accumulator, 'currentValue', currentValue); if (accumulator.length === 0 || accumulator[accumulator.length - 1] !== currentValue) &#123; accumulator.push(currentValue); &#125; return accumulator;&#125;;let arr00 = arr0.sort((a, b) =&gt; &#123;return a - b&#125;).reduce(reducer, []);console.log('arr00:', arr00);// arr0 [ 1, 1, 2, 2, 2, 3, 3, 3, 5, 5, 44, 44, 53, 53, 55 ] accumulator [] currentValue 1;// arr0 [ 1, 1, 2, 2, 2, 3, 3, 3, 5, 5, 44, 44, 53, 53, 55 ] accumulator [ 1 ] currentValue 1;// arr0 [ 1, 1, 2, 2, 2, 3, 3, 3, 5, 5, 44, 44, 53, 53, 55 ] accumulator [ 1 ] currentValue 2;// arr0 [ 1, 1, 2, 2, 2, 3, 3, 3, 5, 5, 44, 44, 53, 53, 55 ] accumulator [ 1, 2 ] currentValue 2;// arr0 [ 1, 1, 2, 2, 2, 3, 3, 3, 5, 5, 44, 44, 53, 53, 55 ] accumulator [ 1, 2 ] currentValue 2;// arr0 [ 1, 1, 2, 2, 2, 3, 3, 3, 5, 5, 44, 44, 53, 53, 55 ] accumulator [ 1, 2 ] currentValue 3;// arr0 [ 1, 1, 2, 2, 2, 3, 3, 3, 5, 5, 44, 44, 53, 53, 55 ] accumulator [ 1, 2, 3 ] currentValue 3;// arr0 [ 1, 1, 2, 2, 2, 3, 3, 3, 5, 5, 44, 44, 53, 53, 55 ] accumulator [ 1, 2, 3 ] currentValue 3;// arr0 [ 1, 1, 2, 2, 2, 3, 3, 3, 5, 5, 44, 44, 53, 53, 55 ] accumulator [ 1, 2, 3 ] currentValue 5;// arr0 [ 1, 1, 2, 2, 2, 3, 3, 3, 5, 5, 44, 44, 53, 53, 55 ] accumulator [ 1, 2, 3, 5 ] currentValue 5;// arr0 [ 1, 1, 2, 2, 2, 3, 3, 3, 5, 5, 44, 44, 53, 53, 55 ] accumulator [ 1, 2, 3, 5 ] currentValue 44;// arr0 [ 1, 1, 2, 2, 2, 3, 3, 3, 5, 5, 44, 44, 53, 53, 55 ] accumulator [ 1, 2, 3, 5, 44 ] currentValue 44;// arr0 [ 1, 1, 2, 2, 2, 3, 3, 3, 5, 5, 44, 44, 53, 53, 55 ] accumulator [ 1, 2, 3, 5, 44 ] currentValue 53;// arr0 [ 1, 1, 2, 2, 2, 3, 3, 3, 5, 5, 44, 44, 53, 53, 55 ] accumulator [ 1, 2, 3, 5, 44, 53 ] currentValue 53;// arr0 [ 1, 1, 2, 2, 2, 3, 3, 3, 5, 5, 44, 44, 53, 53, 55 ] accumulator [ 1, 2, 3, 5, 44, 53 ] currentValue 55;// arr00: [ 1, 2, 3, 5, 44, 53, 55 ];Array.prototype.reduceRight()语法(从右向左遍历,见reduce) :arr.reduceRight(callback(accumulator[, currentValue[, index[, array]]])[, initialValue])Array.prototype.entries()语法 :arr.entries()返回值 : 一个新的包含数组中每个索引的键/值对的Array Iterator对象.1234567891011121314151617181920212223242526272829303132333435let arr0 = [3, 2, 1];let arr00 = arr0.entries();let arr000 = arr00.next();let arr0000 = arr000.value;console.log('arr00:', arr00);console.log('arr000:', arr000);console.log('arr0000:', arr0000);// arr00;// Array Iterator &#123;&#125;// __proto__: Array Iterator// next: ƒ next()// Symbol(Symbol.toStringTag): "Array Iterator"// arr000;// &#123;value: Array(2), done: false&#125;j;// arr0000;// [0, 3];let arr0 = [3, 2, 1];let arr00 = arr0.entries();for(let item of arr00) &#123; console.log(item);&#125;// [ 0, 3 ];// [ 1, 2 ];// [ 2, 1 ];let arr0 = [3, 2, 1];let arr00 = [...arr0.entries()];console.log('arr00:', arr00);// arr00: [ [ 0, 3 ], [ 1, 2 ], [ 2, 1 ] ]Array.prototype.keys()语法 :arr.keys()返回值 : 一个新的包含数组中每个索引键的Array Iterator对象.123456789101112131415let arr0 = [3, 2, 1];let arr00 = arr0.keys();for(let item of arr00) &#123; console.log(item);&#125;// 0// 1// 2let arr0 = [3, 2, 1];let arr00 = [...arr0.keys()];console.log('arr00:', arr00);// arr00: [ 0, 1, 2 ];Array.prototype.values()语法 :arr.values()返回值 : 一个新的包含数组每个索引对应值的 Array Iterator 对象.1234567891011121314let arr0 = [3, 2, 1];let arr00 = arr0.keys();for(let item of arr00) &#123; console.log(item);&#125;// 0// 1// 2let arr0 = [3, 2, 1];let arr00 = [...arr0.keys()];console.log('arr00:', arr00);// arr00: [ 0, 1, 2 ];Array.prototype[@@iterator]()语法 :arr[Symbol.iterator]()返回值 : 数组的 iterator 方法，默认情况下与 values() 返回值相同.]]></content>
      <categories>
        <category>API总结</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>数组原型</tag>
        <tag>迭代方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Array原型之非变异方法]]></title>
    <url>%2FArray%E5%8E%9F%E5%9E%8B%E4%B9%8B%E9%9D%9E%E5%8F%98%E5%BC%82%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[ArrayArray对象是用于构造数组的全局对象.概述数组对象是一个有序的数据(原始类型或对象类型)集合, 是一种类列表对象,它的原型提供了数组操作的方法.数组只能用整数作为数组元素的索引,而不是字符串,且从0开始,第一个元素的索引为0.使用非整数并通过[]或.来访问数组或设置数组元素时,所操作的并不是数组列表的元素,而是数组对象属性集合上的变量.数组对象的属性和数组元素列表是分开存储的,并且数组的遍历和修改操作也不能作用于这些命名属性.123456var arr = [];arr['zero'] = 'zero';arr[0] = 0;arr.forEach(item =&gt; console.log(item))// 0原型方法非变异方法Array.prototype.slice()描述 :浅拷贝数组指定区域的元素.语法 :arr.slice(begin[, end])begin(可选) : 起始索引, 默认值为0. 如果是负数, 则开始索引会被自动计算成为 this.length + start.end : 终止索引, 默认值 this.length. 不包括end位置. 如果是负数时, 规则如上.返回值 : 返回截取的新数组(浅复制).1234567891011let arr0 = [3, 2, 1];let arr00 = arr0.slice();console.log('arr0:', arr0, 'arr00:', arr00);// arr0: [ 3, 2, 1 ] arr00: [ 3, 2, 1 ]let arr1 = [5, 4, 3, 2, 1];let arr11 = arr1.slice(2, 3);console.log('arr1:', arr1, 'arr11:', arr11);// arr1: [ 5, 4, 3, 2, 1 ] arr11: [ 3 ].Array.prototype.concat()描述 :合并多个值或数组.语法 :array.concat(element0[, element1[, ...[, elementN]]])elementN : 将要连接的值或数组.返回值 : 多个值或数组合并后的新数组.12345678910111213let arr0 = [6, 5, 4];let arr1 = [3, 2, 1];let arr = arr0.concat(arr1);console.log('arr0:', arr0, 'arr1:', arr1, 'arr:', arr);// arr0: [ 6, 5, 4 ] arr1: [ 3, 2, 1 ] arr: [ 6, 5, 4, 3, 2, 1 ]let arr2 = [6, 5, 4];let arr3 = [2, 1];let arr = arr2.concat(3, arr3);console.log('arr2: ', arr2, 'arr3: ', arr3, 'arr', arr);// arr2: [ 6, 5, 4 ] arr3: [ 2, 1 ] arr [ 6, 5, 4, 3, 2, 1 ]Array.prototype.join()描述 :将数组众元素用指定字符连接成字符串.语法 :arr.join(connector)connector : 指定一个字符链接数组中的每个元素, 默认逗号连接.返回值 : 用指定连接符将数组中元素连接起来的字符串.1234567let arr0 = [3, 2, 1];let str1 = arr0.join();let str2 = arr0.join('');let str3 = arr0.join('-');console.log('arr0:', arr0, 'str1:', str1, 'str2:', str2, 'str3:', str3);// arr0: [ 3, 2, 1 ] str1: 3,2,1 str2: 321 str3: 3-2-1;Array.prototype.toString()描述 :用字符串形式表示数组元素.语法 :arr.toString()返回值 : 逗号连接数组元素组成的字符串. 当数组元素为数组时, 自动调用其toString()方法.123456let arr0 = [3, 2, 1];let arr00 = arr0.toString();let arr1 = [[6, [5, 4]], 3, 2, 1].toString();console.log('arr0:', arr0, 'arr00:', arr00, 'arr1:', arr1);// arr0: [ 3, 2, 1 ] arr00: 3,2,1 arr1: 6,5,4,3,2,1;Array.prototype.includes()描述 :判断数组中是否指定值.语法 :arr.includes(searchElement[, fromIndex])searchElement : 需要查询的值.fromIndex : 起始索引, 默认值为0. 如果是负数时, 规则如上.返回值 : 布尔值.123456let arr0 = [3, 2, 1];let a = arr0.includes(3);let b = arr0.includes(3, 1);console.log('arr0', arr0, 'a:', a, 'b:', b);// arr0 [ 3, 2, 1 ] a: true b: false;Array.prototype.indexOf()描述 :查询指定元素在数组中首次出现的索引位置.语法 :arr.indexOf(searchElement[, fromIndex])searchElement : 需要查询的值.fromIndex : 起始索引, 默认值为0. 如果是负数时, 规则如上.返回值 : 首次被找到的元素在数组中的索引位置; 若没有找到则返回 -1.123456let arr0 = [3, 2, 1];let a = arr0.indexOf(1);let b = arr0.indexOf(3, 1);console.log('arr0:', arr0, 'a:', a, 'b:', b);// arr0: [ 3, 2, 1 ] a: 2 b: -1;Array.prototype.lastIndexOf()描述 :从数组的后面向前查找, 查询指定元素在数组中首次出现的索引位置.语法 :arr.lastIndexOf(searchElement[, fromIndex = arr.length - 1])searchElement : 需要查询的值.fromIndex : 逆向查找起始索引, 默认值 this.length - 1.返回值 : 逆向首次被找到的元素在数组中的索引位置.123456let arr0 = [3, 2, 1];let a = arr0.lastIndexOf(1);let b = arr0.lastIndexOf(3, 1);console.log('arr0:', arr0, 'a:', a, 'b:', b);// arr0: [ 3, 2, 1 ] a: 2 b: 0;]]></content>
      <categories>
        <category>API总结</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>数组原型</tag>
        <tag>非变异方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Array原型之变异方法]]></title>
    <url>%2FArray%E5%8E%9F%E5%9E%8B%E4%B9%8B%E5%8F%98%E5%BC%82%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[ArrayArray对象是用于构造数组的全局对象.概述数组对象是一个有序的数据(原始类型或对象类型)集合, 是一种类列表对象,它的原型提供了数组操作的方法.数组只能用整数作为数组元素的索引,而不是字符串,且从0开始,第一个元素的索引为0.使用非整数并通过[]或.来访问数组或设置数组元素时,所操作的并不是数组列表的元素,而是数组对象属性集合上的变量.数组对象的属性和数组元素列表是分开存储的,并且数组的遍历和修改操作也不能作用于这些命名属性.123456var arr = [];arr['zero'] = 'zero';arr[0] = 0;arr.forEach(item =&gt; console.log(item))// 0原型方法变异方法Array.prototype.push()描述 :在数组末尾添加一个或多个元素.语法 :arr.push(element0 ..., elementN)elementN : 将要添加到数组末尾的元素.返回值 : 被改动后的原数组的length值, 且原数组被改变.12345let arr0 = [3, 2, 1];let arr0Len = arr0.push('Array');console.log('arr0:', arr0, 'arr0Len:', arr0Len);// arr0: [3, 2, 1, 'Array'] arr0Len: 4;Array.prototype.unshift()描述 :在数组开头添加一个或多个元素.语法 :arr.unshift(element1, ..., elementN)elementN : 将要添加到数组开头的元素.返回值 : 被改动后的原数组的length值, 且原数组被改变.12345let arr0 = [3, 2, 1];let arr0Len = arr0.unshift('Array');console.log('arr0:', arr0, 'arr0Len:', arr0Len);// arr0: ['Array', 3, 2, 1] arr0Len: 4;Array.prototype.pop()描述 :从数组中删除最后一个元素.语法 :arr.pop()返回值 : 被删除的数组元素(空属组调用, 则返回undefined), 且原数组被改变.12345let arr0 = [3, 2, 1];let ele = arr0.pop();console.log('arr0:', arr0, 'ele:', ele);// arr0: [3, 2] ele: 1;Array.prototype.shift()描述 :从数组中删除第一个元素.语法 :arr.shift()返回值 : 被删除的数组元素(空属组调用, 则返回undefined), 且原数组被改变.12345let arr0 = [3, 2, 1];let ele = arr0.shift();console.log('arr0:', arr0, 'ele:', ele);// arr0: [2, 1] ele: 3;Array.prototype.splice()描述 :从数组中删除指定数量的元素并添加向数组添加元素.语法 :array.splice(start[, deleteCount[, element1[, ...[, elementN]]]])start : 指定修改位置(从0计数).deleteCount 要移除的数组元素个数. 默认值为 this.length - start.elementN : 要添加的数组元素.返回值 : 由被删除的元素组成的数组, 且原数组被改变.1234567891011121314151617181920212223let arr0 = [3, 2, 1];let arr00 = arr0.splice(2, 0, 4, 5, 6);console.log('arr0:', arr0, 'arr00:', arr00);// arr0: [3, 2, 4, 5, 6, 1] arr00: [];let arr1 = [3, 2, 1];let arr11 = arr1.splice(2, 1, 4, 5, 6);console.log('arr1:', arr1, 'arr11:', arr11);// arr1: [3, 2, 4, 5, 6] arr11: [1];let arr3 = [3, 2, 1];let arr33 = arr3.splice(1, 2);console.log('arr3:', arr3, 'arr33:', arr33);// arr3: [3] arr33: [2, 1];let arr4 = [3, 2, 1];let arr44 = arr4.splice(3, 0 , 4, 5, 6);console.log('arr4:', arr4, 'arr44:', arr44);// arr4: [3, 2, 1, 4, 5, 6] arr44: [];Array.prototype.sort()描述 :用原地算法对数组的元素进行排序.语法 :arr.sort([compareFunction])compareFunction : 用来指定按某种顺序进行排列的函数. 如果省略, 元素按照转换为的字符串的各个字符的Unicode位点进行排序. 指明了 compareFunction, 那么数组会按照调用该函数的返回值排序. a 和 b 是两个将要被比较的元素:compareFunction(a, b) 小于 0, 那么 a 会被排列到 b 之前;compareFunction(a, b) 等于 0, a 和 b 的相对位置不变;compareFunction(a, b) 大于 0, b 会被排列到 a 之前;返回值 : 排序后的数组.12345let arr0 = [3, 4, 2, 5, 1];let arr00 = arr0.sort((a, b) =&gt; a-b);console.log('arr0:', arr0, 'arr00:', arr00);// arr0:, [1, 2, 3, 4, 5] arr00: [1, 2, 3, 4, 5];Array.prototype.reverse()描述 :将数组中元素的位置颠倒.语法 :arr.reverse()返回值 : 位置颠倒后的数组.12345let arr0 = [3, 2, 1];let arr00 = arr0.reverse();console.log('arr0:', arr0, 'arr00:', arr00);// arr0: [1, 2, 3] arr00: [1, 2, 3];Array.prototype.copyWithin()描述 :将数组的某一部分浅复制到指定位置.语法 :arr.copyWithin(target[, start[, end]])target : 索引起始为0. 被复制的内容将要替换的位置. 如果是负数, target将从 this.length + target开始计算.start : 起始索引, 默认值为0. 被复制内容的起始位置, 包括start位置的元素. 如果是负数, 则开始索引会被自动计算成为 this.length + start.end : 终止索引, 默认值为this .length, 索引起始为0. 被复制内容的结束位置, 但不包括end位置的元素. 如果是负数. 则终止索引会被自动计算成为 this.length + end.返回值 : 被改动后的原数组. 数组内容变化, 长度不变.1234567891011121314151617let arr0 = [3, 2, 1];let arr00 = arr0.copyWithin(2, 0);console.log('arr0:', arr0, 'arr00:', arr00);//arr0: [3, 2, 3] arr00: [3, 2, 3];let arr1 = [3, 2, 1];let arr11 = arr1.copyWithin(2, 1, 2);console.log('arr1:', arr1, 'arr11:', arr11);// arr1: [3, 2, 2] arr11: [3, 2, 2];let arr2 = [3, 2, 1];let arr22 = arr2.copyWithin(-1, -2, -1);console.log('arr2', arr2, 'arr22', arr22);// arr1: [3, 2, 2] arr11: [3, 2, 2];Array.prototype.fill()描述 :将数组的某一区域的全部元素用指定值替换.语法 :arr.fill(value[, start[, end]])value : 填充数组的参数值.start : 起始索引, 默认值为 0. 如果是负数时, 规则如上.end : 终止索引, 默认值为 this.length. 不包括end位置. 如果是负数时, 规则如上.返回值 : 被改动后的原数组.1234567891011let arr0 = [3, 2, 1];let arr00 = arr0.fill(3);console.log('arr0:', arr0, 'arr00:', arr00);// arr0: [3, 3, 3] arr00: [3, 3, 3];let arr1 = [3, 2, 1];let arr11 = arr1.fill(3, 1);console.log('arr1:', arr1, 'arr11:', arr11);// arr1: [3, 3, 3] arr11: [3, 3, 3]]]></content>
      <categories>
        <category>API总结</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>数组原型</tag>
        <tag>变异方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Array构造函数]]></title>
    <url>%2FArray%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[ArrayArray对象是用于构造数组的全局对象.概述数组对象是一个有序的数据(原始类型或对象类型)集合, 是一种类列表对象,它的原型提供了数组操作的方法.数组只能用整数作为数组元素的索引,而不是字符串,且从0开始,第一个元素的索引为0.使用非整数并通过[]或.来访问数组或设置数组元素时,所操作的并不是数组列表的元素,而是数组对象属性集合上的变量.数组对象的属性和数组元素列表是分开存储的,并且数组的遍历和修改操作也不能作用于这些命名属性.123456var arr = [];arr['zero'] = 'zero';arr[0] = 0;arr.forEach(item =&gt; console.log(item))// 0构造函数属性Array.length构造函数的length属性,该属性为静态属性(详见Function.length),不是数组实例的length属性,其值为1.123console.log(Array.length);// 1Array.prototype构造函数的原型对象,所有的数组实例都会从Array.prototype继承属性和方法.通过扩展Array原型上的属性和方法进而为所有的数组实例增加属性和方法.123456789101112Array.prototype.type = "Array";Array.prototype.first = function() &#123; return this[0];&#125;;var arr = [3, 2, 1];arr.type;// Array;arr.first();// 3;构造函数方法Array.from()描述 :从一个类似数组或可迭代对象中创建一个新的数组实例.语法 :Array.from(arrayLike[, mapFn[, thisArg]])ArrrayLike : 伪数组对象(拥有length属性和若干索引属性) 和 可迭代对象.mapFn : 返回的新数组都会执行的回调函数.thisArg : 执行回调函数时this对应的对象.返回值 : 新的数组实例.123456789101112131415161718Array.from('Array');// ["A", "r", "r", "a", "y"];(function () &#123; return Array.from(arguments);&#125;)(3, 2, 1)// [3, 2, 1];let s = new Set(['array', Array]);Array.from(s);// ["array", function];Array.from([3, 2, 1], x =&gt; x.toString());// ["3", "2", "1"];Array.isArray()描述 :判断待验证的参数是否为Array.语法 :Array.isArray(obj)obj : 待验证参数.返回值 : 若待验证参数为数组时,则为true; 否则false.123456789101112131415161718Array.isArray([]);// true;Array.isArray(&#123;&#125;);// false;Array.isArray(Array.prototype);// true;// Polyfillif (!Array.isArray) &#123; Array.isArray = function(arg) &#123; return Object.prototype.toString.call(arg) === '[object Array]'; &#125;;&#125;;Array.of()描述 :创建一个由传入参数组成的新数组实例, 而不考虑参数的数量或类型.语法 :Array.of(element0[, element1[, ...[, elementN]]])elementN : 任意个参数,将顺序得成为数组的元素.返回值 : 新的数组实例.123456789101112131415161718Array.of(3);// [3];Array.of(3, 2, 1);// [3, 2, 1];Array.of('Array', Array);// ["Array", function];// Polyfillif (!Array.of) &#123; Array.of = function() &#123; return Array.prototype.slice.call(arguments); &#125;;&#125;]]></content>
      <categories>
        <category>API总结</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>构造函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器缓存机制]]></title>
    <url>%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[浏览器缓存强缓存释义: 客户端第一次问服务器要某个资源时，服务器丢还给客户端所请求的这个资源同时，告诉客户端将这个资源保存在本地，并且在未来的某个时点之前如果还需要这个资源，直接从本地获取就行了，不用向服务器请求.这种方式缓存下来的资源称为强缓存.Expires &amp; Cache-Control:max-ageExpires:该字段是http1.0时的规范，值为一个绝对时间的GMT格式的时间字符串，代表缓存资源的过期时间，在这个时点之前，即命中缓存.Cache-Control:该字段是http1.0时的规范，值为一个绝对时间的GMT格式的时间字符串，代表缓存资源的过期时间，在这个时点之前，即命中缓存.参数:no-cache: 如果请求头部包含no-cache指令，表示客户端不接收缓存过的响应.中间缓存服务器必须将请求转发给给源服务器. 浏览器强制刷新(window下ctrl+F5)就是这个原理，所以的请求都设置no-cacheno-store: 暗示请求和响应包含机密信息，不能进行缓存.区分: no-store才是真正的不缓存max-age: 该指令用来标识缓存资源的最大有效期. 如果max-age=0，就会向源服务器发送请求进行缓存资源新鲜度的验证.浏览器普通刷新F5“Cache-Control”:” cache-directive”*作为请求首部时，cache-directive 的可选值有:“Cache-Control”:” cache-directive”*作为响应首部时，cache-directive 的可选值有:在请求头中max-age=0与no-cache的区别？返回的状态来看：no-cache都是200，而max-age可能是304（如果浏览器有缓存）. 请求参数：max-age请求头一般会携带If-Modified-Since或If-None-Match字段进行新鲜度验证，而no-cache不会携带. F5刷新是max-age=0来实现，而强制刷新(Ctrl+F5)是通过no-cache实现. 异同: Expires是HTTP 1.0+的首部，用来指定一个绝对的过期日期，依赖客户端时间设置的准确性,缓存时间是相对服务器上的时间而言的.而max-age是HTTP/1.1的Cache-Control的一个字段，用来指定文档的最大使用时间.协商缓存释义: 客户端第一次问服务器要某个资源时，服务器丢还给客户端所请求的这个资源同时，将该资源的一些信息（文件摘要、或者最后修改时间）也返回给客户端，告诉客户端将这个资源缓存在本地.当客户端下一次需要这个资源时，将请求以及相关信息（文件摘要、或者最后修改时间）一并发送给服务器，由服务器来判断客户端缓存的资源是否需要更新：如不需要更新，就直接告诉客户端获取本地缓存资源；如需要更新，则将最新的资源连同相应的信息一并返回给客户端.Last-Modified &amp; If-Modified-Since &amp; Etag &amp; If-None-MatchLast-Modidied &amp; If-Modified-Since:Last-Modified: 为实体首部字段，值为资源最后更新时间，随服务器response返回.If-Modified-Since: 为请求首部字段，通过比较两个时间来判断资源在两次请求期间是否有过修改，如果没有修改，则命中协商缓存，浏览器从缓存中获取资源；如果有过修改，则服务器返回资源，同时返回新的Last-Modified时间.Etag &amp; If-None-Match:Etag: 为相应头部字段，表示资源内容的唯一标识，随服务器response返回.If-None-Match: 为请求头部字段，服务器通过比较请求头部的If-None-Match与当前资源的ETag是否一致来判断资源是否在两次请求之间有过修改，如果没有修改，则命中协商缓存，浏览器从缓存中获取资源；如果有过修改，则服务器返回资源，同时返回新的ETag.不能缓存的请求HTTP信息头中包含Cache-Control:no-cache，pragma:no-cache（HTTP1.0），或Cache-Control:max-age=0等告诉浏览器不用缓存的请求. Cache-Control: no-cache：这个很容易让人产生误解，使人误以为是响应不被缓存.实际上Cache-Control: no-cache是会被缓存的，只不过每次在向客户端（浏览器）提供响应数据时，缓存都要向服务器评估缓存响应的有效性需要根据Cookie，认证信息等决定输入内容的动态请求是不能被缓存的经过HTTPS安全加密的请求（有人也经过测试发现，ie其实在头部加入Cache-Control：max-age信息，firefox在头部加入Cache-Control:Public之后，能够对HTTPS的资源进行缓存，参考《HTTPS的七个误解》）POST请求无法被缓存HTTP响应头中不包含Last-Modified/Etag，也不包含Cache-Control/Expires的请求无法被缓存浏览器缓存机制示意图]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github+Hexo+Next博客搭建之Hexo,Next及部署]]></title>
    <url>%2FGithub-Hexo-Next%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%B9%8BHexo-Next%E5%8F%8A%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[博客已经搭建好了,自然可以趁热打铁写一些博客搭建的经验.一是方便自己以后查看,免得忘记.二是如果有人想了解博客搭建的过程,也正好有个参考.(如果SEO做的好,就有可能看到这篇文章).本文仅记录怎么去搭建博客,而不会解释每一步原理,有些东西我自己都没有搞的太清楚.毕竟我只是想借助博客这个平台记录平时工作的经验而已,细究相关方面知识并不是我的最终目的现在回头看博客的搭建过程,可以总结归纳以下几点. markdown,git和GitHub,github和coding部署, Hexo和Next了解, SEO等Hexo,Next,部署,SEO该博客的搭建用的是Hexo博客框架,详细的说明官方文档都有提到.在主题的选择上用的是Next,对应的也有相关的官方文档.接下来就搭建过程中遇到的简单介绍一下Hexo中基本指令npm install -g hexo-cli // npm安装Hexo, 非Hexo中命令 hexo init &lt;folder&gt; // 指定文件夹下初始化Hexo,若没有设置folder, Hexo默认在目前的文件夹建立网站 cd &lt;folder&gt; // 进入指定文件夹, 非Hexo中命令 npm install // 安装配置文件packge.json中的依赖, 非Hexo中命令 hexo new [layout] &lt;title&gt; // 新建一篇文章.layout默认default_layout参数,标题有空格,需使用引号括起来 hexo generate // 生成静态文件. -d, --deploy 文件生成后立即部署网站.可简写为 hexo g hexo server // 启动服务器.默认情况下网址为:http://loalhost:4000/. -p, --port 重设端口 hexo deploy // 部署网站. -g, --generate 部署之前预先生成静态文件.可简写为 hexo d hexo clean // 清除缓存文件和已生成的静态文件 Hexo部署地址配置打开站点配置文件_config.yml,找到deploy字段,配置如下deploy: - type: git // 以下是我的git地址 repo: git@github.com:yexiaochen/yexiaochen.github.io.git branch: master - type: git // 以下是我的coding地址 repo: git@git.coding.net:yexiaochen/yexiaochen.coding.me.git branch: master 安装Next主题定位到Hexo站点目录下,执行一下命令即可git clone https://github.com/iissnan/hexo-theme-next themes/next 克隆完成后,打开站点配置文件_config.yml,找到theme字段,并将其值更改为next设置菜单页面Next主题有默认的菜单项,部分菜单项需要自己添加.添加菜单项页面新建标签页面在根目录下新建标签页面hexo new page tags 在新建的页面编辑一下内容123456---title: All tagsdate: 2018-03-24 18:02:30type: &quot;tags&quot;comments: false---在主题配置文件_config.yml内, 找到menu字段,添加如下内容123456789menu:home: / || home# about: /about/ || usertags: /tags/ || tagscategories: /categories/ || tharchives: /archives/ || archive# schedule: /schedule/ || calendar# sitemap: /sitemap.xml || sitemap# commonweal: /404/ || heartbeat在菜单项里添加分类项操作同上添加gitment评论 添加gitalk评论远程仓库新建一个repository,名字随意,待会儿会用到添加OAuth Apps.登陆GitHub,通过Settings =&gt; Developer settings =&gt; OAuth Apps,点击New OAuth App.添加后会生成Client ID和Client Secretgitalk和gitment是差不多的产品, 在我们更换评论系统时, 可以在其基础上修改. 在主题配置文件_config.yml内, 找到gitment字段,添加如下内容.12345678910111213gitment: enable: true mint: true # RECOMMEND, A mint on Gitment, to support count, language and proxy_gateway count: true # Show comments count in post meta area lazy: true # Comments lazy loading with a button cleanly: true # Hide &apos;Powered by ...&apos; on footer, and more language: # Force language, or auto switch by theme github_user: yexiaochen # MUST HAVE, Your Github ID 18507780 github_repo: blog-gitment # MUST HAVE, The repo you use to store Gitment comments client_id: your_client_id # MUST HAVE, Github client id for the Gitment client_secret: your_client_secret # EITHER this or proxy_gateway, Github access secret token for the Gitment proxy_gateway: # Address of api proxy, See: https://github.com/aimingoo/intersect redirect_protocol: # Protocol of redirect_uri with force_redirect_protocol when mint enabled在themes/next/layout/_third-party/comments/gitment.swig文件中, 按照gitalk文档里的配置进行修改.123456789const gitalk = new Gitalk(&#123;clientID: 'GitHub Application Client ID',clientSecret: 'GitHub Application Client Secret',repo: 'GitHub repo',owner: 'GitHub repo owner',admin: ['GitHub repo owner and collaborators, only these guys can initialize github issues'],id: location.pathname, // Ensure uniqueness and length less than 50distractionFreeMode: false // Facebook-like distraction free mode&#125;)注意: gitalk 需要GitHub账号登陆才可以创建初始化.部署coding部署到coding和部署到GitHub类似,也是要添加SSH的.新建的项目名称也是要求按照一定的规范来,细节可参考Coding Pages.在Pages服务的设置可参考下图DNS解析设置购买域名后,要对其进行解析设置.因为国外墙的原因,故博客在部署时也选在了不同的平台上.不同的解析路线对应不同的项目URL博客的搭建到此就结束了,其中还是有许多细节没有提到,时间久了已经忘了大部分了]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
        <tag>coding</tag>
        <tag>部署</tag>
        <tag>DNS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github+Hexo+Next博客搭建之git和GitHub]]></title>
    <url>%2FGithub-Hexo-Next%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%B9%8Bgit%E5%92%8C%08GitHub%2F</url>
    <content type="text"><![CDATA[博客已经搭建好了,自然可以趁热打铁写一些博客搭建的经验.一是方便自己以后查看,免得忘记.二是如果有人想了解博客搭建的过程,也正好有个参考.(如果SEO做的好,就有可能看到这篇文章).本文仅记录怎么去搭建博客,而不会解释每一步原理,有些东西我自己都没有搞的太清楚.毕竟我只是想借助博客这个平台记录平时工作的经验而已,细究相关方面知识并不是我的最终目的.现在回头看博客的搭建过程,可以总结归纳以下几点. markdown,git和GitHub,github和coding部署, Hexo和Next了解, SEO等git和GitHub接下来会按一下流程展开,本地git配置 =&gt; 关联远程仓库 =&gt; 初始化仓库.由于博主使用的Mac,执行命令时会和window下cmd有所区别.git配置完成git 的安装后,在使用之前需要配置一些全局参数, 如username和email.因为GitHub每次commit都会记录它们.git config --global user.name &quot;username&quot; git config --global user.email &quot;email&quot; 除了username和email外,还有许多自定义配置,示例:git config --global color.ui true // git输出显示不同颜色 git config --global ignorecase true // git对仓库中的文件大小写敏感 git config --global alias.st status // git提供alias的功能,git status缩写为git st git config --global apply.whitespace nowarn // git忽略空白的变化 查看所有已经做出的配置:git config -l 或 git config --list 添加远程仓库首先在github官网有自己的账号,之后就可以创建仓库了.添加SSH Key由于你的本地Git仓库和github仓库之间的传输是通过SSH加密的,所以需执行以下步骤:本地创建ssh key.$ ssh-keygen -t rsa -C &quot;your_email@youremail.com&quot; 后面的your_email@youremail.com改为你在github上注册的邮箱,之后会要求确认路径和输入密码,我们默认一路回车就行.成功的话会在~/下生成.ssh文件夹,进去打开id_rsa.pub,复制里面的key.ls -al ~/.ssh // 查看是否存在id_rsa.pub,若存在,执行下一步; cd ~/.ssh // 进入.ssh目录 cat id_rsa.pub // 查看复制id_rsa.pub 在GitHub里添加复制的id_rsa.pub. Settings =&gt; SSH and GPG keys =&gt;New SSH key.操作之后,如图示:Title任意填写,Key填入之前复制的id_rsa.pub.点击Add SSH key,添加已经完成.验证是否成功,输入下列命令:ssh -T git@github.com 如果是第一次的会提示是否continue,输入yes就会看到:You’ve successfully authenticated,but GitHub does not provide shell access.这就表示已成功连上github.创建GitHub项目并添加远程仓库登陆github账户后,点击New repository, 会有Create a new repository页面,填写相关信息,点击Create repository,可以根据官网提供的方式添加远程仓库.如下:…or create a new repository on the command lineecho &quot;# something&quot; &gt;&gt; README.md // 生成readme.md git init // 初始化本地仓库 git add README.md // 将文件添加到暂存区 git commit -m &quot;first commit&quot; // 将暂存区文件提交到仓库中 git remote add origin git@github.com:your-repository // 添加你的远程仓库 git push -u origin master // 将本地仓库推送到远程仓库 …or push an existing repository from the command linegit remote add origin git@github.com:your-repository git push -u origin master 以上步骤完成了本地仓库到远程仓库的连接,接下来总结git的一些常用的命令深入了解可参考 git中文git的常用命令状态和工作区域三种状态已提交: 表示数据已经安全得保存在本地数据库中.已修改: 表示修改了文件,但还没保存到数据库中.已暂存: 表示对一个已修改文件的当前版本做了标记,使之包含在下次提交的快照中.三种工作区域Git仓库目录: 是Git用来保存项目的元数据和对象数据库的地方.这是Git中最重要的部分,从其他计算机克隆仓库时,拷贝的就是这里的数据.工作目录: 对项目的某个版本独立提取出来的内容.这些从Git仓库的压缩数据库中提取出来的文件,放在磁盘上供你使用或修改.暂存区: 是一个文件,保存了下次将提交的文件列表信息,一般在Git仓库目录中.有时也被称作’索引’.工作目录下的两种状态已跟踪: 指被纳入了版本控制的文件,在上一次快照中有它们的记录,在工作一段时间后,它们的状态可能处于为修改,已修改或已暂存.未跟踪: 工作目录中除了已跟踪文件以外的所有其它文件都属于未跟踪文件,它们既不存在与上次快照中,也没有放入暂存区.初次克隆某个仓库的时候,工作目录中的所有文件都属于已跟踪文件,并处于未修改状态.Git工作流程基本的 Git 工作流程如下：在工作目录中修改文件.暂存文件,将文件的快照放入暂存区域.提交更新,找到暂存区域的文件,将快照永久性存储到 Git 仓库目录.如果 Git 目录中保存着的特定版本文件,就属于已提交状态. 如果作了修改并已放入暂存区域，就属于已暂存状态.如果自上次取出后,作了修改但还没有放到暂存区域,就是已修改状态.基础操作初始化Git仓库git init 该命令将创建一个名为.git的子目录,这个子目录含有初始化的Git仓库中所有的必须文件添加文件到暂存区git add &lt;file&gt; // 添加单个文件到暂存区 git add . // &apos;.&apos; 表示所有文件、文件夹和子文件夹 添加文件到仓库git commit // 将暂存区的文件提交到仓库中 git commit -m &apos;提交信息&apos; // -m 带提交信息,说明本次提交内容或修改等 git commit -am // -a Git会自动把所有已经跟踪过的文件暂存一并提交,从而跳过git add步骤 查看文件状态git status // 查看哪些文件处于什么状态 git status -s // git status -short 输出简介显示 ?? filename-1 // 新添加未跟踪文件前面有??标记 A filename-2 // 新添加到暂存区文件前有A标记 M filename-3 // 出现在左边的M表示,该文件被修改了并放入了暂存区 M filename-4 // 出现在右边的M表示该文件被修改了但没放入暂存取 MM filename-5 // 同时出现表示在工作区被修改并提交到暂存区由于在工作区中被修改了,所以说暂存区和工作区都有该文件的修改记录 查看文件具体修改git diff // 该命令查看未暂存的文件更新了哪些部分,用于比较工作目录中当前文件和暂存区域快照之间的差异 git diff --cached // 该命令用于查看已暂存的将要添加到下次提交里的内容 (Git 1.6.1 及更高版本还允许使用 git diff --staged，效果是相同的) 查看提交历史git log // 按提交时间列出所有的更新,最新的更新排在最上面 git log -p -(n) // -p 用来显示每次提交的内容差异. -(n) 仅显示最近n次提交 git log --stat // 每次的简略的统计信息 git log --pretty=oneline // 该选项指定使用不同于默认格式的方式展示提交历史. 可用选项包括oneline,short,full,fuller和format(后跟指定格式) git log --shortstat // 只显示--stat中最后的行数修改添加移除统计 git log --name-only // 仅在提交信息后显示已修改的文件清单 git log --name-status // 显示新增、修改、删除的文件清单 git log --graph // 显示ASCLL图形表示的分支合并历史 git relog // 引用日志,记录了HEAD和分支引用所指向的历史,只存在在于本地仓库 撤销操作git reset HEAD &lt;file&gt; // 丢弃已经进入暂存取的修改 git checkout -- &lt;file&gt; // 丢弃工作区中文件的修改 git checkout -- . // 丢弃当前目录下所有工作区中的修改 退回到某个提交版本git reset --hard HEAD^ // 回退到上一个提交 git reset --hard HEAD^^ // 回退到上上一个提交 git reset --hard &lt;commit_id&gt; // 回退到指定id的提交版本 删除操作在文件未添加到暂存取之前,可以直接物理删除想要删除的文件.或通过git checkout -- &lt;file&gt; 来丢弃修改.如果文件已经被提交,则需要git rm删除git rm &lt;file&gt; // 删除被提交的文件 远程仓库查看远程仓库git remote // 查看已配置的远程仓库服务器 git remote -v // 显示需要读写远程仓库使用的Git保存的简写与对应的URL git remote show &lt;remote-name&gt; // 查看某一个远程仓库的更多信息 添加远程仓库git remote add &lt;remote-name&gt; &lt;url&gt; // 添加地址为URL,名为remote-name的引用 从远程仓库中拉取与推送git fetch &lt;remote-name&gt; // 该命令将数据拉取到本地仓库,并不会自动合并或修改当前的工作 git pull &lt;remote-name&gt; // 改命令自动抓取然后合并远程分支到当前分支 git push &lt;remote-name&gt; &lt;branch-name&gt; // 将branch-name分支推送到remote-name服务器上 git push -u &lt;remote-name&gt; &lt;branch-name&gt; // 第一次使用带上-u参数,在将本地的 master 分支推送到远程新的 master 分支的同时,还会把本地的 master 分支和远程的 master 分支关联起来 远程仓库的移除与重命名git remote rm &lt;remote-name&gt; // 移除远程仓库 git remote rename &lt;old-name&gt; &lt;new-name&gt; // 重命名远程仓库 修改本地仓库对应的远程仓库git remote set-url &lt;remote-name&gt; &lt;url&gt; // 当远程的仓库地址发生变化时,需要修改本地仓库对应的远程仓库地址 分支管理git branch // 查看本地分支信息, 输出内容中,标记*,表示当前所在分支 git branch -v // 查看详细的本地分支信息 git branch &lt;branch-name&gt; // 新建一个branch-name分支 git checkout &lt;branch-name&gt; // 新建完branch-name分支后,并通过该命令切到branch-name分支 git checkout master git merge &lt;branch-name&gt; // 切换回master分支,并将branch-name分支的修改合并到master分支 git branch -d &lt;branch-name&gt; // 删除branch-name分支]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github+Hexo+Next博客搭建之Markdown]]></title>
    <url>%2FGithub-Hexo-Next%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%B9%8BMarkdown%2F</url>
    <content type="text"><![CDATA[博客已经搭建好了,自然可以趁热打铁写一些博客搭建的经验.一是方便自己以后查看,免得忘记.二是如果有人想了解博客搭建的过程,也正好有个参考.(如果SEO做的好,就有可能看到这篇文章).本文仅记录怎么去搭建博客,而不会解释每一步原理,有些东西我自己都没有搞的太清楚.毕竟我只是想借助博客这个平台记录平时工作的经验而已,细究相关方面知识并不是我的最终目的.现在回头看博客的搭建过程,可以总结归纳以下几点. markdown,git和GitHub, github和coding部署, Hexo和Next了解, SEO等Markdown工欲善其事,必先利其器.作为程序员,平时的编辑语言首选是markdown,markdown的使用其实很简单.之前除了整理一下文档外,平时倒是用的不多,在此整理一下段落和换行一个Markdown段落前后要有一个以上空行,普通段落不该用空行或制表符来缩进.段落内强迫换行可在插入处键入两个以上空格然后回车.标题markdown支持两种标题,类Setext和Atx形式.类Atx形式是在行首插入1到6个#,分别对应1到6级标题,示例:123# 一级标题## 二级标题### 三级标题区块引用Markdown中建立区块引用,需在行首最前面加上&gt;:1&gt; 这是一个区块引用效果展示:这是一个区块引用区块引用可以嵌套,只要根据层次加上不同数量的&gt;:123&gt; 这是顶层的&gt;&gt; 这是二级引用&gt;&gt;&gt; 这是三级引用效果展示:这是顶层的这是二级引用这是三级引用引用区块内可以使用其他Markdown语法,包括标题、列表、代码区块等:1234567&gt; 列表&gt; 1. item1&gt; 2. item2&gt;&gt; 代码区块&gt;&gt; 这是一个代码区块效果展示:列表item1item2代码区块这是一个代码区块列表Markdown支持有序列表和无序列表.列表项目标记通常放在最左边,也可以缩进,最多3个空格,项目标记后面一定要接着至少一个空格或制表符.列表项目可以包含多个段落,每个项目下的段落都必须缩进四个空格或是一个制表符:123456* 这是第一段落(空行)(四个空格一个制表符)这是第二段落或* 这是第一段落(两个空格)(四个空格一个制表符)这是第二段落效果展示:这是第一段落.这是第二段落这是第一段落这是第二段落列表项目内放进引用,引用需缩进四个空格或一个制表符:12* 列表项目内放进引用(四个空格或一个制表符)&gt; 这是引用一效果展示:列表项目内放进引用这是引用一列表项目内放进代码区块,该区块需缩进两次,八个空格或两个制表符:123* 列表项目内放进代码区块(空行)(八个空格或两个制表符)这是一个代码区块效果展示:列表项目内放进代码区块这是一个代码区块 无序列表无序列表使用星号(*)、加号(+)、减号(-)作为列表标记:123* item + item - item* item + item - item* item + item - item效果展示:itemitemitem有序列表有序列表则是数字接着英文句点( 数字 + . ):1231. item2. item3. item效果展示:item1item2item3代码区块Markdown中建立代码区块,需缩进四个空格或一个制表符:123这是一个普通段落:(空行)(八个空格或两个制表符)这是一个代码区块效果展示:这是一个普通段落:这是一个代码区块 分割线Markdown中的分隔线需三个以上的星号(*)、减号(-)、底线(_).也可以在星号或减号或底线中间插入空格,不影响效果.1234****-----_______**** ***** **********效果展示:链接Markdown支持两种形式的链接语法: 行内式和参考式.链接文字都是用[]标记.行内式行内式链接:1这是一个行内式链接[链接文字](链接URL &quot;链接标题&quot;)效果展示:这是一个行内式链接链接文字参考式1234参考式链接:这是一个参考式链接[链接文字][链接辨别标签](空行)[链接辨别标签]: 链接URL &quot;链接标题&quot;效果展示:这是一个参考式链接链接文字链接内容定义形式:方括号(前面可以选择性加上至多三个空格缩进),里面输入链接文字接着一个冒号接着一个以上的空格或制表符接着链接的网址, 可以用尖括号包起来选择性接着title内容,可以是单引号、双引号或括号,可以放到下一行,也可以加一些缩进链接辨别标签不区分大小写.隐式链接标记隐式链接标记可以省略制定链接标记,此时链接标记等同于链接文字:123这是一个隐式链接标记功能[隐式链接][][隐式链接]: 链接URL &quot;隐式链接标题&quot;效果展示:这是一个隐式链接标记功能隐式链接强调Markdown中标记强调字词需使用星号(*)或底线(_),被单个*或_包围的字词会被&lt;em&gt;标签包围,用两个*或_包起来,则会被转成&lt;strong&gt;,示例:123*强调***强调**__强调__效果展示:强调强调强调如果*或_两边都有空白,它们就只会被当成普通的符号.代码Markdown标记一小段行内代码,需用反引号包起来(`),支持语法高亮,包括:Apache, Bash, CoffeeScript, C++, C#, CSS, HTTP, Java, JavaScript, JSON, Markdown, Nginx, Objective-C, Perl, PHP, Properties, Python, Ruby, Shell Session, SQL, HTML, XML等.示例:1这是一个`行内代码标记`效果展示:这是一个行内代码标记图片Markdown中插入图片,有两种样式: 行内式和参考式.行内式1![图片替代文字](图片链接URL &quot;图片描述&quot;)一个感叹号!接着方括号[],里面是图片的替代文字接着括号,里面是图片的URL,最后还可以选择性加上文字描述.参考式12![图片替代文字][图片参考标记][图片参考标记]: 图片链接URL &quot;图片描述&quot;如果需对图片进行宽高,位置调整,可以使用普通的&lt;img&gt;标签自动链接Markdown支持比较短的自动链接形式来处理网址和电子信箱,需用尖括号&lt;&gt;1&lt;网址的URL&gt;表格Markdown中支持表格,:代表对其方式,:和|之间不能有空格,否则对其会有不兼容.示例:123456789(空格)|左侧|中间|右侧||:---:|:---:|:---:||描述一|描述二|描述三|或(空格)左侧|中间|右侧:---:|:---:|:---:描述一|描述二|描述三效果展示:左侧中间右侧描述一描述二描述三小结Markdown的简单应用到这也差不多写完了,当然还有好多的高级技巧可以自行百度或Google.语法本来就很简单,虽不说十分钟包教包会,但是只要尝试着在键盘上敲两下,看看效果,学会它还是挺容易的.]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[序言]]></title>
    <url>%2F%E5%BA%8F%E8%A8%80%2F</url>
    <content type="text"><![CDATA[忙活了好多天终于把博客搭建好了.平时上班的比较忙,利用零零散散的时间看了好多关于搭建博客的文章,消化之后,发现博客的搭建并不是想象那样麻烦.以前一直有搭建博客的想法,可是每每在搭建的过程中就放弃了.原因有很多,一部分是因为从没有接触过类似博客搭建的知识,也有部分原因是也没有搭建博客的需求.为什么写做任何事都是有原因的.有搭博客写博客的想法也是一直都是存在的.在大学的那会儿,一直觉得做程序员是一类高大上的人物,所以一直对这个行业心怀憧憬.平时看些技术型文章时,一般都是来自大牛的博客,写的文章或在第三方平台,或在自己搭建的博客上.就在那个时候,心中就有了能够拥有属于自己博客的想法.于是呢,自己也是有过尝试,但是对于毫无基础的菜鸟来说,那是一种折磨.挑战新的事物的确有意思,但是突然接触到好多不懂的概念,也是一种酸爽.不过随着经历和经验的积累,也慢慢发现,学习任何新的事物,都要有个循循渐进的过程,储备的足够了自然会从量变转为质变.当然这也是后来话了.在这个阶段搭建博客想法无非就是觉得新鲜,满足一下小虚荣.结局呢,可想而知,没有足够的动力,是不能完成有些许挑战性的任务的.毕竟动物趋于安逸,生性懒惰,没有压力,哪来的奔波.人,也是动物.毕业之后,就开始步入社会,这时候就要考虑如何谋生了.所幸的是,自己从一开始就选择了前端这个行业.从一个毕业就是失业的专业跳到了一个陌生的领域,除了曾经那一丝丝的憧憬让人有所安慰外,剩下的就是彷徨不安.在自学了一段时间的前端基础后,迫于对自身学习成果的不满和外在压力,硬着头皮投递了各家招聘网站的公司.白天参加面试,晚上还要学习巩固白天面试官提的问题.人的潜力或效率有时候还真是逼出来的.在面试期间的确学到了好多东西,也大概的知道了,这类行业到底需要什么样的人.人知道的越多,也就越知道不知道的太多.那时候自己就迫切希望能够稳定下来夯实一下自己的基础.经过一段时间的东奔西跑,找到了人生的第一份正式的工作.准确的说,是被找上了.不是说我的技术有多厉害,而是这份工作压根不需要什么技术.本来我是想拒绝的,也坦言了自己的状况.毕竟我是抱着学技术的心态出来的.可是经过一轮轮的面试,我也是知道,技术的重要性,再加上人家知道情况后还是要留人,那我也就留着呗.留在公司后,就是用cms搭个网站,申请个微信公众号做微信运营什么的.那时候真的什么都不知道,各种百度啊什么的.不过最终还是让我捣鼓出来了.之后日子也就安逸了,不过每天也是提心吊胆的,生怕哪一天老板又整出什么幺蛾子.时间空出来了,搭建博客的想法也是突然又重现在脑海中.趁着机会可以建站搭博客.所以,回家后又开始忙活起如何建站.可想法是好的,现实却偏偏作对.公司一直筹划着一些活动,微信上的一些活动也要同步得做起来,我又开始了各种网站收集资源.所以,搭博客的想法又泡汤了,而且学的前端基础在这段时间也丢了不少.换了工作后,接触的到了具体实在的项目,积累的相关经验也就多了起来,一些笔记类的应用也用了起来.在开发过程中会遇到许多问题,自己也就更加主动去接受新的知识.可是虽然看到了好的文章,也收藏了起来,但是同样也犯了好多人犯的毛病.收藏夹里的记录一天天增加,却从来没有再次看过.而且,平时看的东西太过零散,无法形成自己的一套知识体系. 动力有了,搭建博客的想法也最终可以落实了.怎么去写个人平时不善言辞,尤其平时做工作汇报时,最是尴尬,忙得要死结果几句话就给总结了.这突然让我想起了学生时代写作文的时候,我是如何凑足字数的.由于自身随心随性,不喜欢约束,只要有个大的目标就行了.个人觉得,约束后的自己不再是自己.有规划更要有自己的想法.我向来不喜欢照搬别人的做法.即使权威,也是不行.模具可以快速生产出许多成品,却无法产出一件精品.写东西也是要看状态的,尤其在写总结性的东西,需要把自己的想法加进去.状态在了,有时候看待问题会更加彻底.至于偏向于技术类型的东西,那就随便了,起码在我看来,那都是套路.无非就是要记录一下问题的解决方案.写什么虽然搭博客的起因更多的来源于总结自己的工作经验.但是这个世界不只有眼前的苟且,还有诗与远方对于洒脱成性的我,看待生活时,总会时不时得冒出自己的想法和感悟.虽说不是写诗,但是凝练文采,沉淀底蕴,未尝不可.小结终于到了小结了,本以为自己言语匮乏.没想到也已经写了这么多.万一哪天灵感来了,估计会写出一部中篇小说.万事开头难,本来想是直接进入主题,写经验总结的.但唯恐坚持不下去,就写了这篇序言,以增加仪式感,希望自己能够坚持下去.]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>序言</tag>
        <tag>博客</tag>
      </tags>
  </entry>
</search>
