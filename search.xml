<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[架构与边界]]></title>
    <url>%2F%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%BE%B9%E7%95%8C%2F</url>
    <content type="text"><![CDATA[架构与边界前言总算把《架构整洁之道》看完了，这种看还是走马观花的看法。这本书和前端没有什么直接的关联，看完之后，你甚至会想，前端有架构这个概念么？其实，从系统架构角度看，前端所做的工作只是可替代的实现细节而已。即使如此，也不妨碍从中学到有用的知识，毕竟道理都是相通的。架构概述步入正题，如果只是一个简单的系统，倒是不用在乎架构设计。但系统越来越庞大，越来越复杂的时候，糟糕的设计只会使得投入与产出不成正比，甚至于入不敷出。而罪魁祸首就是人们经常用来自欺欺人的一句话，「技术债后期还上，产品先上线！」。但是，需求永远是做不完的，更何况，短期内技术升级是看不到任何产出的。稳即是快！稳，是要求软件架构的质量有保证，要求每一个实施的技术方案都经过调研和论证，而不能因业务的压力匆匆上线。虽然，「software」，soft 指的是软件的灵活性，但这和系统的「稳」并不冲突，而恰恰因为稳才使得系统更具灵活性。那么，回过头再看一看，导致生产效率持续降低的这个锅到底谁来背？系统的价值可以通过行为和架构两个维度来衡量。行为价值，是指将需求文档变为实际的代码，为使用者创造价值，同时修复任何 Bug。架构价值，体现在让功能实现起来更容易、修改起来更简单、扩展起来更轻松。我们将这两个维度对照着紧急/重要矩阵：系统行为：紧急系统架构：重要再按优先级排序：重要且紧急重要不紧急不重要但紧急不重要且不紧急系统架构占据第一、第二位，系统行为占据第一、第三位。而实际开发过程中，在业务部门和研发人员的“共同努力下”，错误地将第三优先级的事情当成第一优先级去做。业务部门意识不到系统架构的重要性很正常，但是身为研发人员呢？这是研发人员的职责所在，有必要去抗争来自其它部门的压力，阐述问题的重要性。“这是你的问题！”“不用说了，听我的！”“这个事情不需要讨论。”研发人员出力不讨好，费神又费力，到底为了什么？软件架构的终结目标是，用最小的人力成本来满足构建和维护该系统的需求。边界开发中的最佳实践在团队协作中同样适用，管理团队也需要像架构师一样去协调团队及个体之间的关系。在开发过程中，沟通成本其实还是挺高的，这时候就可以学习学习系统中的数据是如何在组件间传递的。架构师所追求的目标是最大限度地降低构建和维护一个系统所需的人力资源。那么我们就需要了解一个系统最消耗人力资源的是什么？答案是系统中存在的耦合 —— 尤其是那些过早做出的、不成熟的决策所导致的耦合。以前端团队为背景：「尤其是那些过早做出的、不成熟的决策所导致的耦合。」这些很好类比，比如高层拍屁股拍出的想法，产品不成熟的想法等，这些决策直接下发到代码的实现者，然后依据反馈不断纠正。边界线也应该沿着系统的变更轴来画。也就是说，位于边界线两侧的组件应该以不同原因、不同速率变化着。根据不同的职能划分不同的区域，左边偏业务，右边偏技术，尴尬的是处在边界上的这位仁兄。如果组长的话语权不够，那就成为谦卑对象的存在了。先忽略红线，根据单一职责，做好自己的本职工作，有输入有输出，依赖关系简单，沟通效率高。组长和组员的关系就如同展示器和视图的关系，组长需要将需求整理成最终的任务分配下去，工作内容包括参与需求评审，技术方案的制定，项目排期等，组员只需要执行任务并反馈即可。再看一看红线部分，边界本来就是应对频繁变更的需求而建立的防火墙，此时红线绕过边界干预边界的另一头，面对这么多的输入，组员也会蒙圈，这任务谁在负责，我该向谁反馈，这个人提出的问题那个人确认了么，等等一系列的问题。所以，私底下对于频繁变更需求并干预边界右侧的产品，我们称之为傻叉某某。对于经常拍屁股拍出想法并干预右侧的 leader，我们也称之为傻叉某某。协作要想稳，就得保证任务高效有质量地完成。任务派发给了蓝框里的研发人员，研发人员之间的指派总不能靠抓阄来决定。A：“这个开发难度为S级（困难）的任务就交给你了，我先走一步。”B：“。。。”某一天，C: “之前的 A 水平有限，这代码已经没法维护了，重做吧。”B：“。。。”C：“抓紧点，我们要赶超对手，没错，就你一个人。”B：“。。。”从以上对话，我们来思考几个问题。如果 B 的水平和 A 一样，最终的结果是项目还会因为无法维护而重做。如果 B 能够胜任，由于时间的问题，最终的结果可能比第一种情况好一些。如果 B 能够胜任，老板为了加快进度，又投入一个人，最终的结果就是个谜，因为这要取决于 B 的水平。不过现在是一个团队了，团队就应该发挥团队应有的优势。所以，职责要明确，搭配要妥当。]]></content>
      <categories>
        <category>这个想法不一定对</category>
      </categories>
      <tags>
        <tag>前端架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[所谓的微前端]]></title>
    <url>%2F%E6%89%80%E8%B0%93%E7%9A%84%E5%BE%AE%E5%89%8D%E7%AB%AF%2F</url>
    <content type="text"><![CDATA[微前端实践那时候的微前端还没今天这般火热，回过头来仔细琢磨才发现那是最早的一次微前端实践。当时，我们在做项目迁移，使用最新的前端技术重写了系统。可是规划中并没有给我们足够的时间去重写项目，而且二期的需求已经开始排期了。系统的升级没有完成，就只能用老系统。这也意味着新的需求，我们需要在新旧系统上都要做一遍，这段时间里，在人力安排上真是苦不堪言。如果在新系统上完成的功能模块也可以运行在老系统上，这不就省下很多的时间和人力了么？这就是微前端的使用场景吧。而后来又不断有第三方的应用集成进来，现在想想，这种需求其实还是比较常见的。所以要说微前端都用在哪里，可以想到的是，新旧系统迁移和聚合应用。我理解的微前端，就是把不同的前端项目聚在一起，最起码从视图的角度来看，它们是一体的，这些前端应用可以各自独立开发，互不干扰。而在当今的前端圈中，React、Vue 和 Angular 最为流行，这也使得应用聚合时变得麻烦起来，所以也有提出 React 和 Vue 互转的方案。最简单的方式是通过路由分发，可以是在前端应用中配置也可以是反向代理配置。如果是前端路由分发，需要写个路由管理的组件。不过，还可以更省事，就拿上面提到的新旧系统的迁移，我们使用了以下方案。B、C 挂载点就是需要挂载在 A 应用上的 DOM 节点。而对于相同技术栈的前端应用，虽然以上的方法都以使用，但是，这么做就可能有些浪费。既然是相同技术栈，那么依赖就有可能是相同的，而对于共同的依赖没有必要多次去加载。这让人想起了 webpack 上 DLL 插件，就是把基础库剥离出来。还有 iframe，这让人想到一个笑话，有个老板要做引擎，还要做成百度那样的，如果使用 iframe 应该是秒秒钟的事情，不过这东西对 SEO 不友好，而且限制条件比较多，像 MDN 这类网站就是不行的。Visual Studio Code 上展示 web 页面的插件就有用 iframe 实现的。实现微前端的方案还有很多，而且并不是特别难的事情，可能是越花哨的词，让人越觉得调调高吧。]]></content>
      <categories>
        <category>这个想法不一定对</category>
      </categories>
      <tags>
        <tag>微前端</tag>
        <tag>前端架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记开源项目的二次开发]]></title>
    <url>%2F%E8%AE%B0%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E7%9A%84%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[Scratch项目的二次开发背景近些年来，青少儿编程被炒得火热，而 Scratch 语言因其简单易学等性质备受关注。国内多数的 Scratch 教学项目是来自 Github 上的开源 Scratch 项目，目前官方最新的版本 scratch-gui 使用前端流行的 React 重写了一遍，而且该项目还在不断完善更新当中。开源项目的二次开发就是在开源项目的基础上结合公司业务所做的二次开发，如果不考虑具体的项目，需要重视的问题是：在结合公司业务的基础上如何持续同步跟进官方项目？添加自己的代码现在想象一下场景，拉取 GitHub 上的源码后，然后直接写入公司业务代码，一波猛如虎的操作后，再次拉取 GitHub 上的最新代码，发现自己写的代码全部冲突了。自己代码和源码有冲突是件正常的事，但我们依然可以减少这种冲突的出现。要减少这种冲突就需要将公司业务代码从源码中解耦出来，尽量不干或扰覆写源码。说到这，突然想到了设计模式中的中介者模式、装饰者模式等，就是说不管是通过中间层还是包裹层，尽量不修改源码部分。我们再说说 scratch-gui 项目，scratch-gui 使用的是 React + Redux 的技术栈，组件化开发再结合状态管理，在大型项目上，阅读源码是件痛苦的事。组件嵌套深，状态错综复杂，不过 Scratch 在组件分类上还是比较清晰的，有负责展示的基础 UI 组件，有负责状态逻辑的容器组件。之前所说的用来解耦的模式在组件化开发上貌似并不是很好用，尤其是容器组件，与其麻烦地拆解包裹还不如封装自己的业务组件。再说了，像基础组件这类组件，源码可能需要经常修改，二次开发中，即便再省事，也不要想着直接修改这类组件。添加业务代码的原则是：尽量加，避免改，然后在复合组件中组装基础组件。分支管理我们费了那么大的劲去拆分组件不仅仅是为了后期可扩展可维护，更是为了减少因为合并最新源码所带来的代码冲突。对于提交频繁的开源项目，我们希望能够跟进同步最新代码。同时，对于业务代码的改动和提交信息，我们也很十分关注。在说分支管理之前，我们先看看一些常用的 git 命令：1234567891011121314151617181920212223242526# 查看 git 命令git help [command]# 清理文件git clean -df# 查看分支信息git branch -vv# 创建与远程分支关联的分支git checkout -b 本地分支名 远程仓库／远程分支名称 # 关联远程分支git branch (--set-upstream-to=&lt;upstream&gt; | -u &lt;upstream&gt;) [&lt;branchname&gt;]# 取消关联远程分支git branch --unset-upstream [&lt;branchname&gt;]# 删除远程分支git push --delete 远程主机 远程分支# 查看远程仓库git remote -v # 添加远程仓库git remote add 远程仓库名称考虑到前端工程化的普及，我们把分支分为官方源码分支（Office），开发分支（dev），测试分支（test），预发布分支（pre）和生产分支（prod）。我们是基于开源项目的二次开发，代码托管的位置自然会在两个位置，官方源码是在 GitHub 上，而我们的代码会放在公司的服务器上，所以我们需要添加两个远程仓库的地址。除了 office 分支关联 Github 上的远程仓库，其它的分支都是关联自己服务器的远程仓库。在这里我们是将分支管理分为两个阶段，第一个阶段是首次拉取官方源码，切出 dev 分支，完成业务开发。第二个阶段为后期代码跟进同步与后期的需求开发。第一阶段切出 dev 分支后，我们要把公司业务代码了。可是在我们写自己业务的时候，人家官方也可能不断地完善更新。此时，我们要不断去合并最新的代码，在合并时我们使用 rebase 去合并代码，这样我们的提交记录会很清晰，毕竟我们也不会关注官方的更新。当然了，在合并的过程中，可能会遇到了冲突的情况，在这种情况下，好多人喜欢使用 merge 命令。一个一个地去解决突也挺好的，而且 rebase 的功能可不止于此。前期的业务开发完成后，还需要测试上线呢。测试分支（test），预发布分支（pre）和生产分支（prod）都差不多，就只说生产分支（prod）。我们切到 prod 分支，通过 merge 指令合并通过测试的分支。merge 和 rebase ，到底什么场合用，推荐的方案是，个人分支使用 rebase，公共分支使用 merge。第二阶段第二阶段也是差不多，区别可能是我们不仅要解决是官方源码的冲突，还有自己团队代码的冲突。我们从 prod 分支切出 dev 分支，因为可能是团队协作，所以在合并到 prod 分支时，还需要同步 prod 上的更新。我们切出那么多分支可不是闹着玩的，前端项目的打包行为，后端数据的来源的等，在不同的环境下都是存在区别的，所以针对不同的环境需要写不同的指令脚本，这也是开源项目二次开发需要改造的地方。构建及部署并不是说要从零开始设计构建流，开源项目已经定义好了构建流，我们要做的只是按照自己的需要修改构建脚本。在 scratch-gui 中，构建命令是由 NPM 脚本结合 webpack 构建工具来完成的。在开发环境中为了提高开发体验，我们可能需要修改 SourceMap，使用模块热替换等，在不同环境我们还需要使用不同的打包策略等等。123456&#123;"dev": "webpack --config webpack.config.dev.js","test": "webpack --config webpack.config.test.js","pre": "webpack --config webpack.config.pre.js","prod": "webpack --config webpack.config.prod.js"&#125;至于部署，前端项目是相对比较容易的，把打包好的项目往服务上一丢就算完成部署了。手动部署，自动化部署还是持续部署，这都无所谓，我们只要针对不同环境配置不同的构建脚本即可。补充公司的 Scratch 项目之前是有做过二次开发的，由于没有考虑分支管理和后期的持续跟进，所以后期拉取最新代码时，到处都是冲突，至此，项目已经没有持续开发下去的意义了。之前的改造也是挺有意思的，改造重点是放在了项目的输入和输出上。这么做的好处就是不用详细地知道项目的细节，起码在视图上让人察觉不出任何不同。不过，就是这种很常用的方法，在这里却暴露了一个很大的问题。项目是开源的、是持续更新的，我们同样也需要持续跟进，在之前的项目中，虽然做到了输出和输入的一致，但是也抛弃项目的细节 —— 项目原有的状态管理。我这一次的改造没有采用这种方法，而是使用的上面提到的方案。在我看来，基于 Scratch 的二次开发难度并不大只是有些繁琐。组件化开发配合状态管理，头痛的就是这种数据驱动的方式，状态在不同组件的生命周期中穿梭，导致状态的跟踪特别麻烦。所以，只有搞清楚组件的层级关系和用途，才能把整条线串起来。项目大体如上，Scratch3 模式分为两种，一为可编辑模式，另一个是不可编辑模式。Scratch3 网站是编程官网的子站点，使用的是反向代理指向不同的项目。Scratch3 项目经过二次开发后打包部署到线上，另一方面也要打包成依赖上传到 npn 私库，供编程官网使用。编程官网和 Scratch3 的技术栈不同，编程官网提供挂载点即可。]]></content>
      <categories>
        <category>开发三两事</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>开源项目</tag>
        <tag>二次开发</tag>
        <tag>分支管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读《JavaScript 轻量级函数式编程》]]></title>
    <url>%2F%E8%AF%BB%E3%80%8AJavaScript-%E8%BD%BB%E9%87%8F%E7%BA%A7%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E3%80%8B%2F</url>
    <content type="text"><![CDATA[读后感很久之前，组内分享过函数式编程的相关内容，听完之后的感受就是和没听没什么区别。函数式编程中有许多概念，对于熟悉和见惯面向对象编程的人来说，一时半会不能够消化。而且，就连值和引用、闭包等概念都分不清的人，对JavaScript 函数式编程的入门更是困难重重。《Functional-Light JavaScript》（中文翻译版《JavaScript 轻量级函数式编程》）自称是轻量级的，抛开了概念的讲解，从为什么用，怎么用，最终呈现什么等几个方面带我们重新认识了函数这个基础且重要的概念。为什么函数式编程当下有三种编程范式，结构化编程、面向对象编程和函数式编程。虽然函数式编程是近些年才采用的编程范式，但是它的发明却是最早的。函数式编程概念是基于 𝛌 演算的直接衍生物，𝛌 演算法的一个核心思想是不变性。故，理论上讲，在函数式编程语言中应该不存在赋值语句的。函数式编程的原则可以使得我们写出的代码是可读、可信任的，但这并不代表它是容易理解的。声明式的风格可以让我们知道程序是干什么的，但是要写出这样的程序却不是很容易理解的，起码对于刚接触函数式编程的人来说。在维护代码的过程中，大部分时间是用来阅读和理解代码。有时候我们需要小心翼翼地阅读每一行代码，生怕某一个不为人知的骚操作会引发了一些列的 bug；有时候也需要在不同函数调用中了解程序的意图。总之，函数式编程的一些原则可以让我们写出可读性高、可验证的代码。当然，即便掌握了函数式编程，也并不意味着你一定得用它。最好的代码是可读性高的代码，因为它在正确的（理想主义）和必然的（正确的）之间寻求到了恰到好处的平衡。函数基础在数学中，函数总是获取一些输入值，然后返回一个输出值，输入值和输出值存在某种关系的映射。在函数式编程中使用的就是数学意义上的函数，接受输入值，明确 return 值。函数通常是这个模样：12345function foo(x, y, z)&#123; // ... &#125;foo.length // 3foo(1, 2, 3);foo.length 是函数期望的参数个数，通常就是形參个数。但是，并不要求实参和形參的个数相同，在函数内部可以通过 arguments 查看所有入參（箭头函数无此参数）。使用 ES6 中的解构可以轻松给变量绑定入參的值：12345678910function foo([x, y, ...args]) &#123; // ... &#125;function foo(params) &#123; var x = params[0]; var y = params[1]; var args = params.slice(2); // ...&#125;由以上对比，我们可以看出，声明式代码通常比命令式代码更干净。所以只要有可能，还是尽可能使用声明式和自解释的代码。有时候函数会根据不同的输入值来重载不同的功能：12345678function foo(x,y) &#123; if (typeof x == "number" &amp;&amp; typeof y == "number") &#123; return x * y; &#125; else &#123; return x + y; &#125;&#125;这种设计虽然暂时很方便，但是对以后的功能添加或修改会带来很大的麻烦。在上面已经提到函数要有明确的 return 值，如果函数内部改变了外层作用域的变量或引用类型的入參，那么这个函数就有了副作用的，对该函数外的环境造成了污染。我们希望函数是个没有副作用的函数，即纯函数。1234567891011121314function sum(list) &#123; var total = 0; for (let i = 0; i &lt; list.length; i++) &#123; if (!list[i]) list[i] = 0; total = total + list[i]; &#125; return total;&#125;var nums = [ 1, 3, 9, 27, , 84 ];sum( nums ); // 124函数可以接受并返回任何类型的值，当这种类型的值恰好是函数时，它就叫高阶函数。而真正高阶的用法，就是闭包，它可以记录并且访问作用于外的变量，甚至该函数在不同作用域中被执行。1234567891011121314function runningCounter(start) &#123; var val = start; return function current(increment = 1)&#123; val = val + increment; return val; &#125;;&#125;var score = runningCounter( 0 );score(); // 1score(); // 2score( 13 ); // 15闭包中保存的变量并不会在函数执行后自动销毁，只要内部函数依然存在对变量的引用，变量就会一直保留。在函数式编程中，闭包是最重要的基础，所以，这个概念一定要理解。还有的函数是没有名字的，这种函数称之为匿名函数，使用最多的是立即执行表达式：12345(function()&#123; // 我是 IIFE!&#125;)();命名函数的好处有很多，可以在堆栈中方便调试，可以通过名字引用自身等。但并不是所有的函数都可以命名的，箭头函数可以说是十分简洁，可以使用最简单的符号来表示一个函数。1people.map( person =&gt; person.nicknames[0] || person.firstName );箭头函数除了写法简洁之外，还有一个可以称之为好处的便是 this。箭头函数中的 this 是基于作用域的，是可以预测的。而对于普通函数，this 是动态绑定的，是基于调用者的。不管是哪一种 this， 我们还是希望能够显式地表示上下文。12345678910function sum(ctx) &#123; return ctx.x + ctx.y;&#125;var context = &#123; x: 1, y: 2&#125;;sum( context );函数的输入在程序中往往将不变的封装起来，变化的隔离开来。很多时候不变的包括一些预设的参数。首先封装一个请求函数：1234// 步骤一：function ajax(url,data,callback) &#123; // ..&#125;对于不同的请求，有不同的 url 或参数：12345678// 步骤二：function getPerson(data,cb) &#123; ajax( "http://some.api/person", data, cb );&#125;function getOrder(data,cb) &#123; ajax( "http://some.api/order", data, cb );&#125;url 就是预设的参数，而剩余的参数在调用的时候传入。12// 步骤三：getPerson( &#123; user: CURRENT_USER_ID &#125;, cb );仔细观察步骤二，代码似乎还可以提炼下：1234567// 步骤二：var partial = (fn, ...presetArgs) =&gt; (...laterArgs) =&gt; fn(...presetArgs, ...laterArgs);var getPerson = partial(ajax, "http://some.api/person");var getOrder = partial(ajax, "http://some.api/order");步骤二的转换就是偏函数的应用，它是通过预设参数的方式来减少入參的数量。如果颠倒入參的顺序，就成了右偏函数。同样是对函数输入管理的技术，即柯里化，该技术将一个接受多个实参的函数拆解成连续的链式函数，每个链式函数接受单一实参并返回接受下一个实参的函数。1234567891011121314151617181920212223242526272829function sum(...args) &#123; var sum = 0; for (let i = 0; i &lt; args.length; i++) &#123; sum += args[i]; &#125; return sum;&#125;sum(1, 2, 3, 4, 5 ); // 柯里化var curry = (fn, arity = fn.length, nextCurried) =&gt; (nextCurried = prevArgs =&gt; nextArg =&gt; &#123; var args = prevArgs.concat( [nextArg] ); if (args.length &gt;= arity) &#123; return fn( ...args ); &#125; else &#123; return nextCurried( args ); &#125; &#125; )( [] );// (5 用来指定需要链式调用的次数)var curriedSum = curry( sum, 5 );curriedSum( 1 )( 2 )( 3 )( 4 )( 5 );从以上的代码可以发现，无论是偏函数还是柯里化，都是收齐所有的实参后才执行原函数，也就是说没必要一次性传入所有的参数，而且柯里化这种只接受单一参数的特性在后面的组合函数中也起着很重要的作用。函数式编程可以说在参数上下了很大的功夫，甚至还有种称之为无形參的风格，其目的就是移除非必要的形參到实参之间的映射。无形參风格是否提高了代码的可读性，有没有必要使用无形參风格，还需要你自己去定夺。12345678910function double(x) &#123; return x * 2;&#125;[1,2,3,4,5].map( function mapper(v)&#123; return double( v );&#125; );// 无形參风格；[1,2,3,4,5].map( double );组合函数函数组合，就是把上一个函数的输出值作为下一个函数的输入值，并以此持续下去。看个例子，将一句话拆分为单词数组：1234567891011121314151617181920212223242526272829303132333435// 转小写，过虑出单词；function words(str) &#123; return String( str ) .toLowerCase() .split( /\s|\b/ ) .filter( function alpha(v)&#123; return /^[\w]+$/.test( v ); &#125; );&#125;// 去重；function unique(list) &#123; var uniqList = []; for (let i = 0; i &lt; list.length; i++) &#123; // value not yet in the new list? if (uniqList.indexOf( list[i] ) === -1 ) &#123; uniqList.push( list[i] ); &#125; &#125; return uniqList;&#125;var text = "To compose two functions together, pass the \output of the first function call as the input of the \second function call.";function uniqueWords(str) &#123; return unique( words( str ) );&#125;var wordsUsed = uniqueWords(text);// ["to","compose","two","functions","together","pass",// "the","output","of","first","function","call","as",// "input","second"]数据的流向：1wordsUsed &lt;-- unique &lt;-- words &lt;-- text但是函数式编程喜欢声明式风格，关注点在是什么而不是怎么做，我们不需要知道具体的实现细节。我们希望是这样的：1234567// 命令式function shorterWords(text) &#123; return skipLongWords( unique( words( text ) ) );&#125;// 声明式var shorterWords = compose( skipLongWords, unique, words );如何实现函数 compose ？12345678910111213141516171819202122232425262728293031323334353637// 写法一：var compose = (...fns) =&gt; result =&gt; &#123; var list = fns.slice(); while (list.length &gt; 0) &#123; // 将最后一个函数从列表尾部拿出 // 并执行它 result = list.pop()( result ); &#125; return result; &#125;;// 写法二：var compose = (...fns) =&gt; fns.reverse().reduce( (fn1,fn2) =&gt; (...args) =&gt; fn2( fn1( ...args ) ) );// 写法三：var compose = (...fns) =&gt; &#123; // 拿出最后两个参数 var [ fn1, fn2, ...rest ] = fns.reverse(); var composedFn = (...args) =&gt; fn2( fn1( ...args ) ); if (rest.length == 0) return composedFn; return compose( ...rest.reverse(), composedFn ); &#125;;副作用和值的不可变性const 是用来声明一个常量的，而常量就是不允许被重新赋值的变量。在排查问题的时，我们很少将注意力放在由 const 声明的变量上，毕竟它就是一个无关痛痒的常量。如果最终就是因为这个常量发生了变化，会不会很刺激？！虽然 const 声明的是常量，但是对于引用类型的值，程序还是允许它改变的。因为 const 的不靠谱，我们不得不重新关注由它声明的常量。12const x = [ 2 ];x[0] = 3;数据的突变引发了一系列意想不到的 bug，究其原因，是变量被共享或有着不同的用处。12345678910111213var x = 1;foo();console.log( x );bar();console.log( x );baz();console.log( x );当变量被共享时（在函数 foo()、bar()、baz() 中，任何一个函数都有可能改变变量 x），最终我们无法确认 x 到底是什么值，为了追踪变量 x 的变化，我们不得不仔细逐个阅读函数 foo()、bar()、baz()。显而易见，这给我们阅读理解代码带来了很大的麻烦。12345678910111213141516function sum(list) &#123; var total = 0; for (let i = 0; i &lt; list.length; i++) &#123; if (!list[i]) list[i] = 0; total = total + list[i]; &#125; return total;&#125;var nums = [ 1, 3, 9, 27, , 84 ];sum( nums ); // 124sums; //[1, 3, 9, 27, 0, 84]而对于引用同一对象的不同变量，对象的改变也是同步的，这种改变往往是不易察觉的。所以，对于引用类型的特殊性，需要特别注意的。归纳一下，什么样的变量被共享时需要额外上心的，外层作用域里的变量和引用类型的变量。如何避免这种数据突变带来的状态紊乱的？可以想到的是将变量变成只读的或重新拷贝一份以作区别。1234567var x = Object.freeze( [ 2, 3, [4, 5] ] );// 不允许改变：x[0] = 42;// oops，仍然允许改变：x[2][0] = 42;我们可以使用 Object.freeze 等 API 将数据转为不可变，但是这种 API 的还是有局限性的，只能浅层限制不可变。要想使得一个深层嵌套的对象不可变，就需要深度遍历对每个属性使用 Object.freeze 等 API。另一种思路就是拷贝一份数据，这样的话，再怎么折腾副本都不会影响到源数据。123456function addValue(arr) &#123; var newArr = [ ...arr, 4 ]; return newArr;&#125;addValue( [1,2,3] ); // [1,2,3,4]在此，我们不由地想起函数式编程的核心 —— 不变性。我们看到了变化的数据给程序造成的可读性差、状态紊乱等坏处，自然我们就想到数据不变性会让程序更加友好。但值的不变性并不意味着值代表的状态不会发生改变，所以就有了值的拷贝。这种不变性是指，当需要改变程序中某个状态时，我们不能改变源数据，而是拷贝跟踪它的副本。拷贝也有深拷贝和浅拷贝，我们需要的是独立于源数据的副本。1234567891011function updateLastLogin(user) &#123; var newUserRecord = Object.assign( &#123;&#125;, user ); newUserRecord.lastLogin = Date.now(); return newUserRecord;&#125;var user = &#123; // ..&#125;;user = updateLastLogin( user );然而，拷贝也不是没有代价的。突然多出来的副本，多少会影响到性能。我们希望有种方式可以减少内存占用，提高性能。它使得不同变量指向同一个数据源同时有着不同版本的数据，不同版本的数据互不影响，这有点像 git 的版本控制，这样的话，值的不变性这个语义也得以保留。其实已经有一些库实现了类似的优化，如 Immutable.js 等。如果用两个字总结以上的内容，无疑，就是「干扰」了，这种干扰来自于非预期的数据变化。作为函数式编程的主角 —— 函数，我们自然也会希望函数内部不会造成数据的突变，一切结果是可预测的，更多的希望它能够符合函数式编程的核心 —— 不变性。也就是说，我们在编码的过程中要减少函数的副作用。除了以上所说的数据共享，副作用还包括随机性 （Math.random()）、IO 操作、竞态问题等。副作用是多种多样，我们使用纯函数来减少这种副作用。换句话说，与纯函数相违背的，我们基本可以认为是副作用。什么是纯函数？有说纯函数就是幂等函数，但并不是所有的纯函数都是数学概念上的幂等。12345678910111213141516171819var hist = document.getElementById( "orderHistory" );// 幂等的：hist.innerHTML = order.historyText;// 非幂等的：var update = document.createTextNode( order.latestUpdate );hist.appendChild( update );// 非幂等的：function calculateAverage(list) &#123; var sum = 0; for (let i = 0; i &lt; list.length; i++) &#123; sum += list[i]; &#125; return sum / list.length;&#125;calculateAverage( [1,2,4,7,11,16,22] ); // 9另一种定义函数的方法是，给定相同的输入（一个或多个），它总是产生相同的输出。12345const PI = 3.141592;function circleArea(radius) &#123; return PI * radius * radius;&#125;还有一种定义就是，即纯函数具有引用透明性。引用透明性是指一个函数调用可以被它的输出值所代替，并且整个程序的行为不会改变。换句话说，不可能从程序的执行中分辨出函数调用是被执行的，还是它的返回值是在函数调用的位置上内联的。1234567891011121314151617function calculateAverage(list) &#123; var sum = 0; for (let i = 0; i &lt; list.length; i++) &#123; sum += list[i]; &#125; return sum / list.length;&#125;var nums = [1,2,4,7,11,16,22];var avg = calculateAverage( nums );console.log( "The average is:", avg ); // The average is: 9var avg = 9;console.log( "The average is:", avg ); // The average is: 9代码的副作用降低了程序的质量，同时也加大了我们对代码的阅读难度。没有副作用的程序是不存在的，我们只是通过重构不纯的函数或封装副作用等方式来避免副作用的产生。闭包和对象首先用两段代码来描述同一个东西：12345678910111213141516171819202122232425// 闭包方式function person(name,age) &#123; return happyBirthday()&#123; age++; console.log( "Happy " + age + "th Birthday, " + name + "!" ); &#125;&#125;var birthdayBoy = person( "Kyle", 36 );birthdayBoy(); // Happy 37th Birthday, Kyle!// 对象方式var birthdayBoy = &#123; name: "Kyle", age: 36, happyBirthday() &#123; this.age++; console.log( "Happy " + this.age + "th Birthday, " + this.name + "!" ); &#125;&#125;;birthdayBoy.happyBirthday();// Happy 37th Birthday, Kyle!可以发现闭包和对象就是对同一事物的两种表达方式。关于闭包和对象有着以下的论调：一个没有闭包的编程语言可以用对象来模拟闭包。一个没有对象的编程语言可以用表报模拟对象。现在，我们在 JavaScript 中用对象模拟闭包。1234567function outer() &#123; var x = 1; return function inner()&#123; return x; &#125;;&#125;首先要解决 outer() 执行后，x 变量没有被销毁。在创建函数 outer 时，有个对象会保存该作用域下的所有变量:123scopeOfOuter = &#123; x: 1&#125;;在创建函数 inner 时，也会生成一个 scopeOfInner 的作用域对象，这个对象的原型指向 scopeOfOuter：12scopeOfInner = &#123;&#125;;Object.setPrototypeOf( scopeOfInner, scopeOfOuter );所以在访问 x 变量时，更像是在访问 scopeOfInner.x，然后沿原型链查找。以上只是些假设，真实的情况肯定比这复杂。这里只是论证可以使用对象实现闭包，同样我们也可以使用闭包实现对象。递归递归可以说是很函数式，它的优点是更具有声明行，简洁易读，但最大的弊端还是内存占用方面。123456789101112131415function foo() &#123; var z = "foo!";&#125;function bar() &#123; var y = "bar!"; foo();&#125;function baz() &#123; var x = "baz!"; bar();&#125;baz();每个函数调用都将开辟出一小块称为堆栈帧的内存。堆栈帧中包含了函数语句当前状态的某些重要信息，包括任意变量的值。之所以这样，是因为一个函数暂停去执行另外一个函数，而另外一个函数运行结束后，引擎需要返回到之前暂停时候的状态继续执行。但是对于递归来说，可能会生成上万的堆栈，最终会导致爆栈。我们希望内层函数在函数底部调用时，外部函数的堆栈直接弹出。这种技术叫做尾调用优化。减少内存的方法还包括后继传递风格（CPS）和 Trampoline 等。利用CPS变换，把任意递归函数改写成尾调用形式，以 continuation 链的形式，将递归占用的栈空间转移到堆上，避免爆栈的悲剧。（CPS变换可以用来将普通递归转变为尾递归？？）在缺乏尾调用优化的语言中，并不知晓函数不会返回，状态、参数压栈依旧会发生，因此需要手动强制弹出下一层调用的函数，禁止解释器的压栈行为，这就是所谓的Trampoline。1234567891011121314151617181920212223242526272829303132333435363738394041// 斐波那契function fib(n) &#123; if (n &lt;= 1) return n; return fib( n - 2 ) + fib( n - 1 );&#125;// CPSfunction fib(n,cont = r =&gt; r) &#123; if (n &lt;= 1) return cont( n ); return fib( n - 2, n2 =&gt; fib( n - 1, n1 =&gt; cont( n2 + n1 ) ) );&#125;function trampoline(fn) &#123; return function trampolined(...args) &#123; var result = fn( ...args ); while (typeof result == "function") &#123; result = result(); &#125; return result; &#125;;&#125;// trampoline 化trampoline(fib(n,cont = r =&gt; r) &#123; if (n &lt;= 1) return cont( n ); return () =&gt; fib( n - 2, n2 =&gt; fib( n - 1, n1 =&gt; cont( n2 + n1 ) ) );&#125;)吐槽书中还有其它章节，大部分属于实操，按下不表。对于 JavaScript 函数式编程入门，本书倒是一个不错的选择。不知道是外国人本来就说话啰嗦还是翻译的问题，中文版有些地方读起来不是很顺畅。不过翻译向来是出力不讨好，请原谅我的吐槽，你们都是棒棒的！]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>函数式编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读《乌合之众》]]></title>
    <url>%2F%E8%AF%BB%E3%80%8A%E4%B9%8C%E5%90%88%E4%B9%8B%E4%BC%97%E3%80%8B%2F</url>
    <content type="text"><![CDATA[读后感在读《乌合之众》的过程中，有时候会想，如果作者生在中国该多好，有着时间跨度长，历史悠久的群体可以研究，定会获得意想不到的收获。个人认为本书的论调基础是，人终究不是一个理性的人，能够被群体接受的意见往往不是最优的，而是能够被普遍接受的。语录个人有意识的行为，会逐渐被群体无意识行为取代。理性只是较晚的人类才有的属性，并且还不够完美，还不能揭示无意识的规律，理性想要站稳脚跟，还需要未来很长时间。在我们的所有行为中，无意识作用很大，而理性却没什么作用。群体是不善于推理的，但却是急于采取行动的。创造文明，领导文明的，从来都不是群体，而是少数的知识贵族。群体有的只是强大的破坏力，他们的统治永远都是一个野蛮阶段。文化的高级阶段的表现有着复杂的典章制度，能够从原始的本能状态转为思想的理性状态。最容易被人们容忍的办法，其实是不怎么清楚、不容易理解，而且看上去负担最小的办法。个人的自觉的个性消失，并且情感和思想要和其他人一起转向一个共同的方向，这是想要组成群体的个人所必须表现的特征。无意识现象不但存在于有机体的生活中，而且存在于智力活动中，并发挥着一种完全压倒性的重要作用。事实上，人们在智力上是有很大差异的，但在本能和情感方面是很相似的。在集体的心理中，个人的才智是被削弱的，个性也同样被削弱了。也就是异质性被同质性吞没，无意识的特性品质占据了上风。群体中可以累加的一般只有愚蠢而不是天生的智慧。群体中的每个个人只是把他们拥有的共同的寻常品质集中在一起，那么这个群体所拥有的只能是明显的平庸，而无法创造出新的特点。无意识人格的强势，有意识人格的消失，通过暗示和相互传染的作用，人的思想和感情向着一个共同的方向发展，并且会立刻将这种暗示的观念转化为行动。群体感情的狂暴，会因为群体的责任感消失而得到强化，尤其是在异质的群体中，而且这个群体中人数越多，就越会这样。群体有着明确认识的感情，就是专横和偏执，群体中的他们很容易产生这种感情，而且，只要有人在他们中间，暗示他们，或者煽动他们的这种情绪，他们会立刻付诸行动，将之实现。一种观念的产生，不管它刚出现时有多么高深和伟大的成分，不管它多么伟大，仅仅是因为它进入了群体这个理由，处在群体低下智力的范围，并对群体产生的影响，就让这种观念的伟大成分丧失殆尽。一种观念，只有经过彻底的改造，并进入无意识领域，变成一种情感，才能被群体接受。任何推理，不管是高级的推理，还是群体的拙劣的推理，都需要借助他们头脑中的观念，但是有所差别的是，群体用来推理的各种观念之间，没有逻辑性，只有表面的连续性和相似性。把群体不同的事物，只在表面上有一些相似的事物混合在一起，同时让具体的事物普遍化，这就是群体推理的一个特点。对于智慧形象思维的群体来说，形象的重要性可想而知，他们一般也只能被形象打动。这些形象可以吸引或者恐吓群体，自然而然就成为群体行动的最直接动机。可以影响民众想象力的，是事件发生以及引起人们注意力的方式，并不仅仅是事件的真实本身。一切宗教的创立者，或者某个政治信条的创立者，他们之所以能够站稳脚跟，取决于一个共同的特点，就是他们都成功地激起了群众那种想入非非的感情。在感情与理性的冲突中，感情从未失败过。是时间把各种观念、信仰、思想等碎片集聚起来，形成这个时代的思想和观念。可以说，思想与观念的形成，根植于漫长的岁月的积累，可不像掷骰子那样凭运气。各个不同民族的行动，支配他们的是自己的性格，但凡与这种性格不吻合的，即使拿来了，也不过是暂时借来的，只能作为表面的伪装。国家用教育、教科书，让很多人具有了高文凭，然而国家只能利用这部分人中很小的一部分，那么另一部分只能无事可做。所以，工作只能给最先来的人，后面剩下的人变成为了敌人。一切文明存在的主要动力向来不是理性，也可以说，尽管理性是存在的，但文明的动力始终还是各种感情，这些感情包含有尊严、自我牺牲、宗教信仰、爱国主义精神和对于荣誉的热爱。让某种观念进入群众的头脑，最可靠最有效的办法，就是做出断言，并且简洁有力，不用理睬任何的证据和推理。利用断言、重复和传染而进行普及的观念，借助环境得到了最大的威力，然后它们具有了一种神奇的力量，那就是我们经常说的名望。没有成功陪伴的名望，是很容易在极短的时间里就走向消失的结局的。所有的普遍的信念，都是虚构的，它能够生存的唯一条件，就是不要去审查它。群体的头脑中，一旦有新的教条生根，那么这些教条作为源泉，会持续鼓舞人心，并且会产生出各种各样的制度、生活方式以及艺术。人们处于这样的环境中，就会被它绝对地控制。能够引导意见的力量是不存在的，再加上普遍信仰的不断消亡，产生的唯一结果就是，不管是什么秩序，总会存在着完全相反的意见。并且让群体产生一种态度，就是只要不是直接触及他们的利益，他们就不会关心。因为讨论和分析，所有的意见都没有了名望。意见的特征退化得很快，持续的时间也非常短暂，我们的热情也就很难被唤醒。现代人也开始变得越发麻木不仁。一种文明，如果使得群众占据了上风，那么它离消亡也就不远了。如果非要找一些事去延缓它的毁灭，那就只剩群众极不稳定的意见了，还有群众对所有普遍信仰所表现出的麻木不仁。群体所拥有的状态，或者说支配群体的那种力量都类似于一种野蛮的状态，或者可以理解为像这种野蛮状态的一种回归。种族需要的是获得稳定结构的集体精神，只有这样，种族才会逐渐摆脱那种缺乏思考的群体力量，进而走出野蛮状态。古老的理想一旦消失，种族的才华也就消失了。它回到了原始状态，变成一群独立的个体，成为乌合之众。它没有同一性，没有未来，它所拥有的特性只是乌合之众一时的特点。它的文明的稳定性已经没有了，毫无办法地随波逐流。至上的权力是民众，盛行的是野蛮的风气。文明可能依旧比较精彩，因为历史悠久，文明的外表依旧存在，但是它已经是将要倾倒的大厦，摇摇欲坠，没有支撑，只等风暴来临，它就马上倾倒。一个民族的生命循环，就是在追求理想中，从野蛮到文明，然后，理想没有了优势，便会走向衰落，然后死亡。]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>乌合之众</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【译】The story of a V8 performance cliff in React]]></title>
    <url>%2F%E3%80%90%E8%AF%91%E3%80%91The-story-of-a-V8-performance-cliff-in-React%2F</url>
    <content type="text"><![CDATA[前言本文是根据自己的理解翻译而来，如有疑惑可查看原文 The story of a V8 performance cliff in React。本次暂定翻译三篇文章：JavaScript engine fundamentals: Shapes and Inline Caches(Published 14th June 2018)JavaScript engine fundamentals: optimizing prototypes(Published 16th August 2018)The story of a V8 performance cliff in React(Published 28 August 2019)JavaScript types在 JavaScript 中，值有 8 总类型（当前）：Number，String，Symbol，BigInt，Boolean，Undefined，Null，Object。除了一个明显的例外，这些类型都可以用 typeof 直接查看。12345678910111213141516typeof 42;// → 'number'typeof 'foo';// → 'string'typeof Symbol('bar');// → 'symbol'typeof 42n;// → 'bigint'typeof true;// → 'boolean'typeof undefined;// → 'undefined'typeof null;// → 'object' 🤔typeof &#123; x: 42 &#125;;// → 'object'typeof null 返回的是 &#39;object&#39;，而不是 &#39;null&#39;，要了解为什么，首先要把所有的 JavaScript 类型分成两组：objects(即，对象类型)primitives(即，非对象类型)照此来说，null 表示「没有对象」，而 undefined 表示 「没有值」。按照这个思路，Brendan Eich 在设计 JavaScript 时，受到 Java 的影响，使得右手边的值执行 typeof 后都返回 object。因此，即便规范里有 Null 类型，typeof null === &#39;object&#39; 依然成立。Value representationJavaScript 引擎能够在内存中表示任意的 JavaScript 值。然而，值得注意的是，JavaScript 引擎在内存中值类型的表现形式是不同于 JavaScript 中的类型描述。例如，42，在 JavaScript 中是 number 类型。12typeof 42;// → 'number'在内存中有好多种方式表示整数，例如 42:representationbitstwo’s complement 8-bit0010 1010two’s complement 32-bit0000 0000 0000 0000 0000 0000 0010 1010packed binary-coded decimal (BCD)0100 001032-bit IEEE-754 floating-point0100 0010 0010 1000 0000 0000 0000 000064-bit IEEE-754 floating-point0100 0000 0100 0101 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000ECMAScript 将数字标准化为 64 位浮点值，也称为双精度浮点或 Float64。但是，这并不意味着 JavaScript 引擎总是以 Float64 的形式存储数字 —— 这么做会很低效。引擎会选择其它的内部表现形式，除非观测到的行为完全匹配 Float64。在真实的 JavaScript 应用中，大多数数字都是合法的 ECMAScript 数组索引，即，属于 0 ~ 2³²−2 范围内的整数。123array[0]; // Smallest possible array index.array[42];array[2**32-2]; // Greatest possible array index.JavaScript 引擎会为数字选择最优存储的表达形式以此优化数组元素的访问效率。对于处理器的内存访问操作，数组索引必须是二进制补码的形式。用 Float64 表示数组是一种很费性能的行为，因为每次访问数组元素引擎都需要在 Float64 和二进制补码之间转换。32 位的二进制补码表达形式对数组操作是很有用的。通常来说，处理器执行整型操作比执行浮点型操作要快得多。所以说，下面的例子，第一个循环比第二个循环快两倍。1234567for (let i = 0; i &lt; 1000; ++i) &#123; // fast 🚀&#125;for (let i = 0.1; i &lt; 1000.1; ++i) &#123; // slow 🐌&#125;操作符也是一样。在下面的代码中，模运算符的性能取决于处理的是否是整数。123const remainder = value % divisor;// Fast 🚀 if `value` and `divisor` are represented as integers,// slow 🐌 otherwise.如果两个操作数都是整数的形式，CPU 就可以高效地计算出结果。如果除数是 2 的倍数，V8 还会有额外的捷径。对于值是浮点型的形式，计算过程会变得复杂耗时。因为整型操作的执行速度通常比浮点型要快很多，所以，引擎就应该使用二进制补码来表示所有的整型和整型操作的结果。遗憾的是，那是有悖于 ECMAScript 规范的！ECMAScript 采用了 Float64，某些整数运算实际上产生的是浮点型。在下面这种情况下，对于能够产生正确的结果很重要。12345678910111213141516171819// Float64 has a safe integer range of 53 bits. Beyond that range,// you must lose precision.2**53 === 2**53+1;// → true// Float64 supports negative zeros, so -1 * 0 must be -0, but// there’s no way to represent negative zero in two’s complement.-1*0 === -0;// → true// Float64 has infinities which can be produced through division// by zero.1/0 === Infinity;// → true-1/0 === -Infinity;// → true// Float64 also has NaNs.0/0 === NaN;左边的值都是整型，而右边的却是浮点型。以上的操作在使用 32 位二进制补码的形式是没法正确执行的。JavaScript 引擎必须确保整型操作被合理地处理以生成想要的 Float64 结果。对于在 31 位有符号整数范围内的小整数，V8 有特殊的表示形式，称为 Smi。对于非 Smi 的数值会被表示为 HeapObject，它是内存中某些实体的地址。我们使用一种特殊的 HeapObject，即所谓的 HeapNumber，来表示超出 Smi 范围的数字。123456789101112 -Infinity // HeapNumber-(2**30)-1 // HeapNumber -(2**30) // Smi -42 // Smi -0 // HeapNumber 0 // Smi 4.2 // HeapNumber 42 // Smi 2**30-1 // Smi 2**30 // HeapNumber Infinity // HeapNumber NaN // HeapNumber如上所示，某些数字被表示为 Smi，其它数字被表示为 HeapNumber。V8 对 Smi 专门优化，因为在真实的 JavaScript 编程中，小的整数是非常普遍的。Smi 没必要在内存中分配专用的实体，而且可以素快速地整型操作。Smi vs. HeapNumber vs. MutableHeapNumber有以下对象：1234const o = &#123; x: 42, // Smi y: 4.2, // HeapNumber&#125;;x 的值 42 被编程为 Smi，因此它被存储在对象里。另一方面值 4.2 需要一个独立的实例（空间）来保存这个值，并且这个对象会指向这个实体。运行以下 JavaScript 代码片段：1234o.x += 10;// → o.x is now 52o.y += 1;// → o.y is now 5.2这种情况下，x 的值可以就地更新，因为新的值 52 也在 Smi 的范围内。然而，新的值 y=5.2 不在 Smi 范围内且不同于之前的值 4.2，因此 V8 为 y 重新分配了新的 HeapNumber 实体。HeapNumber 是不可变的，它使得某些优化成为可能。例如，我们把 y 赋值给 x：12o.x = o.y;// → o.x is now 5.2我们只需要把它连接到同一个 HeapNumber 上而不是重新分配一个新的实体（空间）。HeapNumber 不可变也存在缺点，如果更新的值经常不在 Smi 的范围内，它就会变慢，例如下面的例子：1234567// Create a `HeapNumber` instance.const o = &#123; x: 0.1 &#125;;for (let i = 0; i &lt; 5; ++i) &#123; // Create an additional `HeapNumber` instance. o.x += 1;&#125;第一行创建了一个 HeapNumber 实例，其初始值为 0.1。在循环体中值从 1.1，2.1，3.1，4.2 变到 5.1，一共创建了 6 个 HeapNumber 实例，其中 5 个会在循环结束后变没有任何用处。为了避免这种情况，作为优化，V8 提供了就地更新非 Smi 数值的方法。当一个字段对应着非 Smi 的数值，V8 会在 shape 上将这个字段标记为 Double，并分配一个保存 Float64 的 MutableHeapNumber 实体。当字段里的值发生变化时，V8 不必分配一个新的 HeapNumber，而是在 MutableHeapNumber 实体中就地更新。然而，需要注意的是，MutableHeapNumber 中的值是可以改变的，所以值不应该传来传去的。例如，你把 o.x 赋值给变量 y，你不希望 y 会随着 o.x 的改变而改变！所以在给 y 赋值前，必须将 o.x 的值重新包装成 HeapNumber。对于浮点型，V8 已经默默地包装了一下。但是，对于小的整数也采用和 MutableHeapNumber 相同的方法，就会显得浪费，因为 Smi 本就是一种更高效的表现形式。12345const object = &#123; x: 1 &#125;;// → no “boxing” for `x` in objectobject.x += 1;// → update the value of `x` inside object为了避免低效率，我们会在 shape 上为小整数对应的字段上标记 Smi，并且会原地更新数值，只要这个数值在 Smi 范围内。Shape deprecations and migrations如果一个字段里包含的值在 Smi 范围内，之后又不属于 Smi 范围，这中间发生了什么？现有两个对象，它们的 x 属性值都是 Smi 表示形式。12345678const a = &#123; x: 1 &#125;;const b = &#123; x: 2 &#125;;// → objects have `x` as `Smi` field nowb.x = 0.2;// → `b.x` is now represented as a `Double`y = a.x;这两个对象都指向同一个 shape，x 属性特性 Representation 被标记为 Smi：当 b.x 变成 Double 形式，V8 会创建一个新的 shape，属性 x 的 Representation 被标记为 Double 且指向之前的空 shape。V8 也会为属性 x 分配一个 MutableHeapNumber 实体用来保存值 0.2。然后让对象 b 指向新创建的 shape 并且内部偏移量为 0 的位置指向刚分配的 MutableHeapNumber 实体。最后，我们把旧的 shape 标记为废弃的，并断开与过渡树（transition tree）的链接。这就完成了从空 shape 到新 shape 的过渡。我们不能同时完全删除旧 shape，因为对象 a 还在使用，而且短时间找到所有链接到旧 shape 的对象并更新它们，对 V8 来说是笔很大的开销。相反，V8 不急着处理：只有在改变对象 a 的时候才开始迁移到新的 shape。最终，标记为废弃的 shape 会慢慢淡出视野并被垃圾回收机制抹除。更棘手的问题是，如果对象上属性特性 Representation 发生变化的属性不是 shape 链上的最后一个，又会发生什么呢？从产生分支的 shape 开始，我们为属性 y 创建了一个新的过渡链且 y 被标记为 Double。我们在使用新的过渡链时，也就意味着旧的过渡链将被废弃。在最后一步，我们把实例 o 迁移到新的 shape 并用 MutableHeapNumber 保存 y 的值。就这样，新对象不再使用老的那一套，一旦旧的 shape 上的链接都被移除掉，旧 shape 也会从过渡树上消失。Extensibility and integrity-level transitionsObject.preventExtensions() 防止将新属性添加到对象中。如果你这么做了，它将会抛异常。（如果是在非严格模式下，它不会抛异常而是默认什么都不做。）12345const object = &#123; x: 1 &#125;;Object.preventExtensions(object);object.y = 2;// TypeError: Cannot add property y;// object is not extensibleObject.seal 与 Object.preventExtensions 相似，但是它会把所有的属性标记为不可配置，这就意味着你不能删除它们，或改变他们的可枚举性，可配置性，可写性。1234567const object = &#123; x: 1 &#125;;Object.seal(object);object.y = 2;// TypeError: Cannot add property y;// object is not extensibledelete object.x;// TypeError: Cannot delete property xObject.freeze 与 Object.seal 相似，但是它将所有属性标记为不可写以防止属性值被修改。123456789const object = &#123; x: 1 &#125;;Object.freeze(object);object.y = 2;// TypeError: Cannot add property y;// object is not extensibledelete object.x;// TypeError: Cannot delete property xobject.x = 3;// TypeError: Cannot assign to read-only property x让我们来思考一个具体的例子，有两个都只有属性 y 的对象，并阻止第二个对象有任何的扩展。1234const a = &#123; x: 1 &#125;;const b = &#123; x: 2 &#125;;Object.preventExtensions(b);就如我们所知的，从空的 shape 过渡到一个有属性 x （被标记为 Smi）的新 shape 上。当我们阻止 b 的扩展时，我们会过渡到标记为不可扩展的新 shape 上。这个新 shape 没有任何属性，仅仅作为一个标识。注意，我们不能就地更新有 x 的 shape，因为对象 a 依然是可扩展的。The React performance issue让我们用以上学到的知识来解析下 the recent React issue #14365。简单重现这个 bug：123const o = &#123; x: 1, y: 2 &#125;;Object.preventExtensions(o);o.y = 0.2;有一个拥有两个字段的对象，而且它们的属性特性 Representation 被标记为 Smi。我们阻止对象的进一步扩展，但最终我们还是强制改变第二字段的属性特性 Representation 的值（Double）。就如之前学到的，大致流程如下：每个属性的特性 Representation 都被标记为 Smi，并最终过渡到被标记为不可扩展的 shape 上。我们需要将 y 的属性特性 Representation 标记为 Double，这意味着我们需要从引入 y 属性之前的 shape 开始。在这个例子中，就是引入 x 属性的那个 shape。但是， V8 会很困惑，因为当前的 shape 是不可扩展的，而找到的 shape 却是可扩展的。V8 不知道怎么去处理这个过渡树。因此，V8 不再试图搞清楚这些关系，而是创建了一个独立的 shape，这个 shape 和先前的过渡树没有任何关联，而且也不被任何其它对象共享。可以把它当作孤立的 shape：你可以想象，如果有很多对象的话，这样会变得很糟糕，因为整个 shape 系统已经失去价值。在 React 的案例中，当开始分析数据时，FiberNode 上的一些字段需要记录时间戳。123456789class FiberNode &#123; constructor() &#123; this.actualStartTime = 0; Object.preventExtensions(this); &#125;&#125;const node1 = new FiberNode();const node2 = new FiberNode();这些字段（比如，actualStartTime）初始化值是 0 或 -1，因此属性特性 Representation 为 Smi。但是，之后由 performance.now() 生成的浮点型数值被保存在这些字段中，因此属性特性 Representation 被标记为 Double。除此之外，React 还阻止 FiberNode 实例扩展属性。刚开始的状况如下：如预期，两个实例共享着 shape 树。但是之后，一旦你存储了真实的时间戳，V8 就会无从下手：V8 先后给 node1，node2 分别分配了独立的 shape，且它们之间没有任何关联。真实中的 React 应用有着数万个这样的 FiberNode。你可以想象，这种情况将会严重影响到 V8 的性能。幸运的是，这个问题在 V8 v7.4 中解决了。研发人员找到了改变属性特性 Representation 的方法，V8 终于知道它该怎么做了：两个 FiberNode 实例指向不可扩展的 shape，shape 中的 actualStartTime 被标记为 Smi。当 node1.actualStartTime 被分配新的值时，将会生成一条新的过渡链，而且之前的过渡链会被标记为废弃的。可以注意到，现在的过渡链可以正确的过渡转移。当 node2.actualStartTime 也被重新分配时，所有的链接都指向了新的 shape，过渡树中废弃的部分将会被垃圾回收机制清除。React 团队将 FiberNode 所有关于时间的字段都改成了 Double 形式从而缓解这个问题。123456789101112class FiberNode &#123; constructor() &#123; // Force `Double` representation from the start. this.actualStartTime = Number.NaN; // Later, you can still initialize to the value you want: this.actualStartTime = 0; Object.preventExtensions(this); &#125;&#125;const node1 = new FiberNode();const node2 = new FiberNode();由 React 具体的 Bug 引出了 V8 特有的问题，通常来说，开发者不必对某个版本的 JavaScript 引擎做优化。不过，当时事情向不好的方向发展时，我们也不会束手无策。要知道 JavaScript 引擎在幕后做了很多事，尽可能的不要去混合类型。例如，给一个数字字段初始化为 null，这样做的话会使得一些优化化为泡影，而且可读性降低。123456789// Don’t do this!class Point &#123; x = null; y = null;&#125;const p = new Point();p.x = 0.1;p.y = 402;换句话说，写可读性代码，性能自然会紧跟其后！Take-aways本文覆盖了一下几点：JavaScript 区分了 primitives 和 objects，而且 typeof 不靠谱。即使是相同类型的值也会有不同的表达形式。JavaScript 引擎会为每个属性找到最优的表达形式。讨论了 V8 处理 shape 的废弃，迁移和可扩展。基于以上的知识，我们可以使用一些 JavaScript 编程技巧来提升性能：以相同的方式初始化对象类型，这样 shape 系统会更高效。为你的字段选择合理的值（「Representation」：Smi 或 非 Smi）。]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>JavaScript 引擎</tag>
        <tag>V8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【译】JavaScript engine fundamentals: optimizing prototypes]]></title>
    <url>%2F%E3%80%90%E8%AF%91%E3%80%91JavaScript-engine-fundamentals-optimizing-prototypes%2F</url>
    <content type="text"><![CDATA[前言本文是根据自己的理解翻译而来，如有疑惑可查看原文 JavaScript engine fundamentals: optimizing prototypes。本次暂定翻译三篇文章：JavaScript engine fundamentals: Shapes and Inline Caches(Published 14th June 2018)JavaScript engine fundamentals: optimizing prototypes(Published 16th August 2018)The story of a V8 performance cliff in React(Published 28 August 2019)Optimization tiers and execution trade-offs上一篇文章已经讨论了现代 JavaScript 引擎的工作流程：我们也指出了引擎间的相同之处和编译环节中的差异。为什么会这样？为什么一些引擎的编译器比其他引擎多？结论是基于更快地生成代码和生成更好的代码两者间的考量。解释器可以很快地生成字节码，但是字节码的效率不高。另一方面，优化编译器虽然会稍微花费些时间，却可以生成效率更高的机器码。下图是 V8 模型，V8 的解释器称为 Ignition，是所有引擎中最快的解释器（从原始字节码执行速度的角度）。V8 的优化编译器称为 TurboFan，它最终会生成高度优化的机器码。启动速度和执行速度是一些 JavaScript 引擎选择添加优化层的理由。比如，SpiderMonkey 就在解释器和 IonMonkey 编译器间添加了 Baseline 层。解释器可以快速生成字节码，但是字节码执行的速度比较慢。Baseline 会花些时间生成代码，但同样会提供性能更好的代码。最后，IonMonkey 会花更长的时间去生成机器码，并能够更高效地执行。来用一个具体的例子，看看不同引擎之间的处理差异。在这个循环里，一些代码重复执行。12345let result = 0;for (let i = 0; i &lt; 4242424242; ++i) &#123; result += i;&#125;console.log(result);在 Ignition 解释器中，V8 开始执行字节码。在某个时刻引擎测定代码是 hot 的，就会启动 TurboFan frontend, TurboFan frontend 是负责整合分析数据（profiling data）并构建代码的初级机器码表现形式。这些东西会被送到处在其他线程的 TurboFan 优化程序中作进一步优化。当优化程序进行时，V8 继续执行字节码。在某个时刻，优化程序生成可执行代码后，流程会接着执行下去。同样，SpiderMonkey 也是在解释器中开始执行字节码。但是它有 Baseline 层，hot 代码会被送到这里。一旦 Baseline 编译器生成了 Baseline 代码，流程会接着执行下去。Baseline 代码运行一段时间后，SpiderMonkey 最终会启动 IonMonkey frontend 和 优化程序（类似于 V8）。IonMonkey 在优化时，Baseline 也会保持着运行状态。当优化完成后，已优化的代码将取代 Baseline 代码被执行。Chakra 的架构和 SpiderMonkey 很相似。Chakra 尝试并行做很多事情同时又不会阻塞主线程。Chakra 会将字节码和编译器可能需要的分析数据复制出来，并发往编译器专用进程。当代码准备妥当后，引擎开始执行 SimpleJIT 代码。这种方式的好处在于复制所停留的时间远远小于编译器（ 编译器 frontend）所用的时间。缺点就是，这种启发式复制（copy heuristic）会使得某种优化所必须的信息丢失，因此这是在用代码质量换取时间。在 JavaScriptCore，所有的优化编译器和主线程并发运行；主线程只是触发了另一个线程的编译任务。然后编译器通过复杂的加锁从主线程获取分析数据（profiling data）。这种方式的优点是减少了因 JavaScript 优化引发的麻烦。缺点就是需要处理复杂的多线程问题和各种操作所带来的加锁成本。我们讨论了快速生成代码，也讨论了生成快速的代码。但是，还要有一点需要注意：内存的使用！为了解释这个，这里有个两数字相加的例子。12345function add(x, y) &#123; return x + y;&#125;add(1, 2);以下是 V8 的 Ignition 编译器生成的字节码：1234StackCheckLdar a1Add a0, [0]Return不要在意字节码的细节，重点是知道它只有 4 个指令！当代码编程 hot 时，TurboFan 会生成以下高度优化过的机器码：123456789101112131415161718192021222324252627leaq rcx,[rip+0x0]movq rcx,[rcx-0x37]testb [rcx+0xf],0x1jnz CompileLazyDeoptimizedCodepush rbpmovq rbp,rsppush rsipush rdicmpq rsp,[r13+0xe88]jna StackOverflowmovq rax,[rbp+0x18]test al,0x1jnz Deoptimizemovq rbx,[rbp+0x10]testb rbx,0x1jnz Deoptimizemovq rdx,rbxshrq rdx, 32movq rcx,raxshrq rcx, 32addl rdx,rcxjo Deoptimizeshlq rdx, 32movq rax,rdxmovq rsp,rbppop rbpret 0x18和字节码相比较，这里的代码会显得很多！通常来说，字节码会比机器码紧凑得多，尤其对比高度优化过的机器码。另一方面，字节码需要解释器来运行，而优化过的代码则可以被处理器直接执行。这是 JavaScript 引擎不「优化一切」的原因之一（仅优化 「hot function」）。正如我们早先看到的，生成优化过的机器码会用很长的时间，除此之外，我们刚才也知道了优化过的机器码会占用用更多的内存空间。Optimizing prototype property access先前的文章阐述了 JavaScript 引擎使用 Shapes 和 Inline Caches 优化对象属性的访问。再次说明，引擎将对象的 Shape 和对象的值分开存储。结合 Shapes 和 Inline Caches 可以加快代码中同一位置的属性重复性访问。Classes and prototype-based programming我们已经知道了如何快速访问 JavaScript 对象上的属性，我们再看看 JavaScript 最近新增的特性：类。下面是 JavaScript 中类的语法：12345678class Bar &#123; constructor(x) &#123; this.x = x; &#125; getX() &#123; return this.x; &#125;&#125;看似是个新概念，其实就是基于原型的语法糖。1234567function Bar(x) &#123; this.x = x;&#125;Bar.prototype.getX = function getX() &#123; return this.x;&#125;;在这里，我们给 Bar.prototype 这个对象添加属性 getX，这和其它普通对象添加属性没有区别，因为在 JavaScript中， 原型也是个对象！像 JavaScript 这种基于原型的编程语言，方法可以通过原型共享，而字段则存储在实例中。让我们看看通过 Bar 创建实例 foo 会发生什么？1const foo = new Bar(true);创建出来的实例（foo）拥有一个只包含属性 &#39;x&#39; 的 shape。foo 的原型指向 Bar.prototype。Bar.prototype 也有属于自己的 shape，它包含一个 getX 属性，这个属性的值是个返回 this.x 的函数（getX）。Bar.prototype 的原型是 Object.prototype。Object.prototype 是原型链的根源，因此它的原型是 null。如果你用同一个类又创建了一个实例，那么这两个实例将共享 shape，两个实例也会指向同一个 Bar.prototype。Prototype property accessok，我们已经知道了定义一个类并用类创建实例的过程。那么，如果我们在实例上调用一个方法，又会发生什么呢？12345678class Bar &#123; constructor(x) &#123; this.x = x; &#125; getX() &#123; return this.x; &#125;&#125;const foo = new Bar(true);const x = foo.getX();// ^^^^^^^^^^你可以认为方法的调用分为两个步骤：123456const x = foo.getX();// is actually two steps:const $getX = foo.getX;const x = $getX.call(foo);步骤 1：加载方法，这个方法只不过是原型上的属性（而它恰好是个函数）。步骤 2：用实例去调用这个方法（重新绑定 this）。先看步骤 1：开始时，引擎从实例 foo 上查找并发现 foo 的 shape 上没有 getX 属性，于是它不得不沿着原型链向上查找。到达 Bar.prototype 后，开始查找它的 shape 并找到了 getX 属性。然后根据 getX 的属性信息（Offset：0）在 Bar.prototype 上找到了 getX 函数。JavaScript 的灵活性使得原型链可能会突变，例如：1234567const foo = new Bar(true);foo.getX();// → trueObject.setPrototypeOf(foo, null);foo.getX();// → Uncaught TypeError: foo.getX is not a function这个例子中，foo.getX() 被调用了两次，但是每次都会有不同的含义，不同的结果。所以说，尽管原型在 JavaScript 中只是个对象，但是提升原型属性的访问速度依然比常规对象更具有挑战性。通常情况下，原型属性的加载是个非常频繁的操作：每次方法调用都会去加载属性！12345678class Bar &#123; constructor(x) &#123; this.x = x; &#125; getX() &#123; return this.x; &#125;&#125;const foo = new Bar(true);const x = foo.getX();// ^^^^^^^^^^之前，我们讨论了使用 Shapes 和 ICs 优化常规对象的属性访问。那么，我们能否使用相同的策略去优化原型属性的重复性访问呢？下面，我们看看属性是如何加载的。在这个案例中，为了提高重复加载的速度，我们需要知道三件事：foo 的 shape 不包含 getX 且没有改变过。这意味着 foo 没有添加、删除属性，或改变属性特性。foo 的原型依然是 Bar.prototype。这意味着，foo 的原型没有通过 Object.setPrototypeOf() 或 __proto__ 的方式改变过。Bar.prototype 的 shape 包含 getX 且没有改变过。这意味着 Bar.prototype 没有添加、删除属性，或改变属性特性。一般情况下，这意味着我们需要检查 1 遍实例本身，还有因每增加一个原型就就要增加的 2 遍检查直到找到我们想要的属性。1+2N（N 表示原型链上直到找到存在属性的原型的原型数量） 遍的检查看上去还不是特别糟糕，因为这时的原型链还比较短 —— 但是引擎会经常处理有着很长原型链的对象，就比如常见的 DOM 类。1234const anchor = document.createElement('a');// → HTMLAnchorElementconst title = anchor.getAttribute('title');现有个 HTMLAnchorElement 并调用 getAttribute() 方法。这简单的 anchor 元素涉及到 6 个原型！getAttribute() 不是 HTMLAnchorElement 原型上的方法，而是原型链上靠近顶部的原型上。getAttribute() 是在 Element.prototype 上发现的。这意味着我们每次调用 anchor.getAttribute() 时，都需要做以下这些事：检测到 getAttribute 不存在于 anchor 对象本身;检测到 anchor 的原型是 HTMLAnchorElement.prototype;确认没有 getAttribute 属性；检测到下一个原型是 HTMLElement.prototype;确认没有 getAttribute 属性；继续检测下一个原型 Element.prototype;找到 getAttribute。一共需要 7 次检测！而这种情况很常见，于是引擎想方设法去减少属性（原型上）加载时的检查次数。回到更早的例子，当我们从 foo 访问 getX 时，共做了 3 次检查：1234567class Bar &#123; constructor(x) &#123; this.x = x; &#125; getX() &#123; return this.x; &#125;&#125;const foo = new Bar(true);const $getX = foo.getX;在查找属性的过程中，每个牵涉到的原型都需要做缺失检查（确认属性是否存在）。如果我们能够在属性确认的步骤里同时检测原型链，那将会减少总的检查次数。引擎也正是这么做的：每个 shape 都指向了原型，这意味着 foo 的原型改变时，引擎会自动过渡到新的 shape。现在我们只需要检查对象的 shape 就可以同时检测属性是否存在以及原型链的导向。鉴于此，由于检查的次数从 1+2N 降低到 1+N，所以原型上属性的访问速度也变快了。由于在原型链上查找属性的时间复杂度是线性的，所以依然还是很耗时的。引擎使用了不同的方法让检查的次数趋于常量，尤其是同一属性的连续加载（访问）。Validity cells为此，V8 特别处理了原型的 shapes。每个原型都有一个独一无二的 shape，这个 shape 不会被其它的对象共享（特别是其它的原型对象），每一个原型的 shape 都有与之关联的 ValidityCell。如果与之关联的原型被修改，或该原型的上游（原型的原型，原型的原型的原型……）被修改，ValidityCell 都会被标记为无效。让我们看看这是到底怎么一回事？为了加快原型上后续的属性加载，V8 使用 ICs 保存着 4 个字段：代码第一次执行时，ICs 开始工作了，它要缓存属性在原型上的偏移量 「Offset」，属性所在的原型 「Prototype」（本例中的 Bar.prototype），实例的 shape 「Shape」（本例中 foo 的 shape）,还有就是与原型的 shape 相关联的 ValidityCell 「ValidityCell」，这个原型是实例 shape 直接链接的那个原型（本例中的 Bar.prototype）。若在下一次 ICs 命中时，引擎会检查 shape （实例的 shape）和 ValidityCell。如果还有效，引擎会直接从 ICs 中提取信息，根据 Prototype 和 Offset 字段获取属性信息，这样就跳过了之前繁琐的查找步骤。当原型发生改变时，一个新的 shape 将会生成，同时先前的 ValidityCell 将会失效。因此在下次执行时，ICs 将不会起作用，性能自然不会好。回过头来再看看之前的 DOM，例如，Object.prototype 发生变化后，影响的将不仅仅是自身，还包括链的下游 EventTarget.prototype、Node.prototype、Element.prototype，直到 HTMLAnchorElement.prototype。事实上，当你在代码中修改了 Object.prototype，就意味着将性能弃之不顾。所以，不要那样做！让我们看一个具体的例子，有一个 Bar 类，它有 loadX 方法。我们将使用类的实例调用 loadX 若干次。1234567891011121314class Bar &#123; /* … */ &#125;function loadX(bar) &#123; return bar.getX(); // IC for 'getX' on `Bar` instances.&#125;loadX(new Bar(true));loadX(new Bar(false));// IC in `loadX` now links the `ValidityCell` for// `Bar.prototype`.Object.prototype.newMethod = y =&gt; y;// The `ValidityCell` in the `loadX` IC is invalid// now, because `Object.prototype` changed.此时，ICs 中会记录调用 loadX 后的相关信息。然后我们修改了 Object.prototype —— 所有原型的根源 —— ValidityCell 会被标记为无效的，ICs 不会在下次执行时命中，性能也会变得糟糕。改变 Object.prototype 是一个不好的行为，它使得原型链下游所有的 ICs 失去作用。这有另一个不推荐的行为。1234567Object.prototype.foo = function() &#123; /* … */ &#125;;// Run critical code:someObject.foo();// End of critical code.delete Object.prototype.foo;我们拓展了 Object.prototype，它使得原型链下游的所有 ICs 失效。然后调用原型上的新方法，引擎便从头开始为原型属性的访问构建新的 ICs。最后，我们删除了之前添加的方法。清除，听着挺不错的，其实在这种情况下，只会更糟。删除 Object.prototype 上的属性就意味着修改 Object.prototype，所有的 ISc 将再一次失效，引擎也将会再一次地重头开始构建 ICs。Take-aways我们知道了 JavaScript 引擎是如何存储对象和类的，也知道了 Shapes、Inline Caches 和 ValidityCells 是如何帮助优化原型操作的。基于这些知识点，我们可以使用一些 JavaScript 编程技巧来提升性能：不要乱动原型（如果你真的，真的需要这么干，那么，至少要在代码运行前）。]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>JavaScript 引擎</tag>
        <tag>V8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【译】JavaScript engine fundamentals: Shapes and Inline Caches]]></title>
    <url>%2F%E3%80%90%E8%AF%91%E3%80%91JavaScript-engine-fundamentals-Shapes-and-Inline-Caches%2F</url>
    <content type="text"><![CDATA[JavaScript 引擎原理：外形与内联缓存前言本文是根据自己的理解翻译而来，如有疑惑可查看原文 JavaScript engine fundamentals: Shapes and Inline Caches。本次暂定翻译三篇文章：JavaScript engine fundamentals: Shapes and Inline Caches(Published 14th June 2018)JavaScript engine fundamentals: optimizing prototypes(Published 16th August 2018)The story of a V8 performance cliff in React(Published 28 August 2019)JavaScript 引擎工作流一切从你写的 JavaScript 代码开始。JavaScript 引擎会解析源码并将其转换成抽象语法树（AST）。基于 AST，解释器（interpreter）会进一步地生成字节码。为了能够运行得更快，字节码可能会和分析数据（profiling data）一同发给优化编译器（the optimizing compiler）。优化编译器会根据这些分析数据作出某些假设以此生成高度优化的机器码。如果某个时刻，某种假设被证明是错误的，优化编译器将去优化并回滚到解释器部分。JavaScript 引擎中的解释器/编译器流程现在来关注下 JavaScript 代码被解释和优化的地方，并重温下主流 JavaScript 引擎之间的不同之处。一般来说，在运行 JavaScript 代码过程中，会有解释器和优化编译器的参与。解释器会快速地生成尚未优化的字节码，而优化编译器会耗费一些时间用来生成高度优化的机器码。上面的流程和 V8 在浏览器和 Node 环境下的工作流程及其相似：V8 引擎的解释器被称作 Ignition，主要负责生成和执行字节码。当字节码运行时，解释器会收集分析数据，这些数据之后可能会被用来提升执行速度。如果一个函数经常被调用，即 hot，那么，经过解释器转换来的字节码和收集到的分析数据会传给 TurboFan（V8 的优化编译器），进一步被加工成高度优化的机器码。SpiderMonkey，Mozilla 的 JavaScript 引擎，拥有两个优化编译器，Baseline 和 IonMonkey。解释器将转换后的代码传给 Baseline 编译器，Baseline 编译器会将其加工成部分优化的代码。再加上收集到的分析数据，IonMonkey 编译器可以生成高度优化的代码。如果基于假设的优化不成立，IonMonkey 会将代码会滚到 Baseline 部分。Chakra，Microsoft 的 JavaScript 引擎，也有着类似的两个优化编译器，SimpleJIT 和 FullJIT。解释器将转换后的代码传给 SimpleJIT（JIT，Just-In-Time），SimpleJIT 会将其加工成部分优化的代码。再加上收集到的分析数据，FullJIT 可以生成高度优化的代码。JavaScriptCore（JSC），Apple 的 JavaScript 引擎，更是发挥到了极致，使用了三个不同的优化编译器，Baseline、DFG 和 FTL。低级解释器（LLInt）将转换后的代码传给 Baseline 编译器，经其加工后传给 DFG（Data Flow Graph） 编译器，进一步加工后，传给 FTL（Faster Than Light） 编译器。为什么有些引擎的优化编译器会比其他引擎的多？这完全是取舍问题。解释器可以很快地生成字节码，但是字节码的效率不高。优化编译器虽然会花更长的时间，但是生成的机器码更为高效。是更快地去执行代码，还是花些时间去执行更优的代码，这都是需要考虑的问题。有些引擎添加多种不同特点（省时或高效）的优化编译器，虽然这会变得更加复杂，但却可以对以上的取舍有着更细粒度地控制。还有一点需要考虑的是，内存的使用。以上只是强调了不同 JavaScript 引擎的解析器/编译器的区别。抛开这些不谈，从更高的层面来看，所有的 JavaScript 引擎有着相同的架构：一个解析器和一些解释器/编译器。JavaScript 对象模型再来看看，在某些具体实现上，JavaScript 引擎之间还有哪些相同之处。例如，JavaScript 引擎是如何实现 JavaScript 对象模型的？它们又是如何提升对象属性访问速度的？事实证明，所有主流的引擎在这点实现上都非常得相似。ECMAScript 规范把所有的对象定义为词典，将字符串键映射到属性特性（property attributes）。除了 [[Value]]， 规范还定义了一下属性：[[Writable]] 定义是否可写。[[Enumerable]] 定义是否可枚举。[[Configurable]] 定义是否可配置。[[双中括号]] 是用来描述不能直接暴露给 JavaScript 的属性。不过你依然可以通过 Object.getOwnPropertyDescriptor 获取某个对象上的以上属性。123const object = &#123; foo: 42 &#125;;Object.getOwnPropertyDescriptor(object, 'foo');// → &#123; value: 42, writable: true, enumerable: true, configurable: true &#125;ok，这是 JavaScript 如何定义对象的。那么，数组呢？你可以认为数组是一个特殊的对象。一个不同点是，数组会对数组索引特殊处理。数组索引是 JavaScript 规范中的一个特殊术语。数组索引是某个范围内的任何有效索引，即在 0 ～ 2³²−2 范围内的任何一个整数。另一个不同点是，数组还有一个 length 属性。1234const array = ['a', 'b'];array.length; // → 2array[2] = 'c';array.length; // → 3在这个例子里，数组创建好后，&#39;length&#39; 值为 2。当我们给数组索引为 2 的位置赋值时，数组的 &#39;length&#39; 会自动更新。在 JavaScript 中，数组的定义和对象很相似。例如，数组的所有的键（包括数组索引）都是字符串表示。数组的第一个元素存在键值为 &#39;0&#39; 的地方。另一个属性是 &#39;length&#39; 属性，该属性不可枚举不可配置。一旦数组添加一个元素，JavaScript 会自动更新 &#39;length&#39;属性上的 [[Value]] 值。一般来说，数组的行为也是和对象非常相似。优化属性的访问既然我们知道在 JavaScript 中如何定义对象的。接下来让我们深入了解 JavaScript 引擎是如何高效地处理对象的。属性访问是最常见的一个操作，对 JavaScript 引擎来说，提升访问速度事件很有意义的事。12345678const object = &#123; foo: 'bar', baz: 'qux',&#125;;// Here, we’re accessing the property `foo` on `object`:doSomething(object.foo);// ^^^^^^^^^^外形（Shapes）在 JavaScript 程序中，有相同键的对象很多，它们有相同的 Shape。123const object1 = &#123; x: 1, y: 2 &#125;;const object2 = &#123; x: 3, y: 4 &#125;;// `object1` and `object2` have the same shape.有着相同 Shape 的对象，自然会访问相同的属性。12345678910function logX(object) &#123; console.log(object.x); // ^^^^^^^^&#125;const object1 = &#123; x: 1, y: 2 &#125;;const object2 = &#123; x: 3, y: 4 &#125;;logX(object1);logX(object2);考虑到这一点，JavaScript 引擎可以基于 对象的 Shape 来优化对象属性的访问速度。我们假设一个对象有 x、y 属性，且用着字典这种数据结构：它包含字符串表示的键，并且键指向各自的属性特性（property attributes）。如果要访问一个属性，例如 object.y，JavaScript 引擎会在 JSObject 中查找 y，然后加载对应的属性特性，最后返回 [[Value]]。但是在内存中，这些属性特性要存储在哪儿呢？我们应该把它们当作 JSObject 的一部分存储吗？假设之后会有更多的拥有相同 Shape 的对象，如果我们在 JSObject 上存储一个包含属性名称和属性特性的完整字典的话，那显然会是一种浪费。因为拥有相同 Shape 的对象，它们的属性名称会重复。这回造成大量重复和不必要的内存使用。作为优化，引擎将对象的 Shape 单独地存储。Shape 包含所有的属性名称和属性特性，除了 [[Value]]。不过，Shape 包含了 [[Value]] 在 JSObject 上的偏移量，因此 JavaScript 引擎知道去哪里找到相应的值。 每个拥有相同 Shape 的 JSObject 都指向同一个 Shape 实例。现在，每个 JSObject 只需存储对象的值即可。当我们有很多个对象时，好处也是显而易见的。不管有多少个对象，只要有相同的 Shape，Shape 和属性信息只需要存储一次。所有的 JavaScript 引擎都用 Shapes 来优化，但叫法却不同：学术论文称之为 Hidden Classes（容易和 JavaScript 中的 Class 混淆）V8 称之为 Maps（容易和 JavaScript 中的 Map 混淆）Chakra 称之为 Types（容易和 JavaScript 中的动态类型与 typeof 混淆）JavaScriptCore 称之为 StructuresSpiderMonkey 称之为 Shapes在这篇文章中，我们继续称之为 Shapes。过渡链与树（Transition chains and trees）如果一个对象有了一个确定的 Shape,然后又添加了一个属性，这会发生什么呢？JavaScript 引擎如何找到改变后的新 Shape？123const object = &#123;&#125;;object.x = 5;object.y = 6;在 JavaScript 引擎中，这种 Shapes 结构称之为过渡链。如下：对象开始时没有任何属性，因此它会指向一个空的 Shape。下一条语句对象添加了一个属性 &#39;x&#39;，属性值为 5，因此对象指向包含属性 &#39;x&#39; 的 Shape，且在 JSObject 中偏移量为 0 的位置添加 5。下一条语句对象添加了一个属性 &#39;y&#39;，属性值为 5，因此对象指向包含属性 &#39;x&#39; 和 &#39;y&#39; 的 Shape，且在 JSObject 中偏移量为 1 的位置添加 6。注意： 属性的添加顺序会影响 Shape。例如，{x: 4, y: 5} 和 {y: 5, x: 4} 有不同的 Shape。我们没有必要让每个 Shape 都存储完整的属性表。相反，每个 Shape 只需要知道新引入的属性即可。例如，在这种情况下，我们没有必要在最后一个 Shape 中存储属性 &#39;x&#39; 的信息，因为它可以在链的上游中被查找到。要达此目的，每个 Shape 都会和先前的 Shape 链接。如果你在 JavaScript 代码中写了 o.x，JavaScript 引擎会沿着过渡链查找属性 &#39;x&#39;，直到发现引入 &#39;x&#39; 的 Shape。但是，如果没法创建过渡链呢？例如，给两个空对象添加不同的属性。1234const object1 = &#123;&#125;;object1.x = 5;const object2 = &#123;&#125;;object2.y = 6;这种情况下，不得不进行分支处理，用过渡树（transition tree）取代过渡链。在这里，我们创建了一个空对象 a并给它添加了属性 &#39;x&#39;。最终得到以一个包含单个值的 JSObject和两种 Shape（空的 Shape 和仅有属性 &#39;x&#39; 的 Shape）。第二个例子也是以一个空对象 b 开始，但是添加的是属性 &#39;y&#39;。最终得到两条 Shape 链和三个 Shape。这是否意味着总是以空 Shape 开头呢？不一定。引擎对已经存在属性的对象字面两做了优化。来看两个例子，一个是从空的对象开始添加属性 &#39;x&#39;，一个是已经存在属性 &#39;x&#39; 的对象字面量。123const object1 = &#123;&#125;;object1.x = 5;const object2 = &#123; x: 6 &#125;;第一个例子中，我们从空的 Shape 过渡到包含属性 &#39;x&#39; 的 Shape，就如之前所看到的那样。对于 object2，它直接生成包含属性 &#39;x&#39; 的对象而不是从空对象开始过渡。这个包含属性 &#39;x&#39; 的对象，以包含 &#39;x&#39; 的 Shape 开头，省去了空 Shape 这个步骤。至少 V8 和 SpiderMonkey 是这么做的。这种优化缩短了过渡链，使得创建对象更加高效。Benedikt 的文章 surprising polymorphism in React applications 讨论了这些微妙之处是如何影响到实际性能的。这有一个拥有属性 &#39;x&#39;、‘y’、‘z’` 的三维点对象的例子。1234const point = &#123;&#125;;point.x = 4;point.y = 5;point.z = 6;就如之前所学到的，在内存上，这回创建有三个 Shape 的对象（空 Shape 不计入）。访问对象的属性 &#39;x&#39;，例如，如果你在程序中写下了 point.x，JavaScript 引擎会顺着链表：它会从底部的 Shape 开始，一直向上查找，直到发现引入 &#39;x&#39; 的那个 Shape。如果这种操作很频繁，就会显得很慢，尤其是一个对象有很多属性时。检索到需要的属性所花时间是 O（n），即线性的。为了提高检索速度，JavaScript 引擎加入了 ShapeTable 数据结构。ShapeTable 是个字典，它将属性和引入该属性的 Shape 关联起来。且慢，我们又回到了字典查找……这不就是我们在引入 Shapes 之前的方式吗？为什么我们非要整出个 Shapes？原因是 Shapes 可以实现另一种称之为内联缓存的优化。内联缓存（Inline Caches (ICs)）ICs 是 JavaScript 快速运行的关键因素。JavaScript 引擎可以利用 ICs 缓存对象的属性信息，从而减少属性查找的开销。有个函数 getX ，接受一个对象并加载该对象上的属性 x：123function getX(o) &#123; return o.x;&#125;如果我们在 JSC（JavaScriptCore） 中运行这个函数，它会生成以下的字节码：第一条指令（get_by_id）是从参数 arg1 中加载属性 x，并将其值存储到 loc0 中。第二条指令是返回 loc0 中存储的值。JSC 还在 get_by_id 指令中嵌入了内联缓存，它是由两个未初始化的插槽组成。现在给函数 getX 传入对象 { x: &#39;a&#39; }。如我们所知，这个对象有一个包含属性 x 的 Shape，这个 Shape 存储了属性 x 的偏移量和特性。当我们第一次执行函数时，get_by_id 指令会查找属性 x 并检索到值被存储在偏移量为 0 位置。嵌在 get_by_id 指令中的内联缓存会记住 Shape 和属性的偏移量。在下次函数执行时，内联缓存会对比 Shape，如果与之前的 Shape 相同，就只需要通过缓存的偏移量加载值。具体来说，如果 JavaScript 引擎发现对象的 Shape 和之前记录的 Shape 一样，那么它就再也不需要去查找属性信息了 —— 属性信息的查找就可以完全跳过。相比每次都去查找属性信息，这样的操作会显著地提升速度。高效存储数组（Storing arrays efficiently）对于数组，使用数组索引作为数组的属性是很常见的，属性对应的值称之为数组元素。为每个数组的每个数组元素存储属性特性是一种铺张浪费的行为。在 JavaScript 引擎中，数组的索引属性默认是可读、可枚举和可配置的，且数组元素是与命名属性分开存储的。思考以下这个数组：123const array = [ '#jsconfeu',];引擎存储了一个数组长度为 1 的数组，它指向一个包含偏移量和 length 特性的 Shape。这个之前见过的很相似…… 但是数组元素的值存在哪呢？每个数组都有一个独立的元素备份存储（elements backing store），包含着所有索引属性对应的值。JavaScript 引擎不必为数组元素存储属性特性，因为他们通常是可写、可枚举和可配置的，且数组索引可以替代偏移量的作用。如果是不寻常的情况会怎样呢？比如，改变数组元素的属性特性（property attributes）。1234567891011// Please don’t ever do this!const array = Object.defineProperty( [], '0', &#123; value: 'Oh noes!!1', writable: false, enumerable: false, configurable: false, &#125;);上面的这个代码片段是给对象属性 &#39;0&#39; 的特性设置成非默认值。像这种情况，JavaScript 引擎会将整个元素备份存储表示为一个字典，把数组索引和属性特性关联起来。即使数组中只有一个元素的属性特性是非默认值，元素备份存储也会进入缓慢低效的模式（从 Elements 模式 到 Dictionary Elements 模式）。避免用 Object.defineProperty 改变数组索引！看点（Take-aways）基于以上的知识，我们可以使用一些 JavaScript 编程技巧来提升性能：始终以相同的方式初始化对象，这样就可以复用 Shape。不要没事瞎折腾数组元素的属性特性，它们本可以高效地工作。]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>JavaScript 引擎</tag>
        <tag>V8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端架构碎碎念]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84%E7%A2%8E%E7%A2%8E%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[前端架构碎碎念前言最近看了一些关于前端架构相关的书籍和博客，觉得有点自我膨胀了，竟然想对着前端架构这一说法指指点点。从跨入这个行业开始，就觉得架构师就是位于技术金字塔的顶端的那拨人，是引导行业或团队技术走向的那拨人。然而从行业上对前端架构的定义和必备的技能来看，觉得前端架构就是一个伪概念，又或是拔高自己身份的幌子。类比于建房子，考虑到人文因素，会有中西风格；考虑到地理位置，会有南北之分；考虑到简易方便，还会有组合式集装箱房屋。设计师会运用自己专业知识并集合各种因素，设计出符合当前环境的房屋。而架构师也是如此，他们需要从业务、技术等角度构造出合理的组织架构。前端技术不断发展演进，从模块化的摸索，到 MV* 的实践，再到当今组件化的盛行。这些技术人不断折腾，不断改进前端架构，使之更符合这个时代。在市场的筛选下，最终也留下了最适合当前的前端技术方案。不过，大部分前端架构师并不具备这种能力，充其量就是经验丰富的包工头，某种前端技术方案的践行者。设计师怎么练成的，我们不知道。但是类比包工头，我们还是知道前端 Leader 应该做什么。开工前的前期准备这里的前期准备，指的是从零启动一个项目，我们需要做的准备工作。而最能体现整个项目的技术含量的活估计有大半在这里了。作为一个包工头，不是说我能把砖砌得有多好，而是足够了解现有的资源和工作流，并搭建好基础设施，为日后项目高效推进起个好头。在很早以前，数据和视图耦合，那时候没有前端的什么事，最多作为页面仔为后端提供模板，或者说画几个展示用的静态页面。之后 ajax 的兴起，让数据和视图的关系开始松绑，前端在数据的赋能下，迎来了一次大发展。人要与数据交互，必然要通过某个媒介，而前端在获取部分数据的权限后，又反过来促进了人与数据的互动关系。即使后面的 Node，我也认为是前端为争取操作数据权限而做的努力。毕竟，这个年代数据才是王道。视图怎么获取数据？视图怎么展示数据？视图怎么更好得获取数据？视图怎么更好得展示数据？（…没想那么多…）架构设计从早期的服务端直出到现在的服务端渲染，视图的渲染兜兜转转貌似又回到的起点。但此非彼，不可同日而语。ajax 被 Google 使用后，随之而来的是前后端的分离。前端应用也是跟随时代而呈现不同的架构设计，比如多页面应用、单页面应用、同构渲染、微前端等。它们的出现是为了解决某些问题而给出的技术方案，所以说即使过时，却依然有其价值。多页面应用，相对来说，比较简单。简单的多页面应用，比如静态页面，这里可能压根没 JS 的事。复杂点的多页面应用，可能要引入模板引擎，路由等。要是觉得原生操作 DOM 不方便，可以使用 jQuery。多页面应该在项目启动的时候，会加载需要的资源，由于浏览器缓存策略，第二次加载相同的资源时，可能就不需要重复请求了。在结合一点 MV* 模式，快和单页面应用没什么区别了。只是现在流行的单页面不需要直接操作 DOM ，而是交给框架底层处理了。以上的应用说来说去可能都是同一个应用，在某些场景，就需要聚合多个前端应用，有路由分发的方案，有 iframe 作为容器的方案等。前端规范「书同文，车同轨」既然是包工头，自然不大可能是一个光杆司令。制定规范，不仅可以使成员代码风格趋于统一，同时也可以使新手养成良好的编码习惯。对于前端来说，HTML、CSS、JS 分别代表了结构层、表现层和行为层。在代码层次上，它们都有自己的一套标准，可以结合各自 lint工具 + Prettier 轻松规范代码。从组件规范角度，还包括 UI 组件规范、模块化规范、项目组件化设计方案等。编辑器最好也能够统一下，如果能够摸索出能够提高效率的一系列使用方法，同步给全组成员就更好了。自动化构建都 9102 年，自动化构建已成为现代前端工程不可或缺的一个环节。自动化构建可以做很多事，比如文件编译，资源合并，压缩优化等。构建工具很多，但所做的事基本上是差不多的，读取入口配置文件 ➡ 生成模块依赖图 ➡ 加载模块 ➡ 模块文件编译处理 ➡️ 模块文件合并 ➡️ 文件资源优化 ➡ 输出最终资源。不论是生产环境还是开发环境，都需要构建工具的参与。生产环境侧重于性能，比如文件压缩优化，去除无用代码注释等。测试环境侧重于开发体验，比如模块热替换，生成 sourcemap 等。像之前的代码规范，也可以借助构建工具自动化格式化代码，或提示错误。项目代码示例项目在正是启动之前，需要验证程序是否按照自己的预期去执行。验证可行后，并按照自己定义的一系列规范编写示例代码，这样有助于其他成员了解该项目的规范。同时，对内组织技术培训，介绍系统的架构和注意事项。其实，技术验证的过程不应该放在整个开发流程中。工作之余，我们可以多接触新的技术和尝试新的架构设计。在未知的领域，我们无法准确评估时间，临时磨枪可能会导致整个项目的延期。开工技术是为业务服务的，项目启动了，意味着开始偿还业务债了。而前端 Leader 职责也开始发生变化，不仅仅从事技术活，还要参与到团队管理、项目管理等非技术活。项目进入正轨后，人人都成为了螺丝工，技术上的难题基本上很少再会遇到。但是这并不代表整个开发过程会变得一帆风顺。沟通协调「凡事有交代，件件有着落，事事有回音」不管是普通成员，还是团队 Leader，都应该具备这样的做事风格，对自己和别人都有个交代。前端在整个研发队伍中，是一个比较尴尬的存在。尤其在比较重视业务的团队里，好事没捞到，麻烦事却不断找上门。比如页面抛异常，测试伙伴第一个就找前端。产品伙伴不靠谱，频繁找前端。遇到不靠谱的后端小伙伴，联调测试时也会跑来质疑前端。最后可能领导跑来找你谈话，说你们前端团队怎么老是出问题。讲真，这话没法接。感觉前端就是一个接锅侠，时间长了，对团队士气有很大的影响，这也是前端 Leader 需要解决的问题。对于产品，需求评审严格把关，对于不合理或不紧急的需求，延迟或降低其优先级。对于测试伙伴，对其进行技术培训，了解开发者工具的简单使用，和常见异常报错分析科普。对于后端，制定相关约束。以上规范要形成文档保存，方便后来者。当然诸如此类的问题会有很多，对于问题要敏感并及时发现，分析导致问题的根源，最后对症下药逐步解决问题。事情说得很简单，但事实上，人们习惯于存在问题的现状而不自知或发现问题却习惯于有问题的现状。提升团队能力众人拾柴火焰高，只有大伙儿力往一处使，才能产生 1 + 1 &gt; 2 的效果。可是编码并不是力气活，成员的参差不齐，很大的程度上会拖团队的后退。比如，一个新手的代码提交不规范，很可能导致某些人的哀嚎。代码审查，是一个提高自己编码能力的好机会。之前的 Lint 规则可以很好地校正代码风格，而在代码审查中，就可以发现逻辑上的问题或知道可以让代码更出彩的方法。代码重构算是一种提升编程能力的方式，不过有很多人对代码重构有着很大的误解，也不见得项目中对重构的重视。重构可以本着小步快走的原则，增加程序的可读性和可维护性。何时去重构？需要重构的标准的是什么？如果程序冗长啰嗦看不懂，那就重构它。如果一段程序过分依赖于注释，那就重构它。如果你想添加新功能，却无从下手，那就重构它。只要是可读性差，可维护性差，你都有理由去重构它。代码审查还有一个好处就是，可以帮助我们熟悉业务。如果项目业务很复杂，至少要保证有两个人对同一模块有足够的了解。新人培训和技术分享，新人刚接入项目时，有必要对其进行基础的技术培训，如业务培训、技术栈相关知识培训、调试能力培训等，这些都要有相关的文档。这些看着无关紧要的培训，对于新手来说，往往是一大助力。技术分享，并不指望一次简单的分享就让所有的成员学会一项技能，不过这对团队的技术视野和团队技术氛围会有很大帮助。对于技术分享的人，有不同的说法，有人主张新人主持分享，这样可以加快新人融入团队，老人也可以一旁补充说明。而有些人，则认为让最擅长的人去做擅长的事。不知道孰好孰坏，不予置评。我认为团队能力还应该包括存续能力，也就是即便成员流动快，新到位的成员也能很快接入项目。这就需要各种文档记录，新人培训文档，技术架构文档，业务文档，技术分享文档，开发规范文档，工作交接文档等。前后端联调后端由本地开发环境部署到测试环境，按正常的节奏来，前后端联调会很顺利。然而，实际开发中，联调的占比会很大。主要的原因有，前后端沟通效率低，有问题相互质疑。后端自测力度不够，考虑不周全。接口协议变动频繁。接口文档不详实。…最简单粗暴的方法就是引入接口管理平台，引入绩效考核制度。持续化集成 持续化交付 持续化部署这一块就不是前端自己能够决定的事情了，有条件的话可以自己搭建代码托管平台，使用 gitlab ，现在人家提供一条龙服务，可以尝试一波。结语和代码打交道不可怕，和人打交道也不可怕，可怕的是这个前端 Leader 有想法。]]></content>
      <categories>
        <category>开发三两事</category>
      </categories>
      <tags>
        <tag>前端架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读《重构》]]></title>
    <url>%2F%E3%80%8A%E9%87%8D%E6%9E%84%E3%80%8B%E8%AF%BB%E5%90%8E%E6%84%9F%2F</url>
    <content type="text"><![CDATA[重构技术就是以微小的步伐修改程序。如果你犯下错误，很容易便可发现它。傻瓜都能写出计算机可以理解的代码。唯有能写出人类容易理解的代码的，才是优秀的程序员。如果重构引入了性能损耗，先完成重构，再做性能优化。重构早期的主要动力是尝试理解代码如何工作。好代码的检验标准就是人们是否能轻而易举地修改它。重构的唯一目的就是让我们开发很快，用更少的工作量创造更大的价值。前言《重构》这本书，虽然看着很厚，但是读起来却又感觉很薄。用上周末的时间，读完这本书还是有可能的。之前也有做过重构的工作，不过那都是经验之谈，如果被问起为什么这么重构，估计我也不能很好得回答这个问题。所以，在这种情况下通读《重构》，还是挺有收获的，起码从经验上升到了理论。重构原则要了解重构，还是从 What，Why，How 三方面入手。重构是什么？为什么要重构？怎么去重构？重构，使用一系列重构手法，在不改变可观察行为的前提下，对软件内部结构的一种调整。目的是提高其可理解性，降低其修改成本。什么时候重构？如果你看不懂一段代码是在做什么，那么重构它。如果一段代码的目的依赖于注释，那么重构它。如果，一段代码想要添加新的功能，却无处下手，那么重构它。重构就是为了更容易理解，更容易修改。如果不能满足以上条件，这时候就有必要考虑重构了。程序也并非从头到尾翻新一遍才叫重构，步子不能迈大，更希望的是小步快走的节奏。随时随地重构，用小步积累起来慢慢改善系统的设计。当然在实际的开发中，还会遇到各种挑战，比如，新功能开发，测试，性能等问题。而这些，在《重构》的前两章都有介绍。知道了什么和为什么，那么，怎么去重构呢？在重构前，我们还要知道如何辨别需要重构的代码。重构《重构》在第三章也分门别类列举了需要重构的代码所具有的特点。神秘命名，命名要清晰表达功能和用法。重复代码，提炼重复代码，避免重复的代码结构。过长函数，函数越长就越难理解，分解函数，使用小函数。过长参数列表和全局数据。可变数据，对数据的修改经常会导致难以发现和难以跟踪的 bug。发散式变化，模块因不同原因在不同方向上发生了变化。霰弹式修改，将变化的封装起来。依恋情节，一个函数和另一个模块的函数或者数据交流格外频繁，远胜于在自己所处模块内部的交流。数据泥团和基本类型的偏执。重复的 switch 和循环语句。冗赘的元素、夸夸其谈通用性和临时字段。过长的消息链和中间人。内幕交易，避免模块间的大量数据交换，降低模块间的耦合性。过大的类和异曲同工的类。纯数据的类、被拒绝的遗赠和注释。以上就是书中列举的代码的坏味道，每一个坏味道中都有相应的重构手法。第四章，小步快走虽然很大程度上保障重构后的系统稳定性，不过构筑一个测试体系就更好了。从第五章开始，作者依据重构手法的不同划分为第一组重构、封装、搬移特性、重新组织数据、简化条件逻辑、重构 API、处理继承关系等。本书的内容很多却又不多，正如作者所说，你可以把它当成重构字典，没必要记住每个重构手法，只需要在重构时知道采用什么样的策略即可。]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>重构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序云开发之始末]]></title>
    <url>%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BA%91%E5%BC%80%E5%8F%91%E4%B9%8B%E5%A7%8B%E6%9C%AB%2F</url>
    <content type="text"><![CDATA[前言一直都不喜欢微信，所以关于小程序的开发也是没怎么上心。只是在浏览招聘网站时，发现小程序已经成为前端开发人员的一个基本技能了。所以，只能硬着头皮尝试着学习开发小程序。在学习小程序开发时，倒是没觉得有什么阻碍，毕竟前端的最流行的框架已经流行了那么多年了，从某些方面，它们是相似的。本次所开发的功能很简单，但是就整个流程来说却是很漫长的，由于是从零开始开发，所以大部分时间还是花在了产品的构思上和小程序一些奇奇怪怪的问题上。而且，这次的开发只完成了产品预想的 50% 左右，核心的部分基本没有去做。最大的原因可能就是开发体验不好，浪费时间。小程序云开发对于个人开发人员来说，小程序云开发降低了开发门槛，尤其是前端人员的门槛。基于云开发，前端人员可以完成从前端到后台的所有任务。小程序云平台有着 Node环境，所以我们可以把它想象成基于 node 的后台环境。以爬虫为例，首先在 cloudfunctions 文件夹下创建文件夹 crawler，在该文件夹下面在创建创建相应 crawler.js 、package.json 文件，剩下就可以写些逻辑了。1234567891011121314151617181920212223242526272829303132333435363738394041// 云函数入口文件const cloud = require('wx-server-sdk')const Crawler = require("crawler");cloud.init()const uriArray = [&#123; uri: 'http://www.nows.fun/', selector: '#sentence' &#125;, &#123; uri: 'https://www.nihaowua.com/', selector: 'body &gt; div &gt; section &gt; div' &#125;, &#123; uri: 'https://www.nihaowua.com/home.html', selector: 'body &gt; div &gt; section &gt; div' &#125;];let crawler = new Crawler();let canClick = true;const crawlerWebPage = () =&gt; &#123; if (!canClick) return false; canClick = false; let index = Math.floor(Math.random() * 3); let &#123; uri, selector &#125; = uriArray[index]; return new Promise((resolve, reject) =&gt; &#123; crawler.direct(&#123; uri: uri, retries: 0, timeout: 5000, skipEventRequest: false, callback: function (error, response) &#123; canClick = true; if (error) &#123; console.log(error) &#125; else &#123; var $ = response.$; var content = $(selector).text(); console.log('index', index) resolve(content); &#125; &#125; &#125;) &#125;)&#125;;exports.main = async (event, content) =&gt; &#123; const result = await crawlerWebPage(); return result;&#125;云函数创建好了，剩下的就是在小程序中去调用了。123456789101112131415161718192021222324252627refresh: function (obj) &#123; if (!this.data.canClick) return; this.setData(&#123; canClick: false &#125;) wx.showLoading(&#123; title: '加载中', &#125;) wx.cloud.callFunction(&#123; name: "crawler", success: res =&gt; &#123; wx.hideLoading(); this.setData(&#123; soup: res.result, canClick: true &#125;) &#125;, fail: err =&gt; &#123; wx.hideLoading(); this.setData(&#123; soup: "鸡汤要一口一口喝，你太急啦", canClick: true &#125;) console.error('[云函数] [crawler] templateMessage.send 调用失败：', err) &#125; &#125;)&#125;小程序中的组件刚开始接触小程序时，给我的感觉像是在开发一个多页面应用。在开发构思的过程中，需要写的逻辑越来越多。于是就想着把这么多的东西拆开，翻了下文档，发现小程序提到自定义组件比较适合。首先在父组件中配置文件中配置子组件路径，然后自组件也要配置。123456789101112// father.json&#123; "usingComponents": &#123; "type-year": "../../component/type-year/type-year", "type-month": "../../component/type-month/type-month", "type-date": "../../component/type-date/type-date" &#125;&#125;// children.json&#123; "component": true&#125;剩下的就和 React、Vue 中的自定义组件差不多。以上也只是自定义组件，平时还会接触到第三方的组件，比如常用的 UI 组件。通常第三方组件都是使用 npm 包，但是小程序的环境比较特殊，它不是 Node 环境，所以基于 Node 环境的 npm 包也要特殊处理才能够在小程序只能够使用。尽管小程序官方提供了 npm 包转换的方案，但是依然会有很多包不能在小程序中使用，具体可见官方小程序开发文档。小程序中操作节点小程序的渲染层和逻辑层分别由2个线程管理，这和浏览器的环境是不一样的，所以要想操作节点需要使用小程序提供的API，不过在跨组件获取节点时，需要注意一下。12345678910111213141516171819onLoad: function () &#123; let height = &#123;&#125;; let yearChartHeight,monthChartHeight,componentHeight; let query = wx.createSelectorQuery().in(this); // Note: 操作节点 query.selectAll('#little_target, #target_type, #target_content').boundingClientRect( res =&gt; &#123; res.map(item =&gt; &#123; height[`$&#123;item.id&#125;_height`] = item.height; &#125;) yearChartHeight = height.little_target_height - height.target_content_height - height.target_type_height; componentHeight = monthChartHeight = height.little_target_height - height.target_type_height - 48; this.setData(&#123; yearHeight: yearChartHeight, monthHeight: monthChartHeight &#125;) &#125; ).exec();&#125;上面代码就是通过相关的 API 获取三个节点的数据。小程序中使用 echarts对比了 F2 和 echarts， 发现 echarts 提供的图表更多一些。这两个图表库的使用的方式也不同，F2 是 npm 包，需要转换导入使用。echarts 使用起来就相对简单一些，和上面提到的自定义组件一样，而且 echarts 还可以自定义选择需要图表导出，这样就减小包的体积。在使用这些图表库时，才明白什么叫做调參工程师，在开发的过程中真的是边看文档边调整参数。在使用 echarts 的过程中，本以为canvas 可以撑开盒子，结果发现需要父元素需要有高度，这也是为什么上面动态计算盒子高度。1234567891011121314&lt;!-- init 1 --&gt; &lt;view class="chart_wrap" style="height:&#123;&#123;chartHeight&#125;&#125;px"&gt; &lt;ec-canvas id="mychart-dom-bar" canvas-id="mychart-bar" ec="&#123;&#123; ec &#125;&#125;"&gt;&lt;/ec-canvas&gt; &lt;/view&gt;&lt;!-- data: &#123; ec: &#123; onInit: initChart &#125; &#125;, --&gt;&lt;!-- init 2--&gt; &lt;view class="chart_wrap" style="height:&#123;&#123;chartHeight&#125;&#125;px"&gt; &lt;ec-canvas id="mychart-dom-bar" canvas-id="mychart-bar" ec="&#123;&#123; ec &#125;&#125;" bind:init="echartInit"&gt;&lt;/ec-canvas&gt; &lt;/view&gt;在使用的过程中发现，初始化的方式并不惟一，结果也是不一样，这个需要注意一下。小程序的开发体验小程序的开发工具真心不怎么样，从日常 chrome 开发者工具再到小程序的开发者工具，这其中的差距还是很大。而且，我们不能方便随意地使用 npm 包，这在小程序中限制很明显。反正问题很多。over！]]></content>
      <categories>
        <category>写着玩</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>小程序</tag>
        <tag>云开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node写爬虫]]></title>
    <url>%2FNode%E5%86%99%E7%88%AC%E8%99%AB%2F</url>
    <content type="text"><![CDATA[前言最近一段时间在学习小程序，文档很长，但是对于前端开发者来说，并不是很难。然而在准备实践的时候，却犯难了。虽然只是练手，但起码要做一个有意义的东西。所以，第一时间，就想到利用爬虫来爬取自己想要的内容。在打算实践时，却也发现，由于小程序的的一些限制，要想实现我的想法，太麻烦，对于我来说，有点浪费时间。不过，既然都想到过爬虫了，就趁这次机会练练手。通过本次的粗浅的实践，可以将爬虫的过程总结为，获取静态页面或获取接口数据 =&gt; 分析页面结构或分析接口数据 =&gt; 提取数据保存。基于Node的爬虫方式，要么是加载页面，要么是请求API，所以相对来说都很容易实现。puppeteerpuppeteer 应该算是最简单的方式了，通过模拟用户的行为与浏览器交互，然后我们就可以分析页面抓去需要的信息。puppeteer 文档很详实，而且手把手教学，你想要的功能基本上都能在它的 github 上找到相应的例子。puppeteer 是基于 Chromium 的，在安装 puppeteer时，会同时安装 Chromium。而因为众所周知的缘故，整个安装的过程并不是很顺利，文档里提供了不安装 Chromium 的方法，不过，我们也可以使用淘宝的镜像来加快安装时间。1npm config set puppeteer_download_host https://npm.taobao.org/mirrors下面通过一个打卡🌰来使用 puppeteer,12345678910const login = async () =&gt; &#123; const browser = await puppeteer.launch(&#123; headless: false &#125;); // 默认true。置为 false，整个操作过程可视 const page = await browser.newPage(); await page.goto(logURL); // 跳转目标网页logURL，默认 load 事件触发 await page.type('#member_number', '123456') // 输入卡号 await page.click('#btn_member_number') // 点击确定 await page.waitForSelector('#check_in') // 等待签到 Dom 渲染完成 await page.click('#check_in') // 点击签到按钮 await browser.close()&#125;代码流程和用户操作浏览器的流程一致，这种方式相比接下来要说的方式，可以说是傻瓜式操作了。当然 puppeteer 还可以生成截图，性能分析等。接口请求不管是静态还是动态页面的获取，都是通过接口请求来实现的，即通过url向后端服务请求相应的数据。按照之前的爬取流程，要做的就是数据的请求和数据的分析。如果需要保存的话，就要使用存储工具储存数据。一般情况下，在 Node 环境中请求数据，我们会使用封装好的 htttp 库，比如 request，axios等。那么分析数据呢？这就要看情况了，如果爬取的是静态页面，返回的是 HTML，这时我们就需要借助 Cheerio 或 JSDOM 来分析页面结构。如果返回的是常见的 JSON，那就很简单了。不过本次实践没有通过以上的方式，而是在 github 搜索相关信息时，恰巧看到了 crawler。原理上都是差不多的，而且它也集成了 Cheerio。12345678910111213141516const Crawler = require("crawler");const crawlerWebPage = obj =&gt; &#123; let &#123;uri, selector&#125; = obj; // uri 请求的uri，selector 选择器； crawler.direct(&#123; uri: uri, skipEventRequest: false, callback: function(error, response) &#123; if(error) &#123; console.log(error) &#125; else &#123; var $ = response.$; var content = $(selector).text(); console.log(response.statusCode, content, uri); &#125; &#125; &#125;)上面这个也只是 crawler 的简单用法。node-schedule虽然可以爬取了，但是数据并不是一成不变的，所以，更多的时候，我们需要定时重复爬取网页。 node-schedule 就是用来定义定时任务的。12345678910111213141516171819const schedule = require('node-schedule');const loginSchedule = () =&gt; &#123; schedule.scheduleJob(&#123; start: startTime, endTime: endTime, rule: config.schedule.login[loginIndex] &#125;, () =&gt; &#123; let now = new Date(); let loginLog = `$&#123;now&#125; login successed! /r/n`; try &#123; login(); fs.appendFileSync('log.txt', loginLog) &#125; catch (error) &#123; let loginErrorLog = `$&#123;now&#125; - $&#123;logURL&#125; login failed: $&#123;error.message&#125;! /r/n`; fs.appendFileSync('log.txt', loginErrorLog) throw error &#125; &#125;)&#125;定义好相关的规则后，任务就可以按制定的规则执行。pm2以上的任务是可以执行了，可是关闭了命令窗口，进程中断，那么功夫白费。这时候就需要一个工具来管理 node 进程，pm2 倒是一个好工具。pm2 不仅支持热加载，还可以监控等功能，很方便很强大。12345678910111213# 安装npm install pm2 -g# 启动、监听 app.jspm2 start app.js --watch# 监控pm2 monit# 终止pm2 stop......debug在写 Node 应用时，难免磕磕绊绊，学会调试也是很有必要的。本次项目很简单，所以所使用的调试技巧也很粗浅。使用 VSCode 提供的调试工具。在项目中加入 debugger，执行 node debug --inspect app.js,开启调试模式。借助其他调试工具。over]]></content>
      <categories>
        <category>写着玩</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读《学习之道》]]></title>
    <url>%2F%E8%AE%BA%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%81%93%E6%9C%89%E6%84%9F%2F</url>
    <content type="text"><![CDATA[我意识到自己最擅长的既不是象棋也不是太极，我最擅长的是学习之道。偶然间听到了《学习之道》这本书，吸引我的并不是这么霸气的书名，而是书里说的一些观念很是契合。好奇之下，买本看看。书中描述的是作者传奇般的经历，与其说是传授他的学习之道，倒不如说把他经历的点点滴滴讲述给大家听。书中并没有提出速成的方法，只是事无巨细的讲述自己的经历和感悟。而这些却是本书最重要的，作为一个传奇人物，他的经历是很有参考价值的，就算只是描述日常生活的流水账。此时，能否从书中受益，不再取决于书的内容，而是读者如何看待这本书。而最让我敬佩的是，作者能够体察入微，探究其背后的真相。上士闻道，勤而行之；中士闻道，若存若亡；下士闻道，大笑之，不笑不足以为道在读书的过程中，我才知道，为什么我会被这本书吸引。原来，作者也是《道德经》的读者，和我这个半吊子，也算是志同道合了。看完这本书，我就预料，能够读懂这书的势必赞不绝口，读不懂此书的也会觉得味同嚼蜡，索然无味。而我个人观点则是，作者把自己感悟融入了生活之中，在描述个人经历的时候，其实就是在诠释什么是学习之道。这也是我觉得作者很厉害的原因，复归自然。道之出口，淡乎其无味，视之不足见，听之不足闻生活中处处透着大道理，可是看不到，摸不着，听不见，不留痕迹。就如侦探小说里说，之所以主人公能够发现一些线索进而破解案件，是因为发现了不合理的地方。而道法自然，我们在这种环境下成长，也会觉得一切自然而然。我们生气也是自然，我们开心也是自然，以至于我们从来不追究看似自然的背后到底发生了什么。而作者还是个孩童时，补充一下，作者很小的时候就已经过着开挂的人生了，在经历挫折时，及时发现自身处境，并从中获益。我们今天能够有幸看到这本书，也正是因为作者敏锐得观察能力。知人者智，自知者明。胜人者有力，自胜者强在当今这个社会，人们被快节奏的生活压地喘不过气来。我认为所谓的自知，不仅仅指的是个人的能力，还应该包括情绪等。很多人被情绪控制而不自知，而由情绪带来的负面影响又将人带向更坏的处境。冥想，作为缓解压力的运动，在当今社会很流行。在冥想时，我们需要感受自身肌肉的情况，然后不断去调节放松。很多初学者在刚开始冥想时，压根不知道自己的肌肉到底是处于什么状态。人的情绪也是如此，我们需要时刻关注自己情绪的变化，最终也可以做到掌控情绪。而作者也多次在对局中，克服消极情绪，最后拿下冠军。生气也好，开心也罢，这些都不重要。重要的是，我们需要接纳自己情绪，不抵触。如果放在学习里，那就是放下我们的畏难情绪。其实，阻止我们前行的一直都是我们自己。同时，我们还要做到静如处子，动如脱兔，把自己的注意力用在它被需要的地方。天下难事必作于易，天下大事必作于细看似简单的事物，也仅仅是因为我们想简单了。不出户，知天下；不窥牖，见天道，还是那句话，生活中处处透着大道理，看似简单的事情，做多了做透了，也可以作出一番成绩。而我们常常观察不到，是因为我们的想法太多，杂念太多，有太多的理所当然。五色令人目盲，五音令人耳聋，五味令人口爽，驰骋畋猎令人心发狂，难得之货令人行妨在古时候，人们还想着修心养性。在这个物欲横流的社会中，我们更应该如此，受诱惑的东西太多，往往导致我们无法追寻本源。你呆的越舒适，你就越觉得理所当然，也就越不能发现容易忽略的细节。之前看过一个有趣的报道，人有意识和潜意识之说。在人休息发呆的时候，人的潜意识开始进行知识整合。这也是好多人在知识储备足够的时候会有灵光一现的说法。而现在的科技发达，太多的科技产品占用了我们的生活，这也破坏了原有的整合机制。最后报道给出的结论是，在这种环境下，人类会变得越来越笨。说的貌似挺有道理的，所以说玩手机要适度。作者还提到，内化和强化训练。就是不断针对自己不熟悉的领域去强化，进而使其成为身体惯性。讲真，写到这里，其实我已经不记得书中的细节了，虽然才刚看完。书中的内容可以说是干货满满，毕竟作者是以自己的行动去实践并取得了很大的成就。也可以说这本书什么都没说，内容宽泛，更像心理指导。最后用一句话总结，面临危机，坦然接受痛苦，直至从容，闲庭信步。]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>道德经</tag>
        <tag>学习之道</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解剖排序算法]]></title>
    <url>%2F%E8%A7%A3%E5%89%96%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前言排序是计算机中对存储的数据执行最常见的操作之一。语法简单，却很精妙。在排序算法中绕不开的是循环，只有在深入学习排序算法时，才发现平时不起眼的循环语句不可小觑。拿最简单的冒泡排序来说，道理我都懂，可为什么会想到两层嵌套的循环语句？为什么两层循环语句的条件会有所不同？两层循环的关联逻辑是什么？循环在冒泡中扮演着什么角色？循环是通过怎样的逻辑完成冒泡的？等等。这些问题的背后，都值得我们去探究。循环在说正题之前，需要说一个小插曲。由于互联网寒冬，程序员们都有一种危机感。在这场危机中，程序员的筛选条件也变得更加苛刻。无论是前端还是后端，都最好能够熟悉掌握一些基础算法。所以说，刷算法题，也在程序员间流行起来了。我旁边的一同事，就刷到了一个有趣的算法，说是挺有意思的，就让我也尝试一下。讲真，作为一个前端，除了简单处理一下接口数据，还真没有训练过应试般的算法。题目大致是这样的，在 n*n 的平面中，以一半的空间螺旋有序排满以1起始若干数字。画图如下：随着思考的深入，突然发现，这tm不就是一道数学题么？（原谅我说粗话了）找出已知，列出未知，关联已知未知，就差列 x、y 了。以下以 5*5 为例：1234567891011121314151617181920var arr = Array.from(&#123;length: 5&#125;).map(item =&gt; ([]));var i = 1;function Sort(init, length)&#123; let m = init, n= init; while(m &lt; length)&#123; arr[m++][init] = i++; &#125; --m; while(n &lt; length -1) &#123; arr[--m][++n] = i++; &#125; --n; while(n &gt; init) &#123; arr[m][n--] = i++; &#125; if (length &lt;= 3) return arr; Sort(n+1, length - 2);&#125;console.log(Sort(0, 5), arr)变动的就是未知，找出循环条件，关联已知，这样等式就算列出来了。在这里我把平面想像成平面坐标，m、n 当作 x、y 轴，数组就是坐标点的集合，数字螺旋折转的条件作为循环递归条件，就这样，一个粗糙的算法算是完成了。虽然这和本次主题的关系不是很大，但是很受启发，让我觉得程序和数学果然存在着紧密的关系。回到这一小节，以最简单的 for 循环为例。12let arr = [1, 2, 3];for(let i = 0;i &lt; arr.length; i++)&#123;&#125;以上就是最简单的 for 循环写法，从这个简单的 for 语句，我们能够知道的是，第几次循环i（即当前），循环的次数arr.length及循环的驱动i++。很重要的一点就是，i 是随着循环递增的。循环就是这么简单，也没有什么其他魔力。在排序算法中，还有一点需要注意的，那就是数组。在 JavaScript 中，数组元素在内存中并不是连续的。我们可以通过索引来引用相应位置的元素。更重要的是，我们通常操作数组元素的时候，并不是操作数组元素本身，而是该位置上的变量。我们可以想象成，每一个索引位置都是一个变量，然后通过给变量赋值数组元素。循环和数组，如果单独使用倒也没什么。如果两者结合，你就会发现，随着循环的次数增加，数组索引也会递增，再结合一些逻辑，就可以把某些元素移动到制定的位置。那么，都结合怎样的逻辑呢？冒泡排序冒泡排序逻辑，通过两两比较，把较大的元素赋值给当前位置索引的后一索引位置，然后随着循环增加，当前索引也会递增，最终会把最大值推到末尾。然后把这个过程循环多次，最终把倒数第二大、倒数第三大…移到指定位置。1234567891011function bubbleSort(arr)&#123; let len = arr.length; for(let i = 0; i &lt; len - 1; i++)&#123; for(let j = 0; j &lt; len - 1 - i; j++)&#123; // 递增更换当前元素； if (arr[j] &gt; arr[j+1])&#123; // 相邻元素比较； [arr[j], arr[j+1]] = [arr[j+1], arr[j]]; // 位置互换； &#125; &#125; &#125; return arr;&#125;选择排序选择排序逻辑，比较当前数组元素，找出最小元素的索引，将该位置的元素移动指定位置。然后多次循环遍历，最终将剩下数组元素中第二小元素、第三小元素…移到指定位置。12345678910111213function selectionSort(arr)&#123; let len = arr.length; for(let i = 0; i &lt; len - 1; i++)&#123; let minIndex = i; for(let j = i + 1; j &lt; len; j ++)&#123; // 递增替换当前元素； if(arr[j] &lt; arr[minIndex])&#123; minIndex = j; // 更新最小元素索引； &#125; &#125; [arr[minIndex], arr[i]] = [arr[i], arr[minIndex]]; // 与最小元素互换位置； &#125; return arr;&#125;插入排序插入排序逻辑，将当前的数组元素与之前的数组元素比较，并将其插入到适当位置。123456789101112function insertionSort(arr)&#123; let len = arr.length; for(let i = 1; i &lt; len; i++)&#123; let temp = arr[i]; let preIndex = i -1; while(preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; temp)&#123; arr[preIndex + 1] = arr[preIndex--]; // 该位置元素若小于当前元素，则将其后移动； &#125; arr[preIndex+1] = temp; &#125; return arr;&#125;希尔排序希尔排序算是插入排序的升级版本，插入排序是与之前的数组元素挨个进行比较，而希尔排序是以特定间隔进行多次分组比较，所以说在代码上很相似。123456789101112131415function shellSort(gap, arr)&#123; let len = arr.length; for(let i = 0; i &lt; gap.length; i++)&#123; // 以不同间隔分组比较； for(let j = gap[i]; j &lt; len; j++)&#123; // 以间隔的下一索引位置起始； let temp = arr[j]; let preGapIndex = j - gap[i]; while(preGapIndex &gt;= 0 &amp;&amp; arr[preGapIndex] &gt; temp)&#123; // 当前元素与之前固定间隔索引位置元素进行比较； arr[preGapIndex + gap[i]] = arr[preGapIndex]; preGapIndex = preGapIndex - gap[i]; &#125; arr[preGapIndex + gap[i]] = temp; &#125; &#125; return arr;&#125;归并排序归并排序逻辑，使用递归的方式将数组划分为更小的数组对，通过比较重新合成完整的数组。本文采用的是自顶向下的归并排序，还可以使用自底向上的归并排序。123456789101112131415161718192021222324function mergeSort(arr)&#123; let len = arr.length; if(len &lt; 2) return arr; let middle = Math.floor(len/2); // 分组； let left = arr.slice(0, middle); let right = arr.slice(middle); return merge(mergeSort(left), mergeSort(right));&#125;function merge(left, right)&#123; let len = left.length + right.length; let result = [], m = 0, n = 0; left[left.length] = Infinity; right[right.length] = Infinity; for(let i = 0; i &lt; len; i++)&#123; // 循环的次数为新数组的长度； if(left[m] &lt;= right[n])&#123; // 比较左右数组元素重新排列组合成新的数组； result[i] = left[m]; m++; &#125;else&#123; result[i] = right[n]; n++; &#125; &#125; return result;&#125;快速排序快速排序逻辑，从数组中选出基准值，将大于基准值的元素移到右侧数组，将小于基准值的元素移到左侧数组，递归循环此操作直到数组为空。然后合并各组数组，最终得到排序后的新数组。1234567891011121314function quickSort(arr)&#123; if(arr.length &lt; 1) return arr; let len = arr.length; let pivot = arr[0]; // 设置基准值； let lesser = [], greater = []; for(let i = 1; i &lt; len; i++)&#123; if(arr[i] &lt; pivot)&#123; lesser.push(arr[i]); // 将小于基准值推至左侧； &#125; else &#123; greater.push(arr[i]); // 将大于基准值推至右侧； &#125; &#125; return quickSort(lesser).concat(pivot, quickSort(greater));&#125;over！]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker-compose安装gitlab]]></title>
    <url>%2Fdocker-gitlab%2F</url>
    <content type="text"><![CDATA[日常吐槽前端工程化，个人认为就是通过工具减少程序员们的手动操作，从而提高生产力。还有一个就是，减小人在产品开发到上线整个流程的参与度，从而减小 bug 率。毕竟在琐碎繁复的操作中，人难免会出现失误。gitlab 倒是一个很好的工具，可以管理代码，也可以实现持续集成、持续交付、持续部署等。本次的实践也只是通过 docker-compose 安装了 gitlab，顶多只是作为代码托管平台。CI/CD 除了 gitlab 可以完成，还有一些有名的 Jekins，Travis等。本来打算用 gitlab 来完成这些功能，但是相关的知识储备还是有些欠缺。而且，就目前规划来看，继续深入 gitlab 并不划算。所以，这算是在此挖坑，等哪天时机成熟，再来补上这个技术债。git工作流在使用 gitlab 之前，不得不提 Git 工作流。Git 是版本控制系统，而 gitlab 是基于 Git 的代码托管服务。在团队协作时，为了更好的管理代码，就应该制定一个代码提交规范 —— Git 工作流程。目前广泛使用的工作流程有：Git flowgithub flowgitlab flowGit flow：github fow:gitlab fow:三种工作流各有特点,但也并非一成不变，要根据场景制定最佳工作流。docker-compose安装Gitlab安装 gitlab 的方法有很多，就仅仅是使用 gitlab 的 Docker 镜像安装，官方就提供了三种方法GitLab Docker images。不过，个人认为，最为方便的还是使用 docker-compose。12345678910111213141516web: image: 'gitlab/gitlab-ce:latest' restart: always hostname: 'gitlab.example.com' environment: GITLAB_OMNIBUS_CONFIG: | external_url 'https://gitlab.example.com' # Add any other gitlab.rb configuration here, each on its own line ports: - '8090:8090' - '443:443' - '22:22' volumes: - './srv/gitlab/config:/etc/gitlab' - './srv/gitlab/logs:/var/log/gitlab' - './srv/gitlab/data:/var/opt/gitlab'hostname、external_url: 用来制定域名，不过需要在 host 文件中完成 ip 映射。1127.0.0.0 https://gitlab.example.comports: 暴露了容器的三个端口, 分别是 https 对应的 443, http 对应8 090 以及 ssh 对应的 22 (如果不需要配置https, 可以不暴露)volumes: 指定挂载目录, 这个便于我们在本地备份和修改容器的相关数据然后执行 docker-compose up -d 命令就可以后台运行 gitlab 了。（-d 后台运行）第一次登陆时需要设置管理员密码。遇到的问题gitlab Error executing action &#39;create&#39; on resource ...原因：没有相关权限。解决方案： sudo docker-compose up -d。gitlab 500 Internal Privoxy Error原因：本机开了代理。]]></content>
      <categories>
        <category>写着玩</category>
      </categories>
      <tags>
        <tag>gitlab</tag>
        <tag>git工作流程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React+Koa+MongoDB+Docker开发环境]]></title>
    <url>%2FReact-Koa-MongoDB-Docker%2F</url>
    <content type="text"><![CDATA[前言本次博文依然是对 multi-spa-webpack-cli 的扩充和完善。集成 mongoose。集成 Docker 开发环境。multi-spa-webpack-cli 已经发布到 npm，只要在 node 环境下安装即可。1npm install multi-spa-webpack-cli -g使用步骤如下:12345678910111213141516171819202122232425262728293031# 1. 初始化项目multi-spa-webpack-cli init spa-project# 2. 进入文件目录cd spa-project# 未使用 Docker# 3. 打包不变的部分npm run build:dll# 4. 启动项目（手动打开浏览器：localhost:8090）npm start# 5. 启动 MongoDBmongod# 6. 启动服务cd servernpm installnpm start# 使用 Docker（需安装docker）# 3. 启动项目（手动打开浏览器：localhost:8090）npm run docker:dev从上面的步骤可以看出，Docker 只需要 3 步就可以启动项目了。mongoosemongoose 是在 node.js 环境下对 MongoDB 进行便捷操作的对象模型工具。在没开始之前，要先安装 MongoDB。安装 MongoDB 的过程中，可能有些小麻烦，尤其是公司的电脑（谁也不知道电脑里配置了什么东西）。安装过程可参照 【官网：安装MongoDB】还要知道 MongoDB 的一些概念。SQL术语/概念MongoDB术语/概念解释/说明databasedatabase数据库tablecollection数据库表/集合rowdocument数据记录行/文档columnfield数据字段/域indexindex索引tablejoins表连接,MongoDB不支持primary keyprimary key主键,MongoDB自动将_id字段设置为主键数据库服务和客户端：SQLMongoDBMysqld/Oraclemongodmysql/sqlplusmongomongoose 相关概念看看官网就好了【mongoose 中文文档】用法很简单，定义 Schema，转换成 Model，操作 Model，生成实例。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/* model.js */const mongoose = require('mongoose');const Schema = mongoose.Schema;// 定义 Schemaconst UserSchema = new Schema(&#123; username: &#123; type: String, unique: true, require: true &#125;, password: &#123; type: String, require: true &#125;&#125;);// 转换成 Modelconst UserModel = mongoose.model('User', UserSchema);module.exports = UserModel;/* user.js */// 操作 Modellet user = await UserModel.findOne(&#123; username &#125;); if (!user) &#123; try &#123; // 生成实例 await new UserModel(&#123; username, password &#125;).save(); ctx.body = &#123; "success": true, "message": "注册成功" &#125; &#125; catch (error) &#123; ctx.body = &#123; "success": false, "message": "注册失败" &#125; &#125; &#125; else &#123; ctx.body = &#123; "success": false, "message": "用户名已存在" &#125;&#125;Docker由上面的步骤，我们可以看出来，项目启动步骤麻烦，而且在安装 MongoDB 环境时，容易受干扰。下面通过 Docker 来构建开发环境，提高开发体验。在使用 Docker 之前，先了解下几个概念。镜像： 镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。所以，在生产部署时，确保每一层的纯净，剔除不必要文件。比如开发编译时的文件等（ node_module ）。这样也避免了镜像不必要的臃肿。容器：容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 命名空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为容器存储层。容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 数据卷（Volume）、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。开发环境经常对文件修改，就可以利用这里的数据卷绑定宿主目录。上下文：传给 Docker 引擎的文件目录。Docker 在运行时分为 Docker 引擎（也就是服务端守护进程）和客户端工具。在构建镜像时，会将上下文复制到 Docker 引擎。然后通过 Docker 客户端发出指令，而指令的执行是在 Docker 引擎中。所以，上下文的范围要合理，范围过大，就会导致文件复制到 Docker 引擎的时间长；范围过小，则会导致无法操作范围外的文件。Docker 部署开发环境部署开发环境其实很简单，只需要配置 Dockerfile 和 docker-compose 即可。相关文档可见：【Dockerfile 指令详解】和【Compose 模板文件】docker-compose 使用的是 YAML 语言，【YAML 语言教程】1234567891011121314151617181920212223242526272829303132333435version: '3.6'services: client: container_name: "client" build: context: ../ dockerfile: Dockerfile.client.dev volumes: - ../src:/app/client/src ports: - "8090:8090" depends_on: - server server: container_name: "server" build: context: ../server dockerfile: Dockerfile.server.dev volumes: - ../server:/app/server ports: - "8080:8080" depends_on: - database database: container_name: mongo image: mongo volumes: - ../data:/data/db ports: - "27017:27017"开发环境需要的就是实时展现效果，前端页面是这样，后端服务亦是如此。如上文提到，上下文已经提交到镜像，前端项目如何才能够在容器中实现热替换？其实很简单，就是 volumes 这个配置。同理，后端也是，不过还需要 modemon 工具协助。在部署时，也要到了一些问题，就是在镜像中，localhost 无法使用，需要用 IP 代替。123456789101112131415161718// 前端项目/* webpack.dev.js */ devServer: &#123; publicPath: '/', contentBase: path.resolve(__dirname, '..', 'dist'), port: APP_CONFIG.port, host: '0.0.0.0', // 需指明 hot: true, historyApiFallback: &#123; index: '/' &#125; &#125;// 后端项目/* config.js */module.exports = &#123; 'database': 'mongodb://database:27017/yexiaochen' // 与 docker-compose 中 database 服务名匹配&#125;]]></content>
      <categories>
        <category>写着玩</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React脚手架搭建]]></title>
    <url>%2FReact%E8%84%9A%E6%89%8B%E6%9E%B6%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[前言之前的 multi-spa-webpack-cli 只是为 React + antd 模板提供了开发时必要的环境，对于实际的开发并没有什么用处。为了更贴近实际开发，本次 React + antd 模板完善了一些功能。封装 fetch，新增请求错误提示；集成 react-router-dom 路由管理；集成 react-redux 状态管理；必不可少的 antd 集成；node 服务集成（可选）。node 服务和 React+antd 模板是没有多大的关系的。本文只是想通过一个简单的登陆逻辑来演示以上的功能，所以 node 服务不是必须的。multi-spa-webpack-cli 已经发布到 npm，只要在 node 环境下安装即可。1npm install multi-spa-webpack-cli -g使用步骤如下:12# 1. 初始化项目multi-spa-webpack-cli init spa-project1234567891011121314151617# 2. 进入文件目录cd spa-project# 3. 安装依赖npm install# 4. 打包不变的部分npm run build:dll# 5. 启动项目（手动打开浏览器：localhost:8090）npm start# 6. 启动服务(可选)cd servernpm installnpm start预览：封装 fetch现在处理异步的方式，大多数基于 Promise 的。而 fetch 是天然支持 Promise 的，所以无需再手动封装。在 PWA 技术中，已作为一个重要的组成部分在使用。fetch 为人诟病的缺点之一，就是不能 Abort 请求。有方案提出提出，通过 Promise.race 的方法来模拟 timeout。实际上该执行的已然执行，只是表象上达到了预期的效果。不过浏览器现以实验性开始支持 AbortController 。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import &#123; notification &#125; from 'antd';const env = process.env.NODE_ENV;const baseURL = APP_CONFIG[env].ip;// timeout ;// const controller = new AbortController();// const signal = controller.signal;const defaultConfig = &#123; credentials: 'include', headers: &#123; Accept: 'application/json' &#125;, // signal&#125;;const codeMessage = &#123; 301: '永久移动', 302: '临时移动',// ... 504: '网关超时。'&#125;;const checkStatus = response =&gt; &#123; if (response.status &gt;= 200 &amp;&amp; response.status &lt; 300) &#123; return response; &#125; const errortext = codeMessage[response.status] || response.statusText; notification.error(&#123; message: `请求错误 $&#123;response.status&#125;: $&#123;response.url&#125;`, description: errortext &#125;);&#125;;export default async function Fetch(url, config) &#123; let newUrl = baseURL + url; let newConfig = &#123; ...defaultConfig, ...config &#125;; // const timeoutId = setTimeout(() =&gt; controller.abort(), 5000); if ( newConfig.method.toLocaleLowerCase() === 'post' || newConfig.method.toLocaleLowerCase() === 'put' || newConfig.method.toLocaleLowerCase() === 'delete' ) &#123; if (!(newConfig.body instanceof FormData)) &#123; newConfig.headers['Content-Type'] = 'application/json; charset=utf-8'; newConfig.body = JSON.stringify(newConfig.body); &#125; &#125; try &#123; const response = await fetch(newUrl, newConfig); // clearTimeout(timeoutId); return checkStatus(response).json(); &#125; catch (error) &#123; notification.error(&#123; message: `请求错误 : $&#123;newUrl&#125;`, description: error.message &#125;); throw error; &#125;&#125;集成 react-router-dom 路由管理自 raect-router v4 之后，便不再支持集中式管理路由，不过也可以自己手动去实现。React + antd 模板采用的是官网推荐的方式，layouts 目录下的文件用来管理路由。集成 react-redux 状态管理Redux 作为状态管理工具，除了 React，也可以用在其他地方（意思是说，和 React 没半毛钱关系）。在React中使用时，我们需要借助 React-redux 工具，这样使用起来更加方便。严格的单向数据流是 Redux 架构的设计核心。redux 数据流向：就是把 action（行为） dispatch（丢给）reducer（更新 state）。node 服务集成（可选）node 服务登陆采用的是 session 来记录状态。就这样，一个简单的脚手架宣告完成。不过，这才只是个开始。]]></content>
      <categories>
        <category>写着玩</category>
      </categories>
      <tags>
        <tag>CLI</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack开发环境配置]]></title>
    <url>%2Fwebpack%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[日常吐槽经过不断的调整和测试，关于 react 的 webpack 配置终于新鲜出炉。本次的重点主要集中在开发环境上，生产环境则是使用 webpack 的 production 默认模式。本次配置主要有：eslint+prettier;optimization.splitChunks;happypack;DllReferencePlugin &amp; DllPlugin;…文档的重要性讲真，对于初次接触 webpack 的同学，怕的可能不是 webpack 的配置，而是长长的 package.json。依赖那么多，你怎么就知道需要哪些依赖呢。不开玩笑，我还真知道。webpack 的依赖主要是一些 loader 和 plugins。我们知道单页面引用被打包后，原有的结构基本上不复存在了。而之前引用的图片或字体资源还按照之前的路径查找，肯定是找不到的。那么我们就需要转换工具（顺便转换资源）—— url-loader|file-loader。大多数人写样式时，喜欢使用 css、less、sass。这时也会有对应的工具 style-loader, css-loader, less-loader。想要使用 JavaScript 新特性或处理兼容性，就用 babel-loader。以上这些基本上可以应付一些简单的项目。可实际上呢？我信你个鬼，你这个糟老头坏的很！看文档啊，看官方介绍啊。本次也是通过看 babel 文档，和一些依赖文档来配置 webpack 的，全程无压力，而且很正宗。所以，文档很重要。eslint+prettier如果时团队合作，代码规范是很重要的。可以通过 eslint+prettier 规范。这两个工具各有侧重点，不过官网也提供了两者结合的方案。详细介绍见官网。我个人不习惯创建太多的配置文件，所以都放在了 package.json 文件中。123456789101112// webpack.common.js&#123; enforce: "pre", test: /\.m?jsx?$/, exclude: /node_modules/, loader: "eslint-loader", options: &#123; fix: true, cache: true, formatter: require("eslint-friendly-formatter"), &#125;&#125;,12345678910111213141516171819"eslintConfig": &#123; "parser": "babel-eslint", "env": &#123; "browser": true, "es6": true, "node": true &#125;, "parserOptions": &#123; "ecmaVersion": 6, "sourceType": "module" &#125;, "extends": [ "plugin:prettier/recommended" ]&#125;,"prettier": &#123; "singleQuote": true, "semi": true&#125;,开发环境开发环境没什么好说的了，简单易配置，官网很详细。12345678910111213141516171819202122// webpack.dev.jsplugins: &#123; //... new webpack.HotModuleReplacementPlugin()&#125;,devtool: "eval-source-map",devServer: &#123;contentBase: path.resolve(__dirname, '..', 'dist'),port: APP_CONFIG.port,hot: true,open: true&#125;// index.js// 入口处要配置这些，别忘了。// 因为有冒泡的机制，所以在顶端加一个就好。if (module.hot) &#123; module.hot.accept('./views/login/index.js', () =&gt; &#123; render(App) // 渲染应用 &#125;)&#125;optimization.splitChunks这个配置是用来分割包的。在性能优化上，请求数和请求包的大小也是很重要的优化点。请求数量和请求数据大小要控制在合理的范围内。不过通常情况下，我们会将包分割为内容不变的部分和内容变化的部分。这不仅仅是为了将大的包分割成更小的包，也是为了能够充分利用缓存机制。123456789101112131415161718// webpack.common.jsruntimeChunk: 'single', splitChunks: &#123; cacheGroups: &#123; verdor: &#123; test: /[\\/]node_modules[\\/]/, name: 'verdors', chunks: 'all', priority: -10, &#125;, common: &#123; name: 'common', chunks: 'all', minChunks: 2, priority: -20, &#125; &#125;&#125;happypack转换文件算是打包过程中比较耗时的事情，通过 happypack 可以将这件事分摊给多个 node 进程，这样就会大大缩短了打包时间（同理，可以考虑使用 thread-loader）。不过进程之间的通信是要开销的，这是一个优化方向，要不要采用，还需要酌情考虑。123456789101112131415161718192021222324252627282930// loader&#123; test: /\.m?jsx?$/, exclude: /node_modules/, use: 'happypack/loader?id=js',&#125;// pluginsnew HappyPack(&#123; id: 'js', threadPool: happyThreadPool, loaders: [&#123; loader: 'babel-loader', options: &#123; cacheDirectory: true, presets: [['@babel/preset-env', &#123; "useBuiltIns": "usage", "corejs": 3 &#125;], "@babel/preset-react"], plugins: ['@babel/transform-runtime', "@babel/plugin-proposal-class-properties", [ "import", &#123; "libraryName": "antd", "style": true &#125; ] ] &#125; &#125;]&#125;)不喜欢单独的 babel 文件，所以 babel 的配置都在这里了。其实，关于 babel 要配置的内容还是挺多的。不过不要怕，babel 的官方文档有详细说明。DllReferencePlugin &amp; DllPlugin之前也提到过，通常我们会使用 optimization.splitChunks 来处理第三方库，将其分割成不变的部分。可是，每次打包的时候都需要重复这一步骤。这时候我们就想啊，不变的部分打包一次不就可以了么，之后就只打包那些经常变化的部分，这样不就能提高效率了么？是的， DllReferencePlugin &amp; DllPlugin 基本上要做的就是这么一回事。所以，我们会针对这两部分做不同的配置。1234567891011// webpack.dll.jsnew webpack.DllPlugin(&#123; context: process.cwd(), path: path.join(__dirname, '..', 'dist', 'dll', '[name]-manifest.json'), name: '[name]_[hash]'&#125;)// webpack.common.jsnew webpack.DllReferencePlugin(&#123; context: process.cwd(), manifest: require(path.resolve(__dirname, '..', 'dist', 'dll', "vendor-manifest.json"))&#125;),multi-spa-webpack-cli使用说明multi-spa-webpack-cli 已经发布到 npm，只要在 node 环境下安装即可。一路按 Enter，全部源码都在里面！！！1npm install multi-spa-webpack-cli -g使用步骤如下:1234567891011121314# 1. 初始化项目multi-spa-webpack-cli init spa-project# 2. 进入文件目录cd spa-project# 3. 安装依赖npm install# 4. 打包不变的部分npm run build:dll# 5. 启动项目（手动打开浏览器：localhost:8090）npm start]]></content>
      <categories>
        <category>写着玩</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手写webpack脚手架的cli工具]]></title>
    <url>%2F%E6%89%8B%E5%86%99webpack%E8%84%9A%E6%89%8B%E6%9E%B6%E7%9A%84cli%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[日常吐槽本来想搭建一个webpack脚手架的，于是在搭建的过程中不断地搜集相关资料。可最终的结果是，webpack脚手架没有搭建成，却写出个 CLI 小工具。其实，这也并不是没有原因的。现在流行的框架都推出了自己的脚手架工具，比如，Vue CLI，Create React App 等。脚手架和CLI往往如影随形，这也导致了两者在概念上的混淆。标题为什么这么拗口，其实是为了区分这两个概念。我有一个想法既然被带跑偏了，就只能在跑偏的路上越跑越远吧。命令行界面（英语：Command-Line Interface，缩写：CLI）是在图形用户界面得到普及之前使用最为广泛的用户界面，它通常不支持鼠标，用户通过键盘输入指令，计算机接收到指令后，予以执行。也有人称之为字符用户界面（character user interface, CUI） ———— 维基百科使用过 Vue CLI 的同学应该都知道，我们只需要在终端敲几个的命令就可以搭建一个 Vue 的脚手架。如果不使用 CLI 的话，每次创建项目时，都需要配置文件（比如webpack配置文件）、设计结构、技术栈选型等。如果每次从零开始去搭建项目就会很麻烦，所以我们可以把相同的东西抽离成脚手架。以后创建项目时，就可以直接把脚手架复制过来，并以此为基础搭建项目。回过头来再看看我们手动搭建项目的过程，从每次从零开始搭建项目到脚手架的复用，这中间有了很大的进步。可即使是复制黏贴，我们依然觉得很麻烦，如果用命令行的方式来取代图形操作，我们就可以更懒一些了。回到主题，我本来打算写的webpack脚手架是基于这样的一个想法。➡️ 现在大部分的前端工程，webpack作为打包工具已经成了标配了。而 webpack 的配置是大同小异的，完全可以剥离出一个通用的webpack配置，然后针对个别配置进行修改。本次希望最终实现一个基于webpack适用于不同前端模板（React、Vue、ES+）的脚手架。现在脚手架有了，如何自动化去搭建一个项目呢？复制或下载脚手架模板。（为了更灵活，上传到GitHub，或发布npm中）。根据不同需求，在脚手架模板基础上重新配置webpack、package文件。安装依赖。以下代码可见GitHub。CLI 中的预备工作首先了解一下 #!。文件开头要加上#! /usr/bin/env node。在计算领域中，Shebang（也称为 Hashbang ）是一个由井号和叹号构成的字符序列 #! ，其出现在文本文件的第一行的前两个字符。 在文件中存在 Shebang 的情况下，类 Unix 操作系统的程序加载器会分析 Shebang 后的内容，将这些内容作为解释器指令，并调用该指令，并将载有 Shebang 的文件路径作为该解释器的参数。 ———— 维基百科使用 #!/usr/bin/env 脚本解释器名称 是一种常见的在不同平台上都能正确找到解释器的办法。 ———— 维基百科然后看看都用到了哪些东西（部分）。1npm install commander chalk fs-extra shelljs inquirer ora ejs --save12345678910111213#! /usr/bin/env node// multi-spa.jsconst program = require('commander'); // 解析命令;const chalk = require('chalk'); // 命令行界面输出美颜const fs = require('fs-extra'); // fs的拓展;const shell = require('shelljs'); // 重新包装了 child_process；const inquirer = require('inquirer'); // 交互式问答；const ora = require('ora'); // 输出样式美化；const ejs = require('ejs'); // 模版引擎；const path = require('path');const currentPath = process.cwd();let answersConfig = null;命令的解析类似与 Vue 的 vue init，我们也希望自己的 CLI 也能拥有类似的功能。1234// package.json "bin": &#123; "multi-spa-webpack": "./bin/multi-spa.js" &#125;,这样，我们就有了multi-spa-webpack的命令。如果我们想要全局使用，还需要执行下面命令。1npm link接下来就要初始化multi-spa-webpack相关的命令了。12345678910111213141516171819202122232425262728293031323334353637// multi-spa.jsprogram .command('init &lt;项目路径&gt; [选项]') .description('指令说明：初始化项目') .action(async (appName) =&gt; &#123; try &#123; let targetDir = path.resolve(currentPath, appName || '.'); if (fs.pathExistsSync(targetDir)) &#123; if (program.force) &#123; GenarateProject(appName); // 创建项目； &#125; ora(chalk.red(`！当前目录下，$&#123;appName&#125;已存在，请修改名称后重试`)).fail(); process.exit(1); &#125;; answersConfig = await getAnswers(appName); GenarateProject(appName); // 创建项目； &#125; catch (error) &#123; ora(chalk.red(`项目创建失败：$&#123;error&#125;`)).fail(); process.exit(1); &#125; &#125;);program .arguments('&lt;command&gt;') .action((cmd) =&gt; &#123; console.log(); console.log(chalk.red(`！命令未能解析 &lt;$&#123;chalk.green(cmd)&#125;&gt;`)); console.log(); program.outputHelp(); console.log(); &#125;);program.parse(process.argv);if (program.args.length === 0) &#123; console.log(); console.log(chalk.red('！输入的命令有误')); console.log(); chalk.cyan(program.help());&#125;复制或下载模板在执行multi-spa-webpack init spa-project后，就需要拷贝一份脚手架到本地了。至于脚手架从哪里来，可以放在 github 上（类似 Vue CLI）或 放在 CLI 对应的目录下（类似create-react-app）。本文是采用的是从 github 获取脚手架模板的。但是常规的方式，只能下载整个项目，而对于不需要的文件夹或文件，也会同时下载，下载后，只能在本地中删除无关文件了。我这里是从源头上剔除无关文件的下载，这个方法可能会有一些局限性吧（sparse-checkout）。不过两者最终的目的是一样的。12345678910111213141516171819202122232425262728293031323334// multi-spa.jsfunction DownTemplate(projectDir) &#123; const remote = 'https://github.com/yexiaochen/multi-spa-webpack-cli.git'; const &#123; template &#125; = answersConfig; let downTemplateSpinner = ora(chalk.cyan('模板下载中...')).start(); return new Promise((resolve, reject) =&gt; &#123; shell.exec(` mkdir $&#123;projectDir&#125; cd $&#123;projectDir&#125; git init git remote add -f origin $&#123;remote&#125; git config core.sparsecheckout true echo "template/common" &gt;&gt; .git/info/sparse-checkout echo "template/config" &gt;&gt; .git/info/sparse-checkout echo "template/services" &gt;&gt; .git/info/sparse-checkout echo "template/$&#123;template&#125;" &gt;&gt; .git/info/sparse-checkout echo ".gitignore" &gt;&gt; .git/info/sparse-checkout echo "package.json" &gt;&gt; .git/info/sparse-checkout git pull origin master rm -rf .git mv template/* ./ rm -rf template `, (error) =&gt; &#123; if (error) &#123; downTemplateSpinner.stop() ora(chalk.red(`模板下载失败：$&#123;error&#125;`)).fail() reject() &#125; downTemplateSpinner.stop(); ora(chalk.cyan('模板下载成功')).succeed(); resolve(); &#125;) &#125;)&#125;重新生成配置文件像 webpack、package 等配置文件，也都是包含在脚手架里的，不过这些配置还不能直接拿来用。我们还需要通过交互式问答，来针对性得在现有的基础上重新生成配置文件。1234567891011121314151617181920212223242526272829303132333435363738394041424344// multi-spa.jsfunction getAnswers(appName) &#123; const options = [ &#123; type: 'input', name: 'name', message: '项目名称', default: appName, &#125;, &#123; type: 'input', name: 'description', message: '项目描述', default: '单页面应用', &#125;, &#123; type: 'confirm', name: 'eslint', message: '是否启用 eslint+pretty', default: true &#125;, &#123; name: 'cssPreprocessor', type: 'list', message: 'CSS 预处理器', choices: [ "less", "sass", "none", ] &#125;, &#123; name: 'template', type: 'list', message: '选取模板', choices: [ "react", "vue", "es" ] &#125;, ]; return inquirer.prompt(options);&#125;在获得特定的需求后，还要把这些数据注入到配置文件中。就是通过模板引擎把数据塞到模板里。这里使用的是 ejs 模版引擎。123456&lt;!-- webpack.common.ejs --&gt;&lt;%= answers.cssPreprocessor == 'none' ? /\.css$/ : (answers.cssPreprocessor == 'less' ? /\.less$/ : /\.scss$/) %&gt;&lt;%= answers.cssPreprocessor == 'none' ? '' : (answers.cssPreprocessor == 'less' ? 'less-loader' : 'sass-loader') %&gt;1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// multi-spa.jsasync function GenarateWebpackConfig(targetDir) &#123; try &#123; const webpackConfigPath = path.resolve(`$&#123;currentPath&#125;/$&#123;targetDir&#125;/config`, 'webpack.common.ejs'); const webpackConfigTargetPath = path.resolve(`$&#123;currentPath&#125;/$&#123;targetDir&#125;/config`, 'webpack.common.js'); const webpackConfigSpinner = ora(chalk.cyan(`配置 webpack 文件...`)).start(); let webpackConfig = await fs.readFile(webpackConfigPath, 'utf8'); let generatedWebpackConfig = ejs.render(webpackConfig, &#123; answers: answersConfig &#125;); await Promise.all([ fs.writeFile(webpackConfigTargetPath, generatedWebpackConfig), fs.remove(webpackConfigPath) ]) webpackConfigSpinner.stop(); ora(chalk.cyan(`配置 webpack 完成`)).succeed(); &#125; catch (error) &#123; ora(chalk.red(`配置文件失败：$&#123;error&#125;`)).fail(); process.exit(1); &#125;&#125;async function GenaratePackageJson(projectDir) &#123; try &#123; const &#123; name, description, cssPreprocessor &#125; = answersConfig; const packageJsonPath = path.resolve(`$&#123;currentPath&#125;/$&#123;projectDir&#125;`, 'package.json'); const packageJsonSpinner = ora(chalk.cyan('配置 package.json 文件...')).start(); let package = await fs.readJson(packageJsonPath); package.name = name; package.description = description; if (cssPreprocessor == 'less') &#123; package.devDependencies = &#123; ...package.devDependencies, "less-loader": "^5.0.0" &#125; &#125; if (cssPreprocessor == 'sass') &#123; package.devDependencies = &#123; ...package.devDependencies, "node-sass": "^4.12.0", "sass-loader": "^7.1.0" &#125; &#125; await fs.writeJson(packageJsonPath, package, &#123; spaces: '\t' &#125;); packageJsonSpinner.stop(); ora(chalk.cyan('package.json 配置完成')).succeed(); &#125; catch (error) &#123; if (error) &#123; ora(chalk.red(`配置文件失败：$&#123;error&#125;`)).fail(); process.exit(1); &#125;; &#125;&#125;安装依赖其实配置文件生成后，CLI 就快接近尾声了。剩下就是安装依赖。12345678910111213141516171819// multi-spa.jsfunction InstallDependencies(targetDir) &#123; const installDependenciesSpinner = ora(chalk.cyan(`安装依赖中...`)).start(); return new Promise((resolve, reject) =&gt; &#123; shell.exec(` cd $&#123;targetDir&#125; npm i `, (error) =&gt; &#123; if (error) &#123; installDependenciesSpinner.stop() ora(chalk.red(`依赖安装失败：$&#123;error&#125;`)).fail() reject() &#125; installDependenciesSpinner.stop(); ora(chalk.cyan('依赖安装完成')).succeed(); resolve(); &#125;) &#125;)&#125;小结一个粗糙的CLI，就这么完成了。把以上几个方法包装一下，就是本次 CLI 的全部内容了。拷贝脚手架。2. 重新生成配置文件。3安装依赖。123456789async function GenarateProject(targetDir) &#123; await DownTemplate(targetDir); await Promise.all([GenaratePackageJson(targetDir).then(() =&gt; &#123; return InstallDependencies(targetDir); &#125;), GenarateWebpackConfig(targetDir) ]); ora(chalk.cyan('项目创建成功！')).succeed();&#125;如果想要发布，需要登陆npm ，npm publish。]]></content>
      <categories>
        <category>写着玩</category>
      </categories>
      <tags>
        <tag>Node</tag>
        <tag>CLI</tag>
        <tag>命令行界面</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[日常吐槽平时的项目中，很少会用到数据结构与算法的相关知识。作为学习进阶的一个环节，最终还是把数据结构与算法提上了日程。突然有种感觉，这次的学习可能是这一辈子最深入的一次吧😌列表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161/** * 描述： List：列表是一组有序的数据。 * 列表中的数据项称为元素，元素可以是任意数据类型 * @class **/class List &#123; constructor() &#123; /** 当前元素位置； * @type &#123;number&#125; * @private * **/ this.position = 0; /** 列表元素容器； * @type &#123;Array&#125; * @private * **/ this.dataStore = []; &#125; /** * 从列表中查找某个元素； * @protected * @params &#123;*&#125; element 待查找的元素； * @return &#123;number&#125; 元素位置； **/ find(element) &#123; return this.dataStore.indexOf(element); &#125; /** * 向列表中插入某个元素； * @protected * @params &#123;*&#125; element 待插入的元素； * @params &#123;*=&#125; pre 待插入位置的前一元素，可选； **/ insert(element, prev) &#123; let prevAt = this.find(prev); if (prevAt &gt; -1) &#123; this.dataStore.splice(prevAt, 0, element); &#125; else &#123; this.dataStore.push(element) &#125; &#125; /** * 从列表中删除某个元素； * @protected * @params &#123;*&#125; element 待删除的元素； **/ remove(element) &#123; let elementAt = this.find(element); if (elementAt &gt; -1) &#123; this.dataStore.splice(elementAt, 1) &#125; &#125; /** * 清空列表； * @protected **/ clear() &#123; this.dataStore.length = 0; &#125; /** * 第一个元素位置； * @protected **/ front() &#123; this.position = 0; &#125; /** * 最后一个元素位置； * @protected **/ end() &#123; this.position = this.dataStore.length - 1; &#125; /** * 前一个元素位置； * @protected **/ prev() &#123; --this.position; &#125; /** * 后一个元素位置； * @protected **/ next() &#123; if (this.position &lt; this.dataStore.length) &#123; ++this.position; &#125; &#125; /** * 将元素移到某个位置； * @params &#123;number&#125; positon 位置索引； * @protected **/ moveTo(position) &#123; this.position = position; &#125; /** *当前元素是否存在前一个元素； * @protected * @return &#123;boolean&#125; 是否存在； **/ hasNext() &#123; return this.position &lt; this.dataStore.length; &#125; /** * 当前元素是否存在下一个元素； * @protected * @return &#123;boolean&#125; 是否存在； **/ hasPrev() &#123; return this.position &gt;= 0; &#125; /** * 获取当前元素； * @protected * @return &#123;*&#125; 当前元素； **/ getElement() &#123; return this.dataStore[this.position] &#125; /** * 获取当前列表元素数； * @protected * @return &#123;number&#125; 当前列表长度； **/ length() &#123; return this.dataStore.length; &#125;&#125;let names = new List();names.insert('a');names.insert('b');names.insert('c');names.insert('d');names.front();names.next();names.next();names.prev();names.hasNext();names.moveTo(0);names.remove('c');for (names.front(); names.hasNext(); names.next()) &#123; console.log(names.getElement());&#125;栈1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/** * 描述： Stack：栈内的元素只能通过列表的一端访问，这一端称为栈顶。 * 栈被称为一种后入先出的数据结构。 * @class **/class Stack &#123; constructor() &#123; /** 栈元素容器； * @type &#123;Array&#125; * @private * **/ this.dataStore = []; &#125; /** * 查看栈顶元素； * @protected * @return &#123;*&#125; 栈顶元素； **/ peek() &#123; let topAt = this.dataStore.length - 1; return this.dataStore[topAt]; &#125; /** * 将元素压入栈； * @protected * @params &#123;*&#125; element 待压入栈的元素； **/ push(element) &#123; this.dataStore.push(element); &#125; /** * 将元素弹出栈； * @protected * @params &#123;*&#125; element 待弹出栈的元素； * @return &#123;*&#125; 弹出栈的元素； **/ pop() &#123; return this.dataStore.pop(); &#125; /** * 清空栈； **/ clear() &#123; this.dataStore.length = 0; &#125; /** * 获取当前栈元素数； * @protected * @return &#123;number&#125; 当前栈长度； **/ length() &#123; return this.dataStore.length; &#125;&#125;let names = new Stack();names.push('a');names.push('b');names.push('c');names.peek();names.clear();names.length();队列1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/** * 描述： Queue: 队列只能在队尾插入元素，队首删除元素。 * 队列是一种先进先出的数据结构。 * @class **/class Queue &#123; constructor() &#123; /** 队列元素容器； * @type &#123;Array&#125; * @private * **/ this.dataStore = []; &#125; /** * 查看队首元素； * @protected * @return &#123;*&#125; 队首元素； **/ head() &#123; let headAt = 0; return this.dataStore[headAt]; &#125; /** * 查看队尾元素； * @protected * @return &#123;*&#125; 队尾元素； **/ end() &#123; let endAt = this.dataStore.length - 1; return this.dataStore[endAt]; &#125; /** * 入队； * @protected **/ enqueue(element) &#123; this.dataStore.push(element) &#125; /** * 出队； * @protected **/ dequeue() &#123; return this.dataStore.shift(); &#125; /** * 清空队列； **/ clear() &#123; this.dataStore.length = 0; &#125; /** * 获取当前队列元素数； * @protected * @return &#123;number&#125; 当前队列长度； **/ length() &#123; return this.dataStore.length; &#125;&#125;let names = new Queue();names.enqueue('a');names.enqueue('b');names.enqueue('c');names.head();names.end();链表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122/** * 描述： 链表节点 * @class **/class Node &#123; constructor(element) &#123; /** 保存节点数据； * @type &#123;*&#125; * @private * **/ this.element = element; /** 保存指向下一个节点； * @type &#123;null&#125; * @private * **/ this.next = null &#125;&#125;/** * 描述： LinkList: 链表是由一组节点组成的集合。 * 每个节点使用一个对象的引用指向下一个节点。 * 指向另一个节点的引用叫做链 * @class **/class LinkList &#123; constructor() &#123; /** 头节点； * @type &#123;Objec&#125; * @private * **/ this.head = new Node('head'); &#125; /** * 查找节点； * params &#123;*&#125; element 节点元素； * @protected * @return &#123;Objec&#125; 节点； **/ find(element) &#123; let currentNode = this.head; while (currentNode &amp;&amp; currentNode.element != element) &#123; currentNode = currentNode.next; &#125; return currentNode; &#125; /** * 查找链表最后一个节点； * @protected * @return &#123;Objec&#125; 节点； **/ findLast() &#123; let currentNode = this.head; while (currentNode.next) &#123; currentNode = currentNode.next; &#125; return currentNode; &#125; /** * 插入节点； * params &#123;*&#125; element 待插入节点元素； * params &#123;*&#125; prevElement 上一个节点元素； * @protected * @return &#123;Objec&#125; 节点； **/ insert(element, prevElement) &#123; let currentNode = new Node(element); let prevNode = this.find(prevElement) || this.findLast(); currentNode.next = prevNode.next; prevNode.next = currentNode; &#125; /** * 查找上一个节点； * params &#123;*&#125; element 当前节点元素； * @protected * @return &#123;Objec&#125; 节点； **/ findPrev(element) &#123; let currentNode = this.head; while (currentNode.next &amp;&amp; currentNode.next.element != element) &#123; currentNode = currentNode.next; &#125; return currentNode; &#125; /** * 删除节点； * params &#123;*&#125; element 节点元素； * @protected **/ remove(element) &#123; let prevNode = this.findPrev(element); if (prevNode.next) &#123; prevNode.next = prevNode.next.next; &#125; &#125; /** * 展示链表； * params &#123;*&#125; element 当前节点元素； * @protected **/ display() &#123; let currentNode = this.head; while (currentNode.next) &#123; console.log(currentNode.next.element); currentNode = currentNode.next; &#125; &#125;&#125;let names = new LinkList();names.insert('a');names.insert('b');names.insert('c');names.remove('b');names.display();字典12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/** * 描述： Dictionary: 字典是一种以键-值对形式存储数据的数据结构。 * @class **/class Dictionary &#123; constructor() &#123; /** 字典容器； * @type &#123;Array&#125; * @private * **/ this.dataStore = &#123;&#125; &#125; /** * 向字典中添加键值对； * @params &#123;string&#125; key 字典的健； * @params &#123;*&#125; value 字典的值； * @protected **/ add(key, value) &#123; this.dataStore[key] = value; &#125; /** * 查找字典中元素； * @params &#123;string&#125; key 待查找的健； * @protected * @return &#123;number&#125; 代查找的值； **/ find(key) &#123; return this.dataStore[key]; &#125; /** * 删除字典中元素； * @params &#123;string&#125; key 待删除的健； * @protected **/ remove(key) &#123; delete this.dataStore[key]; &#125; /** * 清空字典中元素； * @protected **/ clear() &#123; Object.keys(this.dataStore).forEach(key =&gt; &#123; delete this.dataStore[key]; &#125;) &#125; /** * 展示字典中元素； * @protected **/ display() &#123; Object.keys(this.dataStore).forEach(key =&gt; &#123; console.log(`$&#123;key&#125;: $&#123;this.dataStore[key]&#125;`); &#125;) &#125;&#125;let names = new Dictionary();names.add('a', '1');names.add('b', 2);names.add('c', '3');names.remove('b');names.display();散列123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132/** * 描述： HashTable: 通过散列函数尽量将键均匀地映射到数组中。 * @class **/class HashTable &#123; constructor() &#123; /** 散列表容器； * @type &#123;Array&#125; * @private * **/ this.table = new Array(137); &#125; /** * 散列算法； * @params &#123;string&#125; str 待转换的字符，使用除留余数法； * @protected * @return &#123;number&#125; 转换后的值； **/ hashFunc(str) &#123; const H = 37; let total = 0; for (let i = 0; i &lt; str.length; i++) &#123; total += H * total + str.charCodeAt(i); &#125; total total = total % this.table.length; if (total &lt; 0) &#123; total += this.table.length + 1; &#125; return parseInt(total); &#125; /** * 将数据存入散列表； * @params &#123;string&#125; key 待存入数据的键； * @params &#123;string&#125; data 待存入的数据； * @protected **/ put(key, data) &#123; let position = this.hashFunc(key); this.table[position] = data; &#125; /** * 获取对应键的值； * @params &#123;string&#125; key 待取数据的键； * @protected * @return &#123;number&#125; 对应键的值； **/ get(key) &#123; let position = this.hashFunc(key); return this.table[position]; &#125; /** * 删除对应键的值； * @params &#123;string&#125; key 待删除数据的键； * @protected **/ remove(key) &#123; let position = this.hashFunc(key); delete this.table[position] &#125; /** * 展示散列表； **/ display() &#123; this.table.forEach((item, index) =&gt; &#123; if (item) &#123; console.log(item, index); &#125; &#125;) &#125; // 防止碰撞常用方法。碰撞：将两个键映射成同一个值的现象。 /* // 开链法；将数组元素展开为二维数组。 buildChains() &#123; for (let i = 0; i &lt; this.table.length; i++) &#123; this.table[i] = new Array(); &#125; &#125; put(key, data) &#123; let position = this.hashFunc(key); let index = 0; while (this.table[position][index] != undefined) &#123; index++; &#125; this.table[position][index] = key; this.table[position][index + 1] = data; &#125; get(key) &#123; let position = this.hashFunc(key); let index = 0; while (this.table[position][index] != key) &#123; if (index &gt; this.table[position].length) return; index++; &#125; return this.table[position][index + 1]; &#125; */ /* // 线性探测法；在附近的空位塞入数据。 values = []; put(key, data) &#123; let position = this.hashFunc(key); while (this.table[position] != undefined) &#123; position++; &#125; this.table[position] = key; this.values[position] = data &#125; get(key) &#123; let position = this.hashFunc(key); while (this.table[position] != key) &#123; if (position &gt; this.table.length) return; position++; &#125; return this.values[position] &#125; */&#125;let names = new HashTable();names.put('a', 1);names.put('b', 4);names.put('c', 112);names.put('d', 112);names.remove('b');names.display()集合123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128/** * 描述： Set: 集合是由一组无序但彼此之间又有一定相关性的成员构成，每个成员在集合中只能出现一次。 * @class **/class Set &#123; constructor() &#123; /** 集合容器； * @type &#123;Array&#125; * @private * **/ this.dataStore = []; &#125; /** * 添加成员； * @params &#123;*&#125; element 待添加的成员； * @protected * @return &#123;boolean&#125; 添加成功返回真否则返回假； **/ add(element) &#123; if (!this.dataStore.includes(element)) &#123; this.dataStore.push(element); return true; &#125; return false; &#125; /** * 删除成员； * @params &#123;*&#125; element 待删除的成员； * @protected * @return &#123;boolean&#125; 删除成功返回真否则返回假； **/ remove(element) &#123; let position = this.dataStore.indexOf(element); if (~position) &#123; this.dataStore.splice(position, 1); return true; &#125; return false; &#125; /** * 与其它集合的并集； * @params &#123;Set&#125; set 待合并的集合； * @protected * @return &#123;Set&#125; 合并后的集合； **/ union(set) &#123; let tempSet = new Set(); this.dataStore.forEach(element =&gt; &#123; tempSet.add(element); &#125;) set.dataStore.forEach(element =&gt; &#123; if (!tempSet.dataStore.includes(element)) &#123; tempSet.add(element); &#125; &#125;) return tempSet; &#125; /** * 交集； * @params &#123;Set&#125; set 其它集合； * @protected * @return &#123;Set&#125; 两集合共同存在成员组成的集合； **/ intersect(set) &#123; let tempSet = new Set(); this.dataStore.forEach(element =&gt; &#123; if (set.dataStore.includes(element)) &#123; tempSet.add(element); &#125; &#125;) return tempSet; &#125; /** * 补集 * @params &#123;Set&#125; set 其它集合； * @protected * @return &#123;Set&#125; 属于该集合而不属于其它集合的成员组成的集合； **/ difference(set) &#123; let tempSet = new Set(); this.dataStore.forEach(element =&gt; &#123; if (!set.dataStore.includes(element)) &#123; tempSet.add(element); &#125; &#125;) return tempSet; &#125; /** * 判断是否是其它集合子集； * @params &#123;Set&#125; set 其它集合； * @protected * @return &#123;boolean&#125; 是其它集合子集返回真否则返回假； **/ subset(set) &#123; if (this.dataStore.length &gt; set.dataStore.length) &#123; return false; &#125; else &#123; return !this.dataStore.find(element =&gt; set.dataStore.includes(element)) &#125; &#125; /** * 展示散列表； **/ display() &#123; this.dataStore.forEach((element, index) =&gt; &#123; if (element) &#123; console.log(element, index); &#125; &#125;) &#125;&#125;let names = new Set()names.add('a');names.add('b');names.add('c');names.remove('b');let names_1 = new Set();names_1.add('a');names_1.add('e');names.subset(names_1)二叉树和二叉查找树123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207/** * 描述： 树节点 * @class **/class Node &#123; constructor(data, left, right) &#123; /** 节点保存的数据； * @type &#123;*&#125; * @private * **/ this.data = data; /** 左节点； * @type &#123;Node&#125; * @private * **/ this.left = left; /** 右节点； * @type &#123;Node&#125; * @private * **/ this.right = right; &#125;&#125;/** * 描述：树是一种非线性的数据结构，以分层的方式存储数据。 * 树由一组以边连接的节点组成。 * 从一个节点到另一个节点的这一组边称为路径，以某种特定顺序访问树中所有的节点成为树的遍历。 * 二叉树子节点不超过两个。 * BST： 二叉查找树是一种特殊的二叉树，相对小的值保存在左节点中，较大的值保存在右节点中。 * @class **/class BST &#123; constructor() &#123; /** 根节点； * @type &#123;Node&#125; * @private * **/ this.root = null; &#125; /** * 向树中插入新节点； * @params &#123;*&#125; data 插入的数据； * @protected **/ insert(data) &#123; let n = new Node(data, null, null); if (this.root == null) &#123; this.root = n; &#125; else &#123; let current = this.root; let parent; while (true) &#123; parent = current; if (data &lt; current.data) &#123; current = current.left; if (current == null) &#123; parent.left = n; break; &#125; &#125; else &#123; current = current.right; if (current == null) &#123; parent.right = n; break; &#125; &#125; &#125; &#125; &#125; /** * 中序遍历； * @params &#123;Node&#125; node 遍历的根节点； * @protected **/ inOrder(node) &#123; if (node) &#123; this.inOrder(node.left); console.log(node.data); this.inOrder(node.right); &#125; &#125; /* // 先序遍历； preOrder(node) &#123; if (node) &#123; console.log(node.data); this.preOrder(node.left); this.preOrder(node.right); &#125; &#125; // 后序遍历； postOrder(node) &#123; if (node) &#123; this.postOrder(node.left); this.postOrder(node.right); console.log(node.data); &#125; &#125; */ /** * 获取最小值节点； * @params &#123;Node&#125; node 待查找的节点； * @protected * @return &#123;Node&#125; 拥有最小值的节点； **/ getMin(node) &#123; let current = node || this.root; while (current.left) &#123; current = current.left; &#125; return current; &#125; /** * 获取最大值节点； * @params &#123;Node&#125; node 待查找的节点； * @protected * @return &#123;Node&#125; 拥有最大值的节点； **/ getMax(node) &#123; let current = node || this.root; while (current.right) &#123; current = current.right; &#125; return current; &#125; /** * 查找指定数据的节点； * @params &#123;*&#125; data 待查找的数据； * @protected * @return &#123;Node&#125; 拥有指定数据的节点； **/ find(data) &#123; let current = this.root; while (current != null) &#123; if (current.data == data) &#123; return current; &#125; else if (data &lt; current.data) &#123; current = current.left; &#125; else &#123; current = current.right; &#125; &#125; return null; &#125; /** * 删除指定数据的节点； * @params &#123;*&#125; data 待删除的数据； * @protected **/ remove(data) &#123; let self = this; this.root = removeNode(this.root, data); function removeNode(node, data) &#123; if (node == null) return null; if (data == node.data) &#123; // 没有子节点； if (node.left == null &amp;&amp; node.right == null) &#123; return null; &#125; // 只有右节点； if (node.left == null) &#123; return node.right; &#125; // 只有左节点； if (node.right == null) &#123; return node.left; &#125; // 有左、右子节点； let tempNode = self.getMin(node.right); node.data = tempNode.data; node.right = removeNode(node.right, tempNode.data); /* // 或者左节点最大值； let tempNode = self.getMax(node.left); node.data = tempNode.data; node.left = removeNode(node.left, tempNode.data); */ return node; &#125; else if (data &lt; node.data) &#123; node.left = removeNode(node.left, data); return node; &#125; else &#123; node.right = removeNode(node.right, data); return node; &#125; &#125; &#125;&#125;let names = new BST();names.insert(12);names.insert(6);names.insert(18);names.insert(3);names.insert(9);names.insert(15);names.insert(21);names.inOrder(names.root);names.remove(6);图和图算法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495/** * 描述： Graph: 图由边的集合及顶点的集合组成。 * 邻接表或邻接表数组：将边存储为由顶点的相邻顶点列表构成的数组，并以此顶点作为索引。 * @class **/class Graph &#123; constructor(v) &#123; /** 顶点数； * @type &#123;number&#125; * @private * **/ this.vertices = v; /** 边数； * @type &#123;number&#125; * @private * **/ this.edges = 0; /** 邻接表数组； * @type &#123;Array&#125; * @private * **/ this.adj = Array.from(&#123; length: v &#125;).map(() =&gt; ([])); /** 顶点访问状态； * @type &#123;Array&#125; * @private * **/ this.marked = Array.from(&#123; length: v &#125;).map(() =&gt; (false)); &#125; /** * 添加顶点； * @params &#123;&#125; v 顶点； * @params &#123;&#125; w 顶点； * @protected **/ addEdge(v, w) &#123; this.adj[v].push(w); this.adj[w].push(v); this.edges++; &#125; /** * 深度优先搜索； * @params &#123;&#125; v 顶点； * @protected **/ dfs(v) &#123; this.marked[v] = true; // 打印遍历路径； if (!this.adj[v] != undefined) &#123; console.log('visted:', v); &#125; for (let vertex of this.adj[v]) &#123; if (!this.marked[vertex]) &#123; this.dfs(vertex); &#125; &#125; &#125; /** * 广度优先搜索； * @params &#123;&#125; v 顶点； * @protected **/ bfs(v) &#123; let queue = []; this.marked[v] = true; queue.push(v); while (queue.length &gt; 0) &#123; let v = queue.shift(); // 打印遍历路径； if (!this.adj[v] != undefined) &#123; console.log('visted:', v); &#125; for (let vertex of this.adj[v]) &#123; if (!this.marked[vertex]) &#123; this.marked[vertex] = true; queue.push(vertex); &#125; &#125; &#125; &#125;&#125;let names = new Graph(5);names.addEdge(0, 1);names.addEdge(0, 2);names.addEdge(1, 3);names.addEdge(2, 4);// names.dfs(0);names.bfs(0);]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅尝webpack]]></title>
    <url>%2F%E6%B5%85%E5%B0%9Dwebpack%2F</url>
    <content type="text"><![CDATA[吐槽一下webpack 自出现时，一直备受青睐。作为强大的打包工具，它只是出现在项目初始或优化的阶段。如果没有参与项目的构建，接触的机会几乎为零。即使是参与了，但也会因为项目的周期短，从网上东拼西凑草草了事。纵观网上的 webpack 教程，要么是蜻蜓点水，科普了一些常规配置项；要么是过于深入原理，于实际操作无益。最近一段时间，我把 webpack 的官方文档来来回回地看了几遍，结果发现，真香。中文版的官方文档，通俗易懂，很感谢翻译组的辛勤奉献。看完之后，虽然达不到炉火纯青的地步，但也不会捉襟见肘，疲于应付。对于这种工具类的博文，依然沿袭 用Type驯化JavaScript 的风格，串联各个概念。至于细节，就是官方文档的事了。本文基于 webpack v4.31.0 版本。TapableTapable 是一个小型的库，允许你对一个 javascript 模块添加和应用插件。它可以被继承或混入到其他模块中。类似于 NodeJS 的 EventEmitter 类，专注于自定义事件的触发和处理。除此之外，Tapable 还允许你通过回调函数的参数，访问事件的“触发者(emittee)”或“提供者(producer)”。tapable 是 webpack 的核心，webpack 中的很多对象（compile， compilation等）都扩展自tapable，包括 webpack 也是 tapable 的实例。扩展自 tapable 的对象内部会有很多钩子，它们贯穿了 webpack 构建的整个过程。我们可以利用这些钩子，在其被触发时，做一些我们想做的事情。抛开 webpack 不谈，先看看 tapable 的简单使用。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// Main.jsconst &#123; SyncHook&#125; = require("tapable");class Main &#123; constructor(options) &#123; this.hooks = &#123; init: new SyncHook(['init']) &#125;; this.plugins = options.plugins; this.init(); &#125; init() &#123; this.beforeInit(); if (Array.isArray(this.plugins)) &#123; this.plugins.forEach(plugin =&gt; &#123; plugin.apply(this); &#125;) &#125; this.hooks.init.call('初始化中。。。'); this.afterInit(); &#125; beforeInit() &#123; console.log('初始化前。。。'); &#125; afterInit() &#123; console.log('初始化后。。。'); &#125;&#125;module.exports = Main;// MyPlugin.jsclass MyPlugin &#123; apply(main) &#123; main.hooks.init.tap('MyPlugin', param =&gt; &#123; console.log('init 钩子，做些啥；', param); &#125;); &#125;&#125;;module.exports = MyPlugin;// index.jsconst Main = require('./Main');const MyPlugin = require('./MyPlugin');let myPlugin = new MyPlugin();new Main(&#123; plugins: [myPlugin] &#125;);// 初始化前。。。// init 钩子，做些啥; 初始化中。。。// 初始化后。。。理解起来很简单，就是在 init 处触发钩子，this.hooks.init.call(params) 类似于我们熟悉的 EventEmitter.emit(&#39;init&#39;, params)。main.hooks.init.tap 类似于 EventEmitter.on(&#39;init&#39;, callback)，在 init钩子上绑定一些我们想做的事情。在后面将要说的 webpack 自定义插件，就是在 webpack 中的某个钩子处，插入自定义的事。理清概念依赖图在单页面应用中，只要有一个入口文件，就可以把散落在项目下的各个文件整合到一起。何谓依赖，当前文件需要什么，什么就是当前文件的依赖。依赖引入的形式有如下：ES2015 import 语句CommonJS require() 语句AMD define 和 require 语句样式(url(...))或 HTML 文件(&lt;img src=...&gt;)中的图片链接入口(entry)入口起点(entry point)指示 webpack 应该使用哪个模块，来作为构建其内部依赖图（dependency graph）的开始。输出(output)output 属性告诉 webpack 在哪里输出它所创建的 bundle，以及如何命名这些文件。模块(module)决定了如何处理项目中的不同类型的模块。比如设置 loader，处理各种模块。设置 noParse，忽略无需 webpack 解析的模块。解析(resolve)设置模块如何被解析。引用依赖时，需要知道依赖间的路径关系，应遵循何种解析规则。比如给路径设置别名（alias），解析模块的搜索目录（modules），解析 loader 包路径（resolveLoader）等。外部扩展(externals)防止将某些 import 的包（package）打包到 bundle 中，而是在运行时（runtime）再去从外部获取这些扩展依赖。比如说，项目中引用了 jQuery 的CDN资源，在使用 import $ from &#39;jquery&#39;;时，webpack 会把 jQuery 打包进 bundle，其实这是没有必要的，此时需要配置 externals: {jquery: &#39;jQuery&#39;}，将其剔除 bundle。插件(plugins)用于以各种方式自定义 webpack 构建过程。可以利用 webpack 中的钩子，做些优化或者搞些小动作。开发设置(devServer)顾名思义，就是开发时用到的选项。比如，开发服务根路径（contentBase），模块热替换（hot，需配合 HotModuleReplacementPlugin 使用），代理（proxy）等。模式(mode)提供 mode 配置选项，告知 webpack 使用相应环境的内置优化。具体可见 模式(mode)优化(optimization)从 webpack 4 开始，会根据你选择的 mode 来执行不同的优化，不过所有的优化还是可以手动配置和重写。比如，CommonsChunkPlugin被 optimization.splitChunks 取代。webpack 差不多就是这几个配置项，搞清楚这几个概念，上手还是比较容易的。代码分离现在的前端项目越来越复杂，如果最终导出为一个 bundle，会极大地影响加载速度。切割 bundle，控制资源加载优先级，按需加载或并行加载，合理应用就会大大缩短加载时间。官方文档提供了三种常见的代码分离方法：入口起点配置多个入口文件，然后将最终生成的过个 bundle 出入到 HTML 中。12345678910111213// webpack.config.jsentry: &#123; index: './src/index.js', vendor: './src/vendor.js'&#125;output: &#123; filename: '[name].bundle.js',&#125;,plugins: [new HtmlWebpackPlugin(&#123; chunks: ['vendor', 'index']&#125;)]不过如果这两个文件中存在相同的模块，这就意味着相同的模块被加载了两次。此时，我们就需要提取出重复的模块。防止重复在 webpack 老的版本中，CommonsChunkPlugin 常用来提取公共的模块。新版本中 SplitChunksPlugin 取而代之，可以通过 optimization.splitChunks 设置，多见于多页面应用。动态导入就是在需要时再去加载模块，而不是一股脑的全部加载。webpack 还提供了预取和预加载的方式。非入口 chunk，我们可以通过 chunkFilename 为其命名。常见的如，vue 路由动态导入。12345678// webpack.config.jsoutput: &#123; chunkFilename: '[name].bundle.js',&#125;// index.jsimport(/* webpackChunkName: "someJs" */ 'someJs');import(/* webpackPrefetch: true */ 'someJs');import(/* webpackPreload: true */ 'someJs');缓存基于浏览器的缓存策略，我们知道如果本地缓存命中，则无需再次请求资源。对于改动不频繁或基本不会再做改动的模块，可以剥离出来。1234// webpack.config.jsoutput: &#123; filename: '[name].[contenthash].js',&#125;按照我们的想法，只要模块的内容没有变化，对应的名字也就不会发生变化，这样缓存就会起作用了。事实上并非如此，webpack 打包后的文件，并非只有用户自己的代码，还包括管理用户代码的代码，如 runtime 和 manifest。模块依赖间的整合并不是简单的代码拼接，其中包括模块的加载和解析逻辑。注入的 runtime 和 manifest 在每次构建后都会发生变化。这就导致了即使用户代码没有变化，某些 hash 还是发生了改变。通过 optimization.runtimeChunk 提取 runtime 代码。通过 optimization.splitChunks 剥离第三方库。比如， react，react-dom。123456789101112131415module.exports = &#123; //... optimization: &#123; runtimeChunk: 'single', splitChunks: &#123; cacheGroups: &#123; vendor: &#123; test: /[\\/]node_modules[\\/](react|react-dom)[\\/]/, name: 'vendor', chunks: 'all', &#125; &#125; &#125; &#125;&#125;;最后使用 HashedModuleIdsPlugin 来消除因模块 ID 变动带来的影响。loaderloader 用于对模块的源代码进行转换。loader 是导出为一个函数的 node 模块。该函数在 loader 转换资源的时候调用。给定的函数将调用 loader API，并通过 this 上下文访问。123456789101112131415161718192021// loader API;this.callback( err: Error | null, content: string | Buffer, sourceMap?: SourceMap, meta?: any);// sync loadermodule.exports = function(content, map, meta)&#123; this.callback(null, syncOperation(content, map, meta)); return;&#125;// async loadermodule.exports = function(content, map, meta)&#123; let callback = this.async(); asyncOperation(content, (error, result) =&gt; &#123; if(error) callback(error); callback(null, result, map, meta); return; &#125;)&#125;多个 loader 串行时，在从右向左执行 loader 之前，会向从左到右调用 loader 上的 pitch 方法。如果在 pitch 中返回了结果，则会跳过后续 loader。12345678910111213|- a-loader `pitch` |- b-loader `pitch` |- c-loader `pitch` |- requested module is picked up as a dependency |- c-loader normal execution |- b-loader normal execution|- a-loader normal execution&lt;!-- pitch 中返回结果 --&gt;|- a-loader `pitch` |- b-loader `pitch` returns a module|- a-loader normal executionpluginswebpack 的自定义插件和本文开头 Tapable 中的差不多。webpack 插件是一个具有 apply 方法的 JavaScript 对象。apply 方法会被 webpack compiler 调用，并且 compiler 对象可在整个编译生命周期访问。钩子有同步的，也有异步的，这需要根据 webpack 提供的 API 文档。1234567891011121314151617181920212223242526// 官方例子class FileListPlugin &#123; apply(compiler) &#123; // emit 是异步 hook，使用 tapAsync 触及它，还可以使用 tapPromise/tap(同步) compiler.hooks.emit.tapAsync('FileListPlugin', (compilation, callback) =&gt; &#123; // 在生成文件中，创建一个头部字符串： var filelist = 'In this build:\n\n'; // 遍历所有编译过的资源文件， // 对于每个文件名称，都添加一行内容。 for (var filename in compilation.assets) &#123; filelist += '- ' + filename + '\n'; &#125; // 将这个列表作为一个新的文件资源，插入到 webpack 构建中： compilation.assets['filelist.md'] = &#123; source: function() &#123; return filelist; &#125;, size: function() &#123; return filelist.length; &#125; &#125;; callback(); &#125;); &#125;&#125;module.exports = FileListPlugin;ProvidePlugin自动加载模块，无需处处引用。有点类似 expose-loader。123456// webpack.config.jsnew webpack.ProvidePlugin(&#123; $: 'jquery',&#125;)// some.js$('#item');DllPlugin将基础模块打包进动态链接库，当依赖的模块存在于动态链接库中时，无需再次打包，而是直接从动态链接库中获取。DLLPlugin 负责打包出动态链接库，DllReferencePlugin 负责从主要配置文件中引入 DllPlugin 插件打包好的动态链接库文件。1234567891011121314151617181920// webpack-dll-config.js// 先执行该配置文件output: &#123; path: path.join(__dirname, "dist"), filename: "MyDll.[name].js", library: "[name]_[hash]"&#125;,plugins: [ new webpack.DllPlugin(&#123; path: path.join(__dirname, "dist", "[name]-manifest.json"), name: "[name]_[hash]" &#125;)]// webpack-config.js// 后执行该配置文件plugins: [ new webpack.DllReferencePlugin(&#123; manifest: require("../dll/dist/alpha-manifest.json") &#125;),]HappyPack启动子进程处理任务，充分利用资源。不过进程间的通讯比较耗资源，要酌情处理。123456789101112const HappyPack = require('happypack');// loader&#123; test: /\.js$/, use: ['happypack/loader?id=babel'], exclude: path.resolve(__dirname, 'node_modules'),&#125;,// pluginsnew HappyPack(&#123; id: 'babel', loaders: ['babel-loader?cacheDirectory'],&#125;),webpack-bundle-analyzerwebpack 打包后的分析工具。webpack 告一段落，浅尝辄止。]]></content>
      <categories>
        <category>写着玩</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读《你的孤独，虽败犹荣》]]></title>
    <url>%2F%E3%80%8A%E4%BD%A0%E7%9A%84%E5%AD%A4%E7%8B%AC%EF%BC%8C%E8%99%BD%E8%B4%A5%E7%8A%B9%E8%8D%A3%E3%80%8B%E6%91%98%E6%8A%84%2F</url>
    <content type="text"><![CDATA[读后感《你的孤独，虽败犹荣》，这本书买回来已经很久了。花了一两个月读了前一半，却只用了几个小时读完了后一半，有时候不得不说，自己对自己太任性了。昨晚出去散步时，我说，回去后，我要把那本书读完。我哥一脸诧异，表示不敢相信，毕竟一半的内容不算少。回来后，戴上耳机，随手把罗扎夫加入了播放列表。并不是我想营造一个读书的氛围，只是为了隔绝外面的世界。几个小时后，我说，我看完了。我哥是一脸震惊，不知道是因为我做到了，还是因为吃鸡过程中突然暴毙而没回过味来。这本书算是作者的一个心路历程吧，看完成之后，唏嘘不已。有共情，才会有感概，故事的人和事，似曾相识，不过这一切都已成了回忆。回过头来再想一想，这样，真的好么？语录孤独是自己居然就能成一个世界。有一种孤独是明知道结局是曲终人散，可当下却不得不放声大笑，直至在这样的尽兴中流下眼泪。我们嘲笑过少年的无知，也嘲笑过岁月的苍老。我们行走在路上，理想宏大，眼窝却浅显。有时候我们说很多话，并不是想得到热切的回应，而是只要有人愿意听，愿意帮我们记住，就够了。回忆就像女儿红一般被埋在土里，偶尔想起来挖两锹土，都会醉倒半死。一群人怀旧，就着往事下酒，睫毛上满是青翠的湿气，饱含垂延欲滴的温柔。有人拼命挣脱，终为无谓。有人放任飘洒，终成无畏。有一种孤独是与志同道合的人定下目标，没皮没脸地往前冲，等到离光明不远的时候，你扭头一看，却发现志同道合的人已经不见了。人与人擦肩时，往往会投来短暂且善意的眼光，你以为对方只是在浅显地打量，但对方表达的确实友善的“你好”。你伸出手，便能并肩行走。你错过，便再无下文。有一种孤独是突然想到一个人，却发现已经没有了对方的联系方式。那些你曾以为很要好的朋友，那些你曾以为会一直结伴走下去的人，不知道何时就在路途中走散了。陪你走了一程的朋友，谢谢他们。愿陪你走一生的朋友，谢谢老天。有些人在你面前，你很难说一声谢谢。然而他们离开之后，你却有千言万语想说给自己听，或者也希望，有一天他能够看见。就是这么一种人，进入你生命的时候并不让人欢天喜地，他们却能够在离开你之后，让你一直想念，万语千言。有一种孤独是原以为找一个与自己分享痛苦的人很难，后来发现找一个能分享自己喜悦的人更难。和一些人的关系像平行线，一辈子相守相望，见于眼底藏于心间。就怕耐不住寂寞，冲动而成了相交线，在一个点尽情拥抱，从此便离得越来越远，再也不见。遇见这样的人，因为不想做恋人只能一时，所以才选择做朋友能一世。有些不疼，是早已愈合，提起来只有伤疤，没了感受。有些不疼，是几近麻木，感受爱的能力全都用来感受痛了。你要相信自己强大的愈合能力，即使心里有刺，不拔出来，也会随着时间而最终消失。有一种孤独是我知道你爱我，我也知道我爱你，但我无法用准确的语言让你明白我内心的感受，即使我说了，你也不能理解。我们是人类，但却不是一类人。有一种孤独是很多闭上眼能回忆起的温度、对话、举动、细节，睁开眼却感觉它们从未发生过一样。擦肩而过，再无交集的孤独。借秋微的小说《莫失莫忘》中的一句话：世间最大的遗憾是我们能好好地开始，却没能好好地告别。成年与未成年最大的区别或许是我们开始越来越爱深夜，而只把冷静留给白天。人与人之间的关系，常常从熟悉、到误解，从分离到释怀。释怀似乎才是最终认识自己和理解别人的方式。当时想不明白的原因和愤怒转身而去的情节，都会随着成长而渐渐释怀。释怀不是不再生气，也不是没有感情，而是面对曾经最熟悉的那个人还能问上一句： 你还好吗？你以为做的一切都是为了身边最亲近的人，后来你才知道最亲近的人最需要你做的只是你在身边。有一种孤独是与最亲近的那个人面对的时间和空间里，一直在质疑，而当你转身离开，却瞬间意识到自己的过错。有一种孤独是即使你做了错事，爱你的人却一直说没关系，连弥补的机会都不会给你。有些爱就是错了一次之后，便希望用一生的努力去弥补。越是亲近的人，越是有些话说不出口，也许我们都知道，很多事情都已经过去了，再大的伤害都不能阻止我们现在的感情如何的亲密，只是，如果你真的爱一个人的话，你总是希望能用自己的方式去弥补过去时光里造成的伤害——无论对方现在是否还需要。亲近的人永远把话藏在心底，却用行动告诉全世界自己很在意。有一种孤独是小时候觉得顺其自然的事情，稍微大了之后认为那是按部就班，直到有一天你才发现一切所剩无几、无能为力，只能且行且珍惜。有一种孤独是如果自己忍受了委屈，便能让一切都好转起来，于是选择了闭嘴。没有人注意到你的改变，没有人走进过你的内心，外界越是平和，越是人声鼎沸，你心里的委屈越大、孤独越深。一开始埋下的孤独的种子，在一个人反复的自我回答中，长大成人。你不好了，他们会失落，他们会用尽全力保护你。你好了，他们也会失落，他们觉得自己的能力已经保护不了你了。有一片这样的海，一扇能如此推开的窗，一身被晒得爽朗的肤色，更重要的是，有一个能陪我一起分享一切的人。很多人，有了一切却没有那个人。很多人，有了那个人，却为了追求一片海，最后丢掉了那个人。当对事情感到绝望时，你可以放弃对他人的信任，可以放弃外界对自己的评价，可以放弃对结果的企盼，唯独不能放弃的是内心的平静。只有回归平静，甘于寂寞，不怕枯燥，才能重新听回自己的心跳声。无论你未来身处混沌还是迷途，保持自在安宁是破除任何困局的最大武器。给自己一些时间，一切终会有答案。既然看不清未来，何不把握好现在。拽在手中的，始终会跟着你跑不掉，放飞于空中的，一不留神，便不知飘向何方。曾经迷茫，如今释怀开阔。当下迷茫，却对未来笃定希望。这其中，便是时间和物是人非的成长。有些日子，只记得事，因事想人。有些日子，却记得人，因人而记事。一些人对我们做了一些事，有人只当是日常生活中的无心之举，有人却能读出一个轮回的历史。一些温暖，能让你在自己身上发光发热，传给他人。一些伤害，也能让你亮出胳膊，提醒自己何谓底线。我们常问为什么，沉下来，看一切，我们就是答案。有种孤独是极力挣脱随波逐流的自己，尝试做一些不合群的举动，一开始总会被人误解，经过这样的孤独，才有真正与别人不一样的底气。“如果你未来想在这个行业中出头的话，你觉得要具备什么条件？”“待的时间比别人更长？资历比其他人更老？”当我说出这样的答案时，浑身不寒而栗。不知从什么时候开始，我已经把人生翻盘的决定权完完全全交给了时间。每个人的人生只能自己负责，别人的意见顶多只是参考而已。如果一个人一辈子只能重复同样的一天，那该是世界上最寂寞的事情吧。这些年，见惯了彼此伤害，也曾经被亲近的人抓住七寸反击，总以为受的伤够多了，就不会在跌倒了。现实却是为了每一次的投入而付出更隐秘的自己，于是又换来一批更新的伤口。一个人的坚强不是看他外壳有多硬，而是看他的伤疤有多深。最终，我们把自己磨砺成不害怕伤害，却开始害怕一种创可贴式的关怀。有时，柔软或许比强大更具力量吧。有的人可笑，是因为愚蠢。有的人可笑，是因为执着。而且我相信，只有当你明白自己的时间并不如想象得那么多的时候，你才会对出现在生命中的任何事物如此挑剔。原谅我只有一光年的宽度，只允许你在我生命中走一程的距离，能走多远都可以，但不能重复地走来走去。有些人的好像埋在地下的酒，总是要经过很久，离开之后，才能被人知道。剩下饮酒的人只能寂寞独饮至天明。最遥远的距离是人还在，情还在，回去的路已不在。有人说有结果的付出叫付出，没结果的付出叫代价。其实人在年轻的时候无论有没有结果，都要去付出，除此之外好像也没有什么别的选择。因为知道了不要盲目至追求结果，所以变得开始不着急，把所有的着眼点都放在了每一次的当下，只有对自己的每一次行动负责，才会获一个美好的结果。道理对不对不是最重要的，态度对了才是最重要的。我们可以选择不说真话，但一定不能说假话。不说真话，可以有自己的态度；说假话，则失去一个人处世的原则。有一种孤独是当大多数人不赞同我时，你却偏偏站在我这一方。第一瞬不是感动，而是觉得我怎能让你变得和我一样的孤独，而后才有满满的感动。少数人的温暖，也是一种心照不宣的孤独。“当我讨厌一个人的时候，如果这个人突然说喜欢我，那我就一点也不讨厌对方了。就是这么有原则，无法讨厌一个有眼光的人。”有一种孤独是四周的一切都暗下去，看不清周遭，先是恐惧，然后归于平静。这时，突然可以听清空气的流动，开始看得清自己过去的每一步。这种自省的孤独，胜过一切的鼓励。低谷，这个词若出现在现在，证明你已停止前进。若你坚持爬坡，这个词一定会出现在你的回忆的时光里。一个人的时候或许并不孤独，置身于热闹人群中，才愈发孤独。因为一座城而爱上一个人不是没有可能。有时你会重新爱上一座城，也许只是你曾在这里遇到过几个陌生人。]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>你的孤独，虽败犹荣</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客升级为PWA]]></title>
    <url>%2FHexo%E5%8D%9A%E5%AE%A2%E5%8D%87%E7%BA%A7%E4%B8%BAPWA%2F</url>
    <content type="text"><![CDATA[渐进式网络应用程序（英语：Progressive Web Apps，简称：PWA）是一种普通网页或网站架构起来的网络应用程序，但它可以以传统应用程序或原生移动应用程序形式展示给用户。这种应用程序形态视图将目前最为现代化的浏览器提供的功能与移动设备的体验优势相结合。———— 维基百科PWA 诞生已久，被赋予了 Web 应用和原生应用的特性，具备渐进式、可搜索、可离线、可安装、可链接、安全等优势。PWA 不是一种技术，而是一系列关键技术构成了 PWA。如，Web APP Manifest，Service Worker，Push Notification等。（本文不讨论 Push Notification）让一个传统的网页升级为 PWA ，是一件很容易的事。现以本博客为例，将其打造为 PWA。（本博客没过 https 这关， 😅😅😅）步骤一：Web APP ManifestWeb APP Manifest ，在 JSON 文本中提供应用程序相关的信息。包括自定义名称，自定义图标设置启动网址等。manifest 的目的是将 Web 应用程序安装到设备的主屏幕。1234567891011121314151617181920212223242526272829303132// manifest.json&#123; "name": "夜曉宸", "short_name": "夜曉宸", "icons": [&#123; "src": "/images/favicon-96.png", "sizes": "96x96" &#125;,&#123; "src": "/images/favicon-128.png", "sizes": "128x128" &#125;, &#123; "src": "/images/favicon-144.png", "sizes": "144x144" &#125;, &#123; "src": "/images/favicon-152.png", "sizes": "152x152" &#125;, &#123; "src": "/images/favicon-192.png", "sizes": "192x192" &#125;, &#123; "src": "/images/favicon-256.png", "sizes": "256x256" &#125;, &#123; "src": "/images/favicon-512.png", "sizes": "512x512" &#125;], "start_url": "/", "display": "fullscreen", "background_color": "#f5f5f5", "theme_color": "#f5f5f5", "scope": "/"&#125;定义好 manifest.json 文件后，需要在 HTML 头部引入。1&lt;link rel="manifest" href="/manifest.json"&gt;步骤二：Service WorkerService Worker 是 PWA 的核心技术，充当着浏览器和网络之间的代理，或应用程序与浏览器之间的代理服务器。旨在统筹资源缓存和对自定义网络请求进行控制。Service Worker 运行在一个与JavaScript 主线程独立的线程上，并且没有对 DOM 结构的任何反问权限。并且可以在不同的上下文之间发送和接收信息，可分配给 Service Worker 任务，并在使用基于 Promise 的方法当任务完成时接收结果。service worker 有自己的生命周期，我们要做的是在不同的状态下对资源采用不同的策略（缓存，不缓存，优先缓存，优先网络等）。1234567891011// sw.js// 安装之后完成触发；this.addEventListener('install', function(event) &#123; event.waitUntil(// 安装完成之前需要执行的代码； caches.open('v1').then(function(cache) &#123;// caches API; return cache.addAll([ // 需要缓存的资源列表; '/lib/jQuery.min.js' ]); &#125;));&#125;);service worker 安装完成后，如果已存在旧版本正在使用，则不会激活，直到旧版本停用。如果旧版本的某些资源无需存在，可以在 activate 阶段将其删除。123456789101112// sw.jsself.addEventListener('activate', function(event) &#123; var cacheWhitelist = ['v2']; event.waitUntil( caches.keys().then(function(keyList) &#123; return Promise.all(keyList.map(function(key) &#123; if (cacheWhitelist.indexOf(key) === -1) &#123; return caches.delete(key); &#125;&#125;)); &#125;); );&#125;);既然是充当代理，拦截请求就很重要了。对请求的资源如何控制将会在这里处理。1234567891011121314151617// sw.js// 匹配到资源，则返回；// 没有匹配到资源，则从服务器请求资源，并缓存资源；// 没有网络时，则返回默认的资源；this.addEventListener('fetch', function(event) &#123; event.respondWith( caches.match(event.request).then(function(response) &#123; return response || fetch(event.request).then(function(response) &#123; return caches.open('v1').then(function(cache) &#123; cache.put(event.request, response.clone()); return response; &#125;);&#125;); &#125;).catch(function() &#123; return caches.match('/default.jpg'); &#125;); );&#125;);service worker 要做的事情基本就这些（都写在 sw.js 里了），接下来就是注册 service worker。12345678910// app.js if ('serviceWorker' in navigator) &#123; navigator.serviceWorker.register('/sw-test/sw.js', &#123; scope: '/sw-test/' &#125;).then(function(reg) &#123; // registration worked console.log('Registration succeeded. Scope is ' + reg.scope); &#125;).catch(function(error) &#123; // registration failed console.log('Registration failed with ' + error); &#125;); &#125;到此基本完成了一个可安装、可离线的 Web APP。还记得步骤一的可安装么？安装提示一般会按照一定的规则弹出的，如果我们希望主动引导用户安装呢？首先把 beforeinstallprompt 里的事件保存起来，在一个恰当的时机触发。12345678910111213141516 //app.js// 把 event 存起來var installPromptEvent;window.addEventListener('beforeinstallprompt', function (e) &#123; e.preventDefault() installPromptEvent = e if (installPromptEvent.prompt) &#123; document.querySelector('#install').addEventListener('click', addToHomeScreen); &#125;&#125;);function addToHomeScreen(e) &#123; if (installPromptEvent) &#123; installPromptEvent.prompt() installPromptEvent = null &#125;&#125;步骤三：检测你的 PWA完成 PWA 的构建后，我们可以利用 Chrome 的开发者工具 Audits 工具检测，针对 PWA，会有相关的提示建议。workbox在 PWA 中， service worker 是关键，而缓存策略又是重中之重。对于请求的资源是否缓存，又以怎样的形式返回。如果关照到广度和粒度，估计会很麻烦。Google 为开发者量身打造了 workbox。常见的缓存策略：CacheFirst，CacheOnly，NetworkFirst，NetworkOnly，StaleWhileRevalidate。StaleWhileRevalidateCache First (Cache Falling Back to Network)Network Only1234567891011121314151617181920// 官方示例（部分）// Cache the Google Fonts stylesheets with a stale-while-revalidate strategy.workbox.routing.registerRoute( /^https:\/\/fonts\.googleapis\.com/, new workbox.strategies.StaleWhileRevalidate(&#123; cacheName: 'google-fonts-stylesheets', &#125;));workbox.routing.registerRoute( /\.(?:png|gif|jpg|jpeg|webp|svg)$/, new workbox.strategies.CacheFirst(&#123; cacheName: 'images', plugins: [ new workbox.expiration.Plugin(&#123; maxEntries: 60, maxAgeSeconds: 30 * 24 * 60 * 60, // 30 Days &#125;), ], &#125;));]]></content>
      <categories>
        <category>写着玩</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>PWA</tag>
        <tag>渐进式网络应用程序</tag>
        <tag>workbox</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于MVVM模式简单代码实现]]></title>
    <url>%2F%E5%85%B3%E4%BA%8EMVVM%E6%A8%A1%E5%BC%8F%E7%AE%80%E5%8D%95%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[在写 关于MVC模式简单代码实现 的过程中，觉得最麻烦的就是操作 DOM。所以这次升级了，打算用 React。用过 React 的同学都知道，React 在更新视图时，必须要通过 setState 方式改变状态，这一过程是需要我们主动调用的。而 Vue 是通过对 data 下的变量赋值直接更新了视图，Vue 之所以这么简单，是因为采用了数据劫持的方式。所以，这次的目的就是在 React 的基础上实现和 Vue 类似的效果。实现思路就是利用高阶组件里的反向继承对包裹组件的 state 劫持。这是一个练手的小项目，没考虑那么多。为什么这么闲呢，那是因为之前写了 用Type驯化JavaScript 这篇文章，所以就捣鼓出这么一个玩意。所有代码可见github12345678910111213141516171819202122232425262728293031323334// Mvvm.tsxconst hocExtends = (WrapperComponent: ComponentClass) =&gt; ( class extends WrapperComponent &#123; constructor(props: any) &#123; super(props); &#125; render() &#123; let self = this; this.state = new Proxy(&#123; ...this.state &#125;, &#123; get: function (target, key, receiver) &#123; return Reflect.get(target, key, receiver); &#125;, set: function (target, key, value, receiver): any &#123; self.setState(&#123; [key]: value &#125;) return Reflect.set(target, key, value, receiver); &#125; &#125;) return super.render() &#125; &#125;)......filterSearchStuff(searchStuff: string): void &#123; const &#123; stuffData &#125; = this.state; let stuffItem: IStuff = stuffData.find((item: IStuff) =&gt; item.stuff === searchStuff) this.state.stuffItem = stuffItem; // this.setState(&#123; // stuffItem // &#125;) &#125;......]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>MVVM</tag>
        <tag>TypeScript</tag>
        <tag>react</tag>
        <tag>高阶组件</tag>
        <tag>反向继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用Type驯化JavaScript]]></title>
    <url>%2F%E7%94%A8Type%E9%A9%AF%E5%8C%96JavaScript%2F</url>
    <content type="text"><![CDATA[TypeScript 具有类型系统，且是 JavaScript 的超集。它可以编译成普通的 JavaScript 代码。TypeScript 支持任意浏览器，任意环境，任意系统并且是开源的。作为弱类型、动态型语言，JavaScript 就像未驯化的野马一样。每个人都能上去坐两下，但是真正能够驾驭的只能是个中好手。近几年，前端经历了快速的发展已经不再是以前随便玩玩的小玩意了。面对越来越大型、越来越持久的项目来说，这种宽松的方式反而成了阻碍。东西做大了，随之而来的就是各种规矩规矩是从经验中总结，同时也是为了朝更好的方向发展，就比如编程里的设计原则和设计模式。「Man maketh manners」，记得王牌特工里，主角们在教育别人的时候总喜欢说这么一句话，「不知礼，无以立也」。在 TypeScript 里，「礼」就是 Type，Type 就是规矩。Typescript 通过类型注解提供编译时的静态类型检查，提前发现错误，同时也提高了代码的可读性和可维护性。TypeScript 里的类型注解是一种轻量级的为函数或变量添加约束的方式在 JavaScript 里，变量用于在特定时间存储特定值，其值及数据类型可以在脚本的生命周期内改变。而在 TypeScript 中，标识符（变量、函数、类、属性的名字，或者函数参数）在其定义时就指定了类型（或类型推论出）。在编译阶段，若出现了期望之外的类型，TypeScript 将会提示抛错（虽然有时候并不会影响程序的正常运行）。在 TypeScript 中，通过 : 类型 的方式为标识符添加类型注解。1234567891011121314151617let isDone: boolean = false; // boolean；let decLiteral: number = 6; // number；let name: string = "bob"; // string；let list: number[] = [1, 2, 3]; // Array&lt;number&gt;;let list: Array&lt;number&gt; = [1, 2, 3]; // Array&lt;number&gt;;let x: [string, number]; // tuple;enum Color &#123;Red, Green, Blue&#125; // enum;let notSure: any = 4; // any;function warnUser(): void &#123; // void; console.log("This is my warning message");&#125;let u: undefined = undefined; // undefined;let n: null = null; // null;function error(message: string): never &#123; // never; throw new Error(message);&#125;let obj: object = &#123;&#125;; // object在 TypeScript 中，数组（Array）是合并了相同类型的对象，而元组（tuple）合并了不同类型的对象。（Array&lt;any&gt;,也可以合并不同类型的数据）类型注解中的类型就是以上的那些类型么？TypeScript 的核心原则之一是对值所具有的结构进行类型检查，它有时被称做「鸭式辨型法」或「结构性子类型化」。上面的只是基础类型，它们是填充结构的基本单位而已。在 TypeScript 里，类型不应该还停留在 JavaScript 数据类型的层面上，还应包括基础类型的组合结构化。1234567891011let str: 'Hello'; // 字符串字面量类型；str = 'Hi' // error；let something: 'Hello' | 1; // 联合类型；something = 1 // ok；let obj: &#123;name: string, age: number&#125;; // 对象字面量obj = &#123; name: "夜曉宸", age: 18,&#125;换句话说，在定义标识符的时候，用一个类型模板来描述标识符的结构和内部类型组成。即类型模板就是标识符期望的样子。代码是给人看的，顺便是给机器运行的都说好的代码就该这样。但是在 TypeScript 里，这两句话可以颠倒下顺序。代码是给机器运行的，顺便是给人看的。在谈到 TypeScript 的好处时，有一条很重要，增强了编译器和 IDE 的功能，包括代码补全、接口提示、跳转到定义、重构等。而这些也得益于标识符的类型的精确划分或表述，所以想写好 Typescript 代码，就应该精确描述标识符的类型，而不是随处安放的 any。表述复杂结构最常用的方式 ———— 接口接口是 JavaScript 中没有的东西，是一个非常灵活的概念，可以抽象行为，也可以描述「对象的形状」。对于需要复用的结构类型，就可以使用接口的方式，而不是对象字面量内联式注解。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566interface Iperson &#123; // 对象 name: string, age: number, sayHi(): void,&#125;let obj: Iperson = &#123; name: "夜曉宸", age: 18, sayHi: ()=&gt; &#123;&#125;&#125;/* ——————人工分割线—————— */interface Iperson &#123; // 函数类型 (name: string, age: number): string&#125;let person: Iperson = (name, age) =&gt; &#123; return `$&#123;name&#125;,$&#123;age&#125;`&#125;person('夜曉宸', 18);/* ——————人工分割线—————— */interface Iperson &#123; // 构造函数 new (name: string, age: number)&#125;let person: Iperson = class Person &#123; name: string; age: number; constructor(name, age) &#123; this.name = name; this.age = age; &#125;&#125;new person('夜曉宸', 18);/* ——————人工分割线—————— */interface Iperson &#123; // 类实现接口 name: string, age: number,&#125;class Person implements Iperson&#123; name = '夜曉宸' age = 18&#125;new Person()/* ——————人工分割线—————— */interface Iperson &#123; // 混合类型 (name, age): string, age: number,&#125;function Person(): Iperson &#123; let me = &lt;Iperson&gt;function (name, age): string &#123; return `$&#123;name&#125;, $&#123;age&#125;` &#125; me.age = 18; return me;&#125;let person = Person();person('夜曉宸', 18)person.age以上是接口在对象、普通函数、构造函数、类上的表现。对于接口的属性，还可以做到精确控制，如可选属性、任意属性、只读属性等。最后，接口间可以继承，接口还可以继承类。当接口继承类时，它会继承类的成员但不包括其实现，但是若继承了拥有私有或受保护的成员类时，这个接口只能由这个类或其子类来实现了，这个和类的访问修饰符的特点有关系。说完接口，就要说说类了，因为它们有多相似的地方，比如充当对象的类型模板，继承成员等。类到底是什么呢？ES6 引入了 Class（类）这个概念，通过 class 关键字，可以定义类, Class 实质上是 JavaScript 现有的基于原型的继承的语法糖. Class 可以通过extends关键字实现继承。TypeScript 除了实现了所有 ES6 中的类的功能以外，还添加了一些新的用法。12345678910111213141516171819class Person &#123; static age: number = 18; constructor(public name: string, public age: number) &#123; &#125; sayHi(name: string): string&#123; return `Hi,$&#123;name&#125;` &#125;&#125;/* —————— 人工分割线 —————— */var Person = /** @class */ (function () &#123; function Person(name, age) &#123; this.name = name; this.age = age; &#125; Person.prototype.sayHi = function (name) &#123; return "Hi," + name; &#125;; Person.age = 18; return Person;&#125;());TypeScript 编译后，可以看出来，类其实就是一个函数而已。在 ES6 之前，通过构造函数的方式 new 出对象，造出的对象拥有和共享了构造函数内部绑定的属性方法及原型上的属性方法。TypeScript 里的接口描述的类类型就是类的实例部分应该遵循的类型模板。作为类的静态部分 ———— 构造函数，函数也应该有自己的属性特征。12345678910111213141516171819interface static_person &#123; age: number, new (name: string, age: number);&#125;interface instance_person &#123; name: string, age: number, say(name: string): string&#125;let person: static_person = class Person implements instance_person&#123; static age: number = 18; constructor(public name: string, public age: number) &#123; &#125; say(name) &#123; return `Hi,$&#123;name&#125;` &#125;&#125;new person('夜曉宸',18)由以上代码可以看出，类的静态部分和动态部分都有各自的类型模板。若是想要将类自身作为类型模板又该如何做呢？最简单的方法就是 typeof 类 的方式。123456789101112131415class Person &#123; static age: number = 18; constructor(public name: string, public age: number) &#123;&#125; say(name) &#123; return `Hi,$&#123;name&#125;` &#125;&#125;class Man &#123; static age: number; constructor(public name: string, public age: number) &#123;&#125; public sex = 'man'; say(name)&#123;return `Hi, $&#123;this.sex&#125;,$&#123;name&#125;`&#125;&#125;let man: typeof Person = Man;new man('夜曉宸', 18)类静态部分、类实例部分和类自身，它们都有自己需要遵循的类型模板。知道了其中的区别，也就能更好得理解类作为接口使用、接口继承类等用法了。12345678910111213class Person &#123; name: string; age: number;&#125;interface Man extends Person &#123; sex: 'man'&#125;let man: Man = &#123; name: '夜曉宸', age: 18, sex: 'man'&#125;除了结构上的约束，类也通过访问修饰符对其成员做了约束，包括 public，private，protected，readonly等。1234567891011121314class Person &#123; private name: string; protected age: number;&#125;interface SayPerson extends Person &#123; sayHi(): string&#125;class Human extends Person implements SayPerson &#123; sayHi() &#123; return `Hi, $&#123;this.age&#125;` &#125;&#125;知道了访问修饰符的特点，也就明白之前说过的「当接口继承类时，它会继承类的成员但不包括其实现，但是若继承了拥有私有或受保护的成员类时，这个接口只能由这个类或其子类来实现了」。如果一个标识符的类型不确定，该如何？对于一个内部逻辑相差不大，入參类型不同的函数来说，没必要因为参数类型不同而重复大部分代码，这时就需要一个类型变量来代替。1234567891011121314151617181920212223242526272829/* 范型函数 */class Person &#123; className = 'person'&#125;class Human &#123; classname = 'human'&#125;function create&lt;T&gt;(Class: new () =&gt; T) : T&#123; return new Class();&#125;create(Person).className/* 范型接口 */interface Creat&lt;T&gt;&#123; (Class: new () =&gt; T):T&#125;class Person &#123; className = 'person'&#125;class Human &#123; classname = 'human'&#125;function create&lt;T&gt;(Class: new () =&gt; T) : T&#123; return new Class();&#125;let person: Creat&lt;Person&gt; = create;person(Person) // OKperson(Human) // Error注意了，类型变量表示的是类型，而不是值。类型变量里塞的可能是任意一个类型，但根据场景，我们最好能够更加精确的描述标识符的类型。应了上面的一句话，「想写好 Typescript 代码，就应该精确描述标识符的类型，而不是随处安放的 any」。所以对于泛型，我们也可以做些约束，即，泛型约束。12345678910111213141516class Person &#123; name: string; age: number;&#125;interface Man extends Person &#123; sex: 'man'&#125;function getProperty&lt;T, K extends keyof T&gt;(obj: T, key: K): any &#123; return obj[key]&#125;let man: Man = &#123; name: '夜曉宸', age: 18, sex: 'man'&#125;getProperty(man, 'sex')用类型变量来注释标识符的类型有时会觉得还是不够精确。知道标识符的可能类型，然后组合起来123456789101112131415161718192021222324252627282930313233class Man &#123; name: string; age: number; study():string &#123;return ''&#125;&#125;class Women &#123; name: string; age: number; sing():string&#123;return ''&#125; &#125;function instance(Class: Man | Women) &#123; if ((&lt;Man&gt;Class).study) &#123; return (&lt;Man&gt;Class).study() &#125; else &#123; return (&lt;Women&gt;Class).sing() &#125;&#125;let man:Man = &#123; name: '夜曉宸', age: 18, study() &#123; return '我爱学习'; &#125;&#125;let women: Women = &#123; name: 'godness', age: 17, sing() &#123; return '我爱唱歌' &#125;&#125;instance(man) // 我爱学习instance(women) // 我爱唱歌有交叉类型、联合类型等，而类型命名则是更灵活的类型组织方式。123456789101112// 官网🌰type Name = string;type NameResolver = () =&gt; string;type NameOrResolver = Name | NameResolver;function getName(n: NameOrResolver): Name &#123; if (typeof n === 'string') &#123; return n; &#125; else &#123; return n(); &#125;&#125;类型多了之后，有时候需要对某一类型做特别处理，于是有类型断言 （&lt;类型&gt;） 和类型守卫（typeof, instanceof, in等）。还可以通过条件判断来选择哪种类型。1234// 官网🌰declare function f&lt;T extends boolean&gt;(x: T): T extends true ? string : number;// Type is 'string | numberlet x = f(Math.random() &lt; 0.5)当然了，以上代码好多的标识符是没有必要添加类型注解的。类型推断，即，类型是在哪里如何被推断的类型注解也不是越多越好，即使有些地方你不添加类型注解，TypeScript 也会通过上下文归类等方式找到最佳通用类型。]]></content>
      <categories>
        <category>这个想法不一定对</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随手记（一）]]></title>
    <url>%2F%E9%9A%8F%E6%89%8B%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[NET::ERR_CERT_DATE_INVALID描述：开发环境，接口请求转 https，Chrome 开发者工具控制台报错 ## NET::ERR_CERT_DATE_INVALID。解决方案：Chrome HSTS异常导致无法访问HTTPS网页涉及点：List of Chrome URLs、hstsChrome插件本地导出描述：由于某些原因，Chrome 应用商店无法浏览。对已下载的 Chrome 插件导出安装。解决方案：地址栏输入 chrome://extensions/, 开启开发者模式，打开待导出插件的详细信息，记录扩展程序 ID。地址栏输入 chrome://version/, 记录个人资料路径。扩展程序路径即为：个人资料路径 + ‘Extensions’ + 扩张程序 ID。终端进入拓展程序路径目录，目录下还有扩展程序的对应版本目录，记录扩展程序版本目录。回到扩展程序详情页，点击打包程序，输入扩展程序版本目录并点击打包扩展程序。进入扩展程序路径，拷贝 crx 格式文件即可。（ prm 为密钥文件）涉及点：无Cookie、跨域请求、请求方式描述：不同的请求方式（fetch、axios等）跨域请求时，是否主动携带 Cookie解决方案：Cookie的设置、读取以及是否自动携带问题涉及点：Fetch、XMLHttpRequestgithub 资源下载慢描述：GitHub clone 开源项目，国内下载资源慢可能解决方案：简单有效的方法是，修改 host 文件，添加 192.30.253.112 github.com。本地开发环境获取 Cookie描述：后端服务部署到测试环境时，本地开发无法获取非同域名下的 Cookie解决方案：修改 host 文件，DNS 解析，IP 映射到相应的子域名下。123456sudo vi /etc/hosts# hosts文件# 比如测试地址 test.domain.com127.0.0.1 local.domain.com]]></content>
      <categories>
        <category>开发三两事</category>
      </categories>
      <tags>
        <tag>随手记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读懂UML类图]]></title>
    <url>%2F%E8%AF%BB%E6%87%82UML%E7%B1%BB%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[类的描述在面向对象编程，类是一种面向对象计算机编程语言的构造，是创建对象的蓝图，描述了所创建的对象共同的属性和方法。类的更严格的定义是由某种特定的元数据所组成的内聚的包。它描述了一些对象的行为规则，而这些对象就被称为该类的实例。类有接口和结构。接口描述了如何通过方法与类及其实例互操作，而结构描述了一个实例中数据如何划分为多个属性。类是与某个层的对象的最具体的类型。类还可以有运行时表示形式（元对象），它为操作与类相关的元数据提供了运行时支持。类的UML表示类图是面向对象系统建模中最常用和最重要的图，主要是用来显示系统中的类、接口以及它们之间的静态结构和关系的一种静态模型。类图描述一类的属性和操作，也对系统的约束。类图显示集合的类，接口，关联，协作和约束，它也被称为作为结构图。在类的UML图中，使用长方形描述一个类的主要构成，长方形垂直地分为三层，分别放置类的名称、属性和方法。第一部分是类名。第二部分是类的属性：即类的成员变量，类的性质。表示方式为：可见性 名称：类型 [= 缺省值]可见性表示该属性对于类外的元素是否可见，包括共有（public）、私有（private）和受保护（protected），在类图中分别表示为 +、- 和 #。类型表示属性的数据类型。缺省值表示属性的初始值，可选。第三部分是类的方法：即类的成员方法，操作或行为。表示方式为：可见性 名称（参数列表）[: 返回值]。可见性同类的属性。参数列表表示方法的参数，多个参数之间用逗号隔开。返回类型表示方法返回值类型，可选。类图常见关系在UML类图中，常见的有以下几种关系:泛化（Generalization）, 实现（Realization）,组合(Composition)，聚合（Aggregation）,关联（Association）,依赖(Dependency)。泛化（Generalization）：是父类与子类之间的关系，描述的是 is a king of(is a)的关系。表现为继承非抽象类。实现（Realization）：是类与接口的关系，表示为类是接口所有特征和行为的实现。表现为继承抽象类。组合(Composition)：是类之间整体与部分的关系。在组合关系中，整体对象负责成员对象的创建以及生命周期，即当整体对象被销毁时成员对象也会不复存在。聚合（Aggregation）：是类之间整体与部分的关系。在聚合关系中，成员对象是整体对象的一部分，但是成员对象可以脱离整体对象独立存在。关联（Association）：是类之间的结构关系，用于表示一类对象与另一类对象之间有联系。关联关系默认是双向的，表示相互知道，也可以单向关联、自关联、多重性关联。依赖(Dependency)：是描述一个对象在运行期间会用到另一个对象的关系（使用关系），通常在运行期间产生，并且随着运行时的变化，依赖关系也可能发生变换。各种关系的强弱顺序：泛化 = 实现 &gt; 组合 &gt; 聚合 &gt; 关联 &gt; 依赖]]></content>
      <categories>
        <category>写着玩</category>
      </categories>
      <tags>
        <tag>UML类图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DIP、IoC、DI、JS]]></title>
    <url>%2FDIP%E3%80%81IoC%E3%80%81DI%E3%80%81JS%2F</url>
    <content type="text"><![CDATA[在这个标题中，除了 JS 是乱入之外，其它的几个词汇都是存在一个共同点的，那就是依赖。那么，依赖是什么呢？比如，现在我正在写这篇博客文，但是我得在电脑上编辑，电脑便是我完成这件事的依赖。而在代码中，最直观的体现是模块之间的依赖。如某个模块依赖另外一个模块，那么另外的那个模块就是该模块的依赖。其实在上篇博客文章《JaVaScript中的模块》中，我们也手写了一个模块依赖管理器。依赖这个理解起来很简单，但这不代表可以随意的依赖。在写模块的时候，讲究个高内聚低耦合，以提高模块的可拓展性和可维护性。模块依赖了谁，怎么去依赖，都关乎了最终模块的好与坏。还好在编程界有着提高代码质量的金科玉律，我们可以用理论来指导实践，写出更好的代码。依赖反转原则依赖反转原则（Dependency inversion principle，DIP），是一种特定的解耦形式，使得高层次的模块不依赖于低层次的模块的实现细节，依赖关系被颠倒（反转），从而使得低层次模块依赖于高层次模块的需求抽象。———— 维基百科该原则规定：高层次的模块不应该依赖与低层次的模块，两者都应该依赖于抽象接口。抽象接口不应该依赖于具体实现。而具体实现则应该依赖于抽象接口。现在用一个例子来解释一波。1234567891011121314151617181920// Ajax.jsclass Ajax &#123; get() &#123; return this.constructor.name; &#125;&#125;export default Ajax;// main.jsimport Ajax from './Ajax';class Main &#123; constructor() &#123; this.render() &#125; render() &#123; let content = (new Ajax()).get(); console.log('content from', content); &#125;&#125;new Main();刚开始的时候，我们基于 XMLHttpRequest 对象，封装了 Ajax 用于请求数据。后来 fetch 出来了，我们打算跟上时代的脚步，封装 fetch 以取代 Ajax。1234567891011121314151617181920// Fetch.jsclass Fetch &#123; fetch() &#123; return this.constructor.name; &#125;&#125;export default Fetch;// main.jsimport Fetch from './Fetch';class Main &#123; constructor() &#123; this.render(); &#125; render() &#123; let content = (new Fetch()).fetch(); console.log('content from', content); &#125;&#125;new Main();从以上可以看出来，整个替代过程很麻烦，我们需要找出封装请求模块（Ajax、Fetch）的所有引用，然后替换掉。又由于 Ajax、Fetch 的方法命名也是不同，所以也需要对应地做更改。这就是传统的处理依赖关系的方式。在这里 Main 是高层次模块，Ajax、Fetch 是低层次模块。依赖关系创建于高层次模块，且高层次模块直接依赖低层次模块，这种依赖关系限制了高层次模块的复用性。依赖反转原则则颠倒这种依赖关系，并以上面提到的两个规定作为指导思想。12345678910111213141516171819202122232425// Service.jsclass Service &#123; request()&#123; throw `$&#123;this.constructor.name&#125; 没有实现 request 方法！` &#125;&#125;class Ajax extends Service &#123; request()&#123; return this.constructor.name; &#125;&#125;export default Ajax;// Main.jsimport Service from './Service.js';class Main &#123; constructor() &#123; this.render(); &#125; render() &#123; let content = (new Service).request(); console.log('content from', content); &#125;&#125;new Main();在这里我们把共同依赖的 Service 作为抽象接口，它就是高层次模块与低层次模块需要共同遵守的契约。在高层次模块中，它会默认 Service 会有 request 方法用来请求数据。在低层次模块中，它会遵从 Service 复写应该存在的方法。这在《在JavaScript中尝试组合模式》中，无论分支对象还是叶对象都实现 expense() 方法的道理差不多。即使后来需要封装 axios 取代 fetch，我们也只需要在 Service.js 中修改即可。再次回顾下传统的依赖关系。依赖关系创建于高层次模块，且高层次模块直接依赖低层次模块。经过以上的折腾，我们充其量只是解决了高层次模块直接依赖低层次模块的问题。那么依赖关系创建于高层次模块的问题呢？控制反转如果说依赖反转原则告诉我们该依赖谁，那么控制反转则告诉们谁应该来控制依赖。像上面的 Main 模块，它依赖 Service 模块。为了获得 Service 实例的引用，Main 在内部靠自身 new 出了一个 Service 实例。这样明显地引用其它模块，无异加大了模块间的耦合。控制反转（Inversion of Control，IoC），通过控制反转，对象在被创建的时候，有一个控制系统内所有对象的外界实体，将其所依赖的对象的引用传递给它。可以说，依赖被注入到对象中。———— 维基百科这些话的意思就是将依赖对象的创建和绑定转移到被依赖对象类的外部来实现。实现控制反转最常见的方式是依赖注入，还有一种方式依赖查找。依赖注入依赖注入（Dependency Injection，DI），在软件工程中，依赖注入是种实现控制反转用于解决依赖性设计模式。一个依赖关系指的是可被利用的一种对象（即服务提供端）。依赖注入是将所依赖的传递给将使用的从属对象（即客户端）。该服务将会变成客户端的状态的一部分。传递服务给客户端，而非允许客户端来建立或寻找服务，是本设计模式的基本要求。没看懂？没关系。这句话讲的是，把过程放在外面，将结果带入内部。在《JaVaScript中的模块》中，我们已经用到过依赖注入，就是对于依赖模块的模块，则把依赖作为参数使用。所以我们再次改造下，123456789101112131415161718192021222324252627282930// Service.jsclass Service &#123; request() &#123; throw `$&#123;this.constructor.name&#125; 没有实现 request 方法！` &#125;&#125;class Ajax extends Service &#123; request() &#123; return this.constructor.name; &#125;&#125;export default Ajax;// Main.jsclass Main &#123; constructor(options) &#123; this.Service = options.Service; this.render(); &#125; render() &#123; let content = this.Service.request(); console.log('content from', content); &#125;&#125;export default Main;// index.jsimport Service from './Service.js';import Main from './Main.js';new Main(&#123; Service: new Service()&#125;)在 Main 模块中, Service 的实例化是在外部完成，并在 index.js 中注入。相比上一次，改动后的代码并没有看出带来多大的好处。如果我们再增加一个模块呢？123456789class Router &#123; constructor() &#123; this.init(); &#125; init() &#123; console.log('Router::init') &#125;&#125;export default Router;12345678# Main.js+ this.Service = options.Router;# index.js+ import Router from './Router.js' new Main(&#123;+ Router: new Service() &#125;)若是内部实例化就不好处理了。可换成依赖注入后，这个问题就很好解决了。1234567891011121314151617181920212223242526272829303132// utils.jsexport const toOptions = params =&gt; Object.entries(params).reduce((accumulator, currentValue) =&gt; &#123; accumulator[currentValue[0]] = new currentValue[1]() return accumulator; &#125;, &#123;&#125;);// Main.jsclass Main &#123; constructor(options) &#123; Object.assign(this, options); this.render(); &#125; render() &#123; let content = this.Service.request(); console.log('content from', content); &#125;&#125;export default Main;// index.jsimport Service from './Service.js';import Router from './Router.js';import Main from './Main.js';import &#123; toOptions &#125; from './utils.js'/** * toOptions 转换成参数形式 * @params &#123;Object&#125; 类 * @return &#123;Object&#125; &#123;Service: Service实例, Router: Router实例&#125; */const options = toOptions(&#123;Service, Router&#125;);new Main(options);因为依赖注入把依赖的引用从外部引入，所以这里使用 Object.assign(this, options) 方式，把依赖全部加到了 this 上。即使再增加模块，也只需要在 index.js 中引入即可。到了这里，DIP、IoC、DI 的概念应该有个清晰的认识了。然后我们再结合实际，加个功能再次巩固一下。作为一功能个独立的模块，一般都有个初始化的过程。现在我们要做的是遵守一个初始化的约定，定义一个抽象接口，1234567891011121314151617181920212223242526// Interface.jsexport class Service &#123; request() &#123; throw `$&#123;this.constructor.name&#125; 没有实现 request 方法！` &#125;&#125;export class Init &#123; init() &#123; throw `$&#123;this.constructor.name&#125; 没有实现 init 方法！` &#125;&#125;// Service.jsimport &#123; Init, Service &#125; from './Interface.js';import &#123; mix &#125; from './utils.js'class Ajax extends mix(Init, Service) &#123; constructor() &#123; super(); &#125; init() &#123; console.log('Service::init') &#125; request() &#123; return this.constructor.name; &#125;&#125;export default Ajax;Main、Service、Router 都依赖 Init 接口（在这里就是一种协定），Service 模块比较特殊，所以做了 Mixin 处理。要做到统一初始化，Main 还需要做些事。12345678910111213141516171819// Main.jsimport &#123; Init &#125; from './Interface.js'class Main extends Init &#123; constructor(options) &#123; super(); Object.assign(this, options); this.options = options; this.render(); &#125; init() &#123; (Object.values(this.options)).map(item =&gt; item.init()); console.log('Main::init'); &#125; render() &#123; let content = this.Service.request(); console.log('content from', content); &#125;&#125;export default Main;至此，结束123456789101112131415161718192021222324// index.jsimport Service from './Service.js';import Router from './Router.js';import Main from './Main.js';import &#123; toOptions &#125; from './utils.js'/** * toOptions * 转换成参数形式 * @params &#123;Object&#125; 类 * @return &#123;Object&#125; * &#123; * Service: Service实例, * Router: Router实例 * &#125; */const options = toOptions(&#123; Service, Router &#125;);(new Main(options)).init();// content from Ajax// Service::init// Router::init// Main::init（以上所有示例可见GitHub）]]></content>
      <categories>
        <category>这个想法不一定对</category>
      </categories>
      <tags>
        <tag>DIP</tag>
        <tag>Ioc</tag>
        <tag>DI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JaVaScript中的模块]]></title>
    <url>%2FJaVaScript%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[模块在 JavaScript 中，模块只不过是基于函数某些特性的代码组织方式。在《你不知道的 JavaScript》中，给出了模块模式因具备的两个必要条件：必须有外部的封闭函数，该函数必须至少被调用一次（每次调用都会创建一个新的模块实例）。封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。从中我们可以看到一个比较重要的一点，从函数调用所返回的只有数据属性而没有闭包函数的对象并不是真正的模块。你看👀，理解闭包的重要性再次体现出来了。从以上要求的两点来看，只要满足相应的条件，我们很容易写出一个模块。123456789101112131415161718192021const userModule = ((name = 'module') =&gt; &#123; let id = 1,moduleName = name; const sayName = () =&gt; &#123; console.log('moduleName: %s', moduleName); &#125;; const sayId = () =&gt; &#123; console.log('id: %s', id); &#125;; const changeName = value =&gt; &#123; moduleName = value; &#125;; const changePublicAPI = () =&gt; &#123; publicAPI.sayIdentification = sayId &#125;; const publicAPI = &#123; sayIdentification: sayName, changeName, changePublicAPI, &#125; return publicAPI;&#125;)();以上在满足两个必要的基础上转换成了 IIFE（立即执行函数表达式）。同时可以看出，基于函数的模块可以在运行时通过内部保留着公共 API 对象的引用，从而对模块实例进行修改。模块机制模块的出现也是为了能够提高代码的复用率，方便代码管理。复用模块，自然会出现模块依赖的问题，所以说我们需要一个管理模块依赖的模块。1234567891011121314151617181920212223242526272829303132333435const moduleManage = (() =&gt; &#123; let modules = &#123;&#125;; const define = (name, deps, module) =&gt; &#123; deps = deps.map(item =&gt; modules[item]) modules[name] = module(...deps); &#125;; const exports = (name) =&gt; &#123; return modules[name]; &#125; return &#123; define, exports, &#125;&#125;)();moduleManage.define('a', [], () =&gt; &#123; const sayName = name =&gt; &#123; console.log('name: %s', name); &#125;; return &#123; sayName, &#125;&#125;);moduleManage.define('b', ['a'], (a) =&gt; &#123; let name = 'b'; const sayName = () =&gt; &#123; a.sayName(name) &#125;; return &#123; sayName, &#125;&#125;);var b = moduleManage.exports('b');b.sayName();模块依赖管理器也依然是个模块，这里的实现其实很简单。modules[name] = module(...deps)，使用 modules 缓存各个模块，对于依赖模块的模块，则把依赖作为参数使用。规范CommonJS 规范服务于服务端，同步阻塞，在写法风格上是依赖就近。但是在浏览器上，CommonJS 就不好使了，浏览器需要从服务器请求数据，下载完成后才会有下一步的执行。如果采用 CommonJS 的同步方式，指不定什么时候文件才会下载完成。为了推广到浏览器上，AMD 规范采用异步方式加载模块。先异步加载模块，加载完成后就可以在回调中使用依赖模块了。这样就保证了在使用依赖时，依赖已经加载完成。AMD 规范是早早地下载，早早地执行，在回调里 require 的是依赖的引用。在写法风格上是依赖前置，这种风格已经不同于 CommonJS 了。还有，这里早早地执行会带来一个问题，如果存在某个依赖某些条件不成立，导致没有用上。那么，这里的早早地执行岂不是多此一举了？CMD 规范是 sea.js 推崇的规范，它采用的也是异步加载模块的方式，只是在依赖模块的执行时机上有所不同。在写法风格上，又回归到 CommonJS，依赖就近。sea.js 是早早地下载，延迟执行。到了 ES6，终于从语法上支持模块化了，ES6 模块是编译时加载，使得在编译时就能确定模块的依赖关系，而且在将来服务器和浏览器都会支持 ES6 的模块化方案。]]></content>
      <categories>
        <category>这个想法不一定对</category>
      </categories>
      <tags>
        <tag>模块化</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异步的JavaScript（生成器篇）]]></title>
    <url>%2F%E5%BC%82%E6%AD%A5%E7%9A%84JavaScript%EF%BC%88%E7%BB%88%E7%AF%87%EF%BC%89%2F</url>
    <content type="text"><![CDATA[回顾所谓的异步，就是程序的一部分现在进行，而另一部分则在将来运行。异步处理的重点就是如何处理将来运行的那一部分。回调是 JavaScript 中最基本的异步模式，就是事先约定好将来要做的事然后回头调用。简单直接，但也存在不信任、调用嵌套过深等问题。对于编写代码、维护代码的我们而言，人类的大脑还是习惯于线性的处理方式。基于回调的异步模式所存在的问题促使着我们寻求一种机制来保证回调的可信任，同时能更好的表达异步。这时候 Promise 出现了，Promise 的出现，并非要取代回调。而是把回调转交给了一个位于我们和其它工具之间的可信任的中介机制。Promise 链也提供（尽管并不完美）以顺序的方式表达异步流的一个更好的方法，这有助于我们的大脑更好地计划和维护异步 JavaScript 代码。生成器Promise 虽然有序、可靠地管理回调，但是我们还是希望如同步般表达异步。我们已经知道生成器是作为生产迭代器的工厂函数，同时我们还要知道生成器也是一个消息传递系统。为什么是生成器在生成器出现之前，程序代码一旦执行，就没有停下来的时候，直到程序结束🔚。然而在生成器里代码是可以暂停的，而且还可以和生成器之外通信☎️，通信结束后又可以恢复执行。回想一下之前的异步流程控制，我们一直在想方设法使得异步任务能够同步表达。现在，我们可以借助生成器来实现这一想法💡。了解了生成器的特性之后，我们就应该知道，当生成器在执行一个异步任务时，完全可以把异步任务放在生成器外部执行，待异步任务执行结束后再返回🔙生成器恢复执行。要知道，生成器暂停的只是内部的状态，程序的其余部分还是正常运行的。这样的话，生成器内部的所有代码看起来都是同步表达了。同时我们也要注意到，生成器不过是一种新🆕的表达方式，和异步还是同步没有半毛钱💰关系。既然没有关系，那在异步模式选择上就更无所谓了。考虑到异步系列文章是渐进式的，所以我们就用 Promise + 生成器 模式来表达异步。生成器与Promise的结合在异步流程控制方面，生成器是由两部分组成的。一部分是生成器内部代码以同步的方式表达任务，另一部分是由生成器生成的迭代器处理异步。12345678910111213141516171819202122232425262728293031323334const async = n =&gt; &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; resolve(`第$&#123;n&#125;个异步任务`) &#125;, 0); &#125;)&#125;;const generator = function *generator()&#123; const response_1 = yield async(1); const response_2 = yield async(2); const response_3 = yield async(3); console.log('response_1: %s;response_2: %s;response_3: %s;',response_1,response_2,response_3);&#125;;const gen = generator();const gen_1 = generator();console.log('gen_next_1: %s; gen_next_2: %s; gen_next_3: %s;', gen_1.next().value, gen_1.next().value, gen_1.next().value);gen.next().value.then(yield_1 =&gt; &#123; console.log('yield_1: %s;', yield_1); return gen.next(yield_1).value.then(yield_2 =&gt; &#123; console.log('yield_2: %s;', yield_2) return gen.next(yield_2).value.then(yield_3 =&gt; &#123; console.log('yield_3: %s', yield_3); return gen.next(yield_3); &#125;) &#125;)&#125;);// gen_next_1: [object Promise]; gen_next_2: [object Promise]; gen_next_3: [object Promise];// yield_1: 第1个异步任务;// yield_2: 第2个异步任务;// yield_3: 第3个异步任务// response_1: 第1个异步任务;response_2: 第2个异步任务;response_3: 第3个异步任务;如果只看 generator 函数这块，函数内部的写法和同步无异。gen 和 gen_1 都是同一生成器的实例。如前文所述，理解这块代码还是要从两方面入手 ———— 迭代和消息传递。迭代属性在此不再赘述，现在重点是消息传递的属性。在生成器中，生成器函数被调用后并未立即执行，而是构造了一个迭代器。而生成器正是靠着 yield/next 来完成生成器内外部的双向通信。在生成器内部，yield 是用来暂停（完全保持其状态）和向外部传递数据的关键字/表达式（初始时函数也是处于未执行状态）。在生成器外部，next 具有恢复生成器和向生成器内部传递数据的能力。混沌初始（gen 造出来了），盘古开天辟地（第一个 next() 执行），天地初成，继女娲造人后，一切欣欣向荣。共工和祝融两个调皮蛋撞坏了不周山，给女娲出了一个难题（yield），华夏史驻此不前。女娲向上天求助（yield async(1)），上天回应了并送来了五彩石（yield_1）,女娲顺利补天，华夏史再次启程（next(yield_1)）。然而好景不长，华夏部落经常受到蚩尤部落骚扰侵犯，蚩尤的存在再次阻碍了华夏史的前行（yield）。黄帝无奈向其师求助（yield async(2)），九天玄女授其兵法（yield_2）,黄帝顺利杀蚩尤，华夏史再次启程（next(yield_2)）。然而好景不长，中原地带洪水泛滥，华夏史再次受阻（yield）。夏禹无奈向太上老君求助（yield async(3)）,太上老君赠其神铁（yield_3）,夏禹顺利治水，华夏史再次启程（next (yield_3)）。实在编不下去了，还好结束了。😓 代码运行过程大抵如此。生成器内部生成一个数据，然后抛给迭代器消费，迭代器又把执行结果甩给了生成器。就是这么简单，别想的太复杂就行。所谓的消息双向传递，指的不仅仅是正常情况下生成器内外部的数据。对于异常错误，生成器内外部也可以双向捕捉。因为生成器内部的暂停，是保留了其上下文的，所以 try...catch 又可以一展身手了。生成器自执行 &amp; async/awaitPromise + 生成器 来表达异步算是实现了，然而我们也应该注意到在用迭代器控制生成器的那部分太过繁琐。如果能够封装下就好了， 如下：12345678910111213141516171819202122232425262728293031323334const generator_wrap = function (generator) &#123; const args = [...arguments].slice(1); const gen = generator.apply(this, args); return new Promise((resolve, reject) =&gt; &#123; const handleNext = function handleNext(yield)&#123; let next; try &#123; next = gen.next(yield); &#125; catch (error) &#123; reject(error) &#125; if (next.done) &#123; resolve(next.value) &#125; else &#123; return Promise.resolve(next.value).then(yield =&gt; &#123; handleNext(yield); &#125;, error =&gt; &#123; gen.throw(error); &#125;) &#125; &#125;; handleNext(); &#125;)&#125;;// ———————————— 手动分割线 ————————————const generator = function *generator()&#123; const response_1 = yield async(1); const response_2 = yield async(2); const response_3 = yield async(3); console.log('response_1: %s;response_2: %s;response_3: %s;',response_1,response_2,response_3);&#125;;generator_wrap(generator);// response_1: 第1个异步任务;response_2: 第2个异步任务;response_3: 第3个异步任务;不看 generator_wrap 函数，只看分割线以下的部分。至此，异步流程的表达越来越接近理想中的模样了。但 generator_wrap 函数还是需要自己手动封装，不过现在不用啦😄ES2017 推出了 async/await ，我们不用再自己去管理生成器，简单、强大、方便的 async/await 为我们处理了一切。123456789const awati_async = async () =&gt; &#123; const response_1 = await async(1); const response_2 = await async(2); const response_3 = await async(3); console.log('response_1: %s;response_2: %s;response_3: %s;', response_1, response_2, response_3);&#125;;awati_async();// response_1: 第1个异步任务;response_2: 第2个异步任务;response_3: 第3个异步任务;至此，关于 JavaScript 的异步表达暂时告一段落了👋。]]></content>
      <categories>
        <category>很难么</category>
      </categories>
      <tags>
        <tag>异步</tag>
        <tag>生成器</tag>
        <tag>async/await</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从迭代器模式到迭代协议]]></title>
    <url>%2F%E4%BB%8E%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%88%B0%E8%BF%AD%E4%BB%A3%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[迭代器模式迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素，而不需要暴露该对象的内部表示。迭代器分为内部迭代器和外部迭代器。内部迭代器只需一次初始调用，而外部迭代器必须显式地请求迭代下一个元素，这样我们就可以手动控制迭代过程。实现一个内部迭代器：1234567891011Array.prototype.innerIterator = function(callback)&#123; for (let i = 0, len = this.length; i &lt; len; i++) &#123; callback &amp;&amp; callback.call(this[i], this[i], i) &#125;&#125;;[1,2,3].innerIterator(function(item, index)&#123; console.log('item:', item, 'index:', index)&#125;)// item: 1 index: 0// item: 2 index: 1// item: 3 index: 2实现一个外部迭代器：123456789101112131415161718Array.prototype.outerInterator = function()&#123; let index = 0; return &#123; next: () =&gt; &#123; return index &lt; this.length ? &#123;value: this[index++], done: false&#125;: &#123;value: undefined, done: true&#125; &#125; &#125;&#125;let iterator = [1,2,3].outerInterator();for(let next; (next = iterator.next()) &amp;&amp; !next.done;) &#123; console.log('item', next.value)&#125;// item 1// item 2// item 3迭代协议了解了迭代器模式，再来看看 ES6 中补充的迭代协议。可迭代（iterable）协议和迭代器（iterator）协议。可迭代协议：一个可迭代对象（或其原型上），必须有一个 Symbol.iterator 的属性，该属性所对应的值为返回一个对象的无參函数，被返回对象符合迭代器协议。当可迭代对象需要迭代时，调用该方法。一些数据类型内置了 @@iterator 方法，有自己默认的迭代行为。（String, Array, TypedArray, Map , Set 等都是内置可迭代对象， 因为它们的原型对象都有一个 @@iterator 方法.）（[Symbol.iterator]、@@iterator 可以认为是一回事）123let iterator = ('hi')[Symbol.iterator]()var a = iterator.next();// a &#123; value: 'h', done: false &#125;迭代器协议：一个迭代器必须实现了 next() 方法，该方法是返回一个对象的无參函数。被返回的对象有两个必要的属性：done 和 value。123456789101112131415161718Array.prototype.Iteration = function()&#123; let index = 0; return &#123; [Symbol.iterator]()&#123;return this&#125;, next: () =&gt; &#123; return index &lt; this.length ? &#123;value: this[index++], done: false&#125;: &#123;value: undefined, done: true&#125; &#125; &#125;&#125;;let Iteration = [2, 3, 4].Iteration();for(let value of Iteration) &#123; console.log('value', value)&#125;// value 2// value 3// value 4不能发现，Iteration 同时满足可迭代协议和迭代协议。又因为是可迭代的，for...of 是可以直接使用，而且这个和外部迭代器十分相似。一旦一种数据结构有了 @@iterator 方法后， 就认为是可迭代的。ES6 中许多新的方法就是基于此的 解构赋值、扩展运算符、yield*，还有 for..of、Array.from()等。知道了以上知识，也就知道了为什么对象不可以直接使用 for...of 了。不过我们可以在对象原型上添加 @@iterator 方法，使之成为可迭代的。12345678910111213141516171819Object.prototype.Iteration = function()&#123; let keys = Object.keys(this), index = 0; return&#123; [Symbol.iterator]()&#123;return this&#125;, next: () =&gt; &#123; let current = index++; return current &lt; keys.length? &#123;value: [keys[current], this[keys[current]]], done: false&#125;: &#123;value: undefined, done: true&#125;; &#125; &#125;&#125;let iterator = &#123;'a': 1, 'b': 2, 'c': 3&#125;.Iteration(); for(let [key, value] of iterator) &#123; console.log('key:', key, 'value:', value)&#125;// key: a value: 1// key: b value: 2// key: c value: 3生成器像以上的的对象都是我们自己手动实现的，符合可迭代协议和迭代协议的对象。看起来很麻烦，还好这些工作已经有函数替我们做了，那就是生成器函数。生成器函数是可以作为迭代器工厂的函数，当它被执行时会返回一个新的 Generator 对象，该对象符合可迭代协议和迭代器协议。现在我们用生成器函数使得对象符合迭代协议：1234567891011Object.prototype.Iteration = function *()&#123; for(let [key, value] of Object.entries(this))&#123; yield [key, value] &#125;&#125;for(let [key, value] of &#123;'a': 1, 'b': 2, 'c': 3&#125;.Iteration()) &#123; console.log('key:', key, 'value:', value)&#125;// key: a value: 1// key: b value: 2// key: c value: 3在这里生成器只是作为迭代器而已，其实它还是消息双向传递系统。也正是这些特性的存在，使得异步流程控制又向前迈了一大步。]]></content>
      <categories>
        <category>很难么</category>
      </categories>
      <tags>
        <tag>迭代器</tag>
        <tag>迭代协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用DevTools提高你的工作效率]]></title>
    <url>%2F%E7%94%A8DevTools%E6%8F%90%E9%AB%98%E4%BD%A0%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%95%88%E7%8E%87%2F</url>
    <content type="text"><![CDATA[Chrome DevTools 调试使用 demo地址作为前端开发者，免不了要和 DevTools 打交道,熟练的使用 DevTools 能够大大提高我们的工作效率。然而，开发者工具的使用并没有得到足够的重视。工欲善其事必先利其器，更何况，工具的学习成本比专业技能的学习成本小的多。Chrome 有不同版本，如果想第一时间体验一些新的功能可以使用除稳定版本的其它版本。本次主要围绕着 Workspace 和 Blackbox script 这两点来感受它们带来的便利。WorkspaceWorkspace 主要还是将浏览器关联本地文件，使得浏览器拥有读写本地文件的权利。随着前端的发展，业务和逻辑也越来越复杂。还好打包压缩工具应运而生，还有 sourceMap 的使用，又让我们从压缩混淆的代码中有了看源码的体验。此时我们依然可以 DevTools 里 Sources 页签里的 Filesystem 页签添加本地文件夹，从浏览器里修改本地文件。这个功能或许还有点用，但是还是不如人意。因为修改后的文件需要刷新后才能显示变动，而文件被更改后，打包工具需要重新编译，编译时间或许很长或许很短，而且页面被被整体刷新了，给人一种很生硬的感觉。不过，还好有 热组件替换 这么一说。给我们的应用程序加上这货之后，我们的开发将会更加丝滑😉。热组件替换以 create-react-app 为例🌰（最新版本），步骤如下。也可以看看👀官方怎么说react-hot-loader.1⃣️：1npm install react-hot-loader --save-dev2⃣️：在 entry 中添加 isEnvDevelopment &amp;&amp; &#39;react-hot-loader/patch&#39;,3⃣️：在 oneOf 中 babel-loader 的 plugins 中添加 [&#39;react-hot-loader/babel&#39;],4⃣️：在入口文件添加以下内容1234567891011121314151617181920import &#123; AppContainer &#125; from 'react-hot-loader'const root = document.getElementById('root')const render = (Component) =&gt; &#123; ReactDOM.render( &lt;AppContainer&gt; &lt;Component /&gt; &lt;/AppContainer&gt;, root )&#125;render(App)if (module.hot) &#123; module.hot.accept('./App', () =&gt; &#123; const NextApp = require('./App').default render(NextApp) &#125;)&#125;至此，热组件替换改造完成，让我们再次感受下。通过以上展示，我们可以发现，整个界面只是局部被替换了，过渡得很自然。这应该才是我们想要的效果✨。插一句，在 Network 页签中，Preserve log 一定要勾选上☑️。这样的话，即使页面刷新了，也是有记录📝的，非常方便在页面跳转刷新时使用。Blackbox script如果说以上是提高了开发上的效率，那么这个 Blackbox script 功能将会在定位上省下不少时间。在断点排查问题时，代码总会在不同的位置切换。但是，经常会遇到各种不是我们程序里的代码跳出来。不过，只要我们把该文件标记为 Blackbox script 时，下次就不会再出现了。当然这只是最基本的操作，要想充分利用这个功能，还是要配合其它功能的使用。Call Stack调用栈在排查问题是很有用的，我们知道，函数的执行是有执行上下文的，函数由最外层到最内层依次压入栈中，在执行的时候，依次从栈中弹出。这样我们就可以从最内层沿着链找到最外层。排查错误时也是这个道理，我们经常遇到不知名的错误❌，可能是调用第三方的，也可能是底层，总之不是我们写的代码（我信你个鬼😏）。遇到这种情况就可以尝试用调用栈的方法，既然执行了，肯定是有调用的地方，我们可以沿着链去找源头（十有八九是我们自己写的代码😏）。不过调用栈中可能混杂了不是我们自己写的函数，这时候 Blackbox script 就派上用场了。Event Listener Breakpoints可能在熟悉一个新的项目时，想知道某个 dom 绑定的处理事件。Sources 页签下的 Event Listener Breakpoints 可以定位到代码具体的位置，不过和上次一样，好多其它代码混淆视听，我们需要把它们标记为 Blackbox script。标记完后，下次就会直接在自己的代码里停住了。Initiator其实和 Event Listener Breakpoints 并排的 XHR/fetch Breakpoints 也很有用，不过和接下来要讲的功能比，就显得鸡肋了。在 Network 页签中，记录的都是请求的数据。在开发的时候常遇到这两种情况，1⃣️：接口报错，在 Network 页签中可以看到整个URL被标红了，要快速定位到调用接口的地方。2⃣️：请求出去了，请看看响应时，如何处理数据。其实，两个实质上都是一样，就是快速定位代码。快速定位在大型项目中还是挺麻烦的，除非业务比较熟，剩下只能全局搜索了。还好，Network 页签下的 Initiator 也有类似调用栈的东西，我们可以在其列表中找到，Blackbox script 的功能依然时屏蔽无关的代码。补充除了以上还有很多调试技巧，1⃣️：有时候我们看见了控制有错误❌输出，却不知道是哪里的问题。或者是控制有报错❌，但一闪而过，无法捕捉。这时候可以尝试使用异常断点的功能(最右➡️的那个)。倒数第二个，是用来恢复函数执行的，使断点不起作用。2⃣️：数据量过大时，可能由于某一条数据的问题导致了页面渲染问题。如果打断点的话，数据量太大了，每一次都跳到循环的处理逻辑中会很麻烦。不过断点是支持条件断点的，还可以打印我们想要的变量（在最新的 Chrome dev版本中，已单独拎出来了）。3⃣️：有时候页面加载过快，都来不及看明白页面是怎么展示的。比如跳转问题，比如模拟网速慢、电脑性能卡慢问题。（这里十有八九是并发引起的竞态问题😏）右下角 Oneline 可自选模式。4⃣️：……]]></content>
      <categories>
        <category>善事利器</category>
      </categories>
      <tags>
        <tag>Chrome</tag>
        <tag>DevTools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异步的JavaScript(Promise篇)]]></title>
    <url>%2F%E5%BC%82%E6%AD%A5%E7%9A%84JavaScript%E2%80%94%E2%80%94Promise%E7%AF%87%2F</url>
    <content type="text"><![CDATA[引言错误理解精心组织起来的异步代码还不如使用一团乱麻的回调函数。在处理异步的问题上，回调基本上能够胜任，不过这都是建立在一切正常运转的基础上。然而事与愿违，回调受到控制反转的影响，把控制权交给了第三方，这种控制转移导致了一系列的信任问题（回调调用过早、回调调用过晚、回调不被调用、回调调用次数过少或过多等问题）。同时，基于回调的异步表达又是无序性的，回调地狱的使用，让我们正确理解代码的难度加大。函数的确可以规避以上的问题，但是，毋庸置疑，这会再次加大代码的理解难度。与其交给不信任的第三方，倒不如转交给一个位于我们和第三方间的可信任的中介机制，这里就是我们要说的 Promise。回调的转变如何把回调交给 Promise， 其实很简单。使用 Promise 后我们就无需再关心大部分的信任问题和无序性。因为 Promise 机制已经为我们处理好了，我们不需要写些特定逻辑来解决一些信任问题和并发带来的竞态问题，只要我们按照 Promise 规范正确执行即可。现在，以 setTimeout 代表异步操作来进行 Promise 改造。12345678910111213// callback asyncconst callback_async = (x = Date.now(), callback) =&gt; &#123; // do something now console.log('callback_async:初始时间戳', x) setTimeout(() =&gt; &#123; // do something in the future let interval = Date.now() - x callback &amp;&amp; callback(`callback_async:在$&#123;interval&#125;毫秒后异步完成`) &#125;, 1000)&#125;callback_async(undefined, res =&gt; &#123; console.log('callback_async:', res)&#125;)在 Promise 中我们依然能够看到回调的身影，只是回调作为参数传递的位置发生了变化。我们不再把回调交给第三方，而是让 Promise 从第三方获取某些数据，然后回调作为参数传递进去。1234567891011121314const promise_async = (x = Date.now()) =&gt; &#123; return new Promise(resolve =&gt; &#123; // do something now console.log('promise_async:初始时间戳', x) setTimeout(() =&gt; &#123; // do something in the future let interval = Date.now() - x resolve(`promise_async:在$&#123;interval&#125;毫秒后异步完成`) &#125;, 1000) &#125;)&#125;promise_async(undefined).then(res =&gt; &#123; console.log(res)&#125;)不同之前的把回调直接传给第三方的做法，这次是靠着 Promise 这个中间机制来替异步任务管理着回调。错误的处理使用 Promise 后，怎么就会好了很多呢？首先说说在错误的处理上。JavaScript 代码在执行的过程中若遇到错误就不会执行下去的。作为传入第三方的回调（同步回调或异步回调），如果在此之前就已经报错了，回调压根不会执行。在这种情况下，能通过回调捕获错误，也是很有意义的。我们很自然地想到了 try...catch , 不过在异步回调中，回调函数的执行栈与原函数分离开，导致外部是无法抓住异常。不过没关系，我们就多捕捉一遍。在此，我们就用“error-first风格”模拟一下。1234567891011121314151617181920212223// callback asyncconst callback_async = (x = Date.now(), callback) =&gt; &#123; try &#123; console.log('callback_async:初始时间戳', x) // do something now // throw 'callback-outer: error' setTimeout(() =&gt; &#123; try &#123; // do something in the future // throw 'callback-inner: error' let interval = Date.now() - x callback &amp;&amp; callback(null, `callback_async:在$&#123;interval&#125;毫秒后异步完成`) &#125; catch (error) &#123; callback(error) &#125; &#125;, 1000) &#125; catch (error) &#123; callback(error) &#125;&#125;callback_async(undefined, (error, res) =&gt; &#123; error?console.log('asyncError:', error):console.log('async:', res)&#125;)依次解开注释 throw... ，我们就可以成功地捕获到错误或异常。但同时也发现，对于一个不断嵌套的异步回调，就回调地狱那样，我们会为每一个异步回调做 try...catch 的错误处理，这会使原有的代码更加混乱。“幸运”的是，Promise 已经为我们处理好了这个问题。对于错误或异常，我们只需要注册 rejected 或 catch 的回调即可。不过 Promise 也存在着和上面相同的问题，无法捕获脱离上下文环境的错误或异常，我们只能收到手动 reject。1234567891011121314151617181920const promise_async = (x = Date.now()) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; // do something now // throw 'promise-outer: error' console.log('promise_async:初始时间戳', x) setTimeout(() =&gt; &#123; try &#123; // do something in the future // throw 'promise-inner: error' let interval = Date.now() - x resolve(`promise_async:在$&#123;interval&#125;毫秒后异步完成`) &#125; catch (error) &#123; reject(error) &#125; &#125;, 1000) &#125;)&#125;promise_async(undefined).catch(error =&gt; &#123; console.log(error)&#125;)对于多个异步任务，Promise 仍然能够很好的处理错误，因为 Promise 使用的 this-then-that 的流程控制，默认处理函数只是把错误重新抛出，这使得错误可以继续沿着Promise链传播下去，直到显式的 rejected 或 catch 捕获错误。Promise化Promise 带来的好处远远不止这些。一旦 Promise 决议， 它就永远保持这个状态，这个 Promise 的 then(...) 注册的回调就会被自动调用，且只会被调用一次。这也算解决了回调调用过少、过多及不被调用的问题。即使不能解决，但也可以在此基础上再做处理。你要是问为什么，我只能说人家就是干这个的，作为一个可信任的中间协商机制。说到一旦决议就不能改变，这个很重要么，是的，真的很重要。在基于回调模式的异步处理中，JavaScript 代码执行后会一直走下去，遇到回调就直接执行了。但是 Promise 决议后，可以一直保留着这个结果，通过 .then(..) 形式添加的回调函数，甚至在异步操作完成之后才添加的回调函数，都会被执行调用。这也是上一个 Promise 里的错误只能在 Promise 链的下一个回调里捕获的原因。知道了 Promise 的好处，也知道了基于回调模式的异步处理方式，我们就可以尝试把“error-first风格”的回调 Promise 化。1234567891011// Promise Wrapvar promise_wrap = function(fn)&#123; return function() &#123; let args = Array.from(arguments); return new Promise((resolve, reject) =&gt; &#123; fn.apply(null, args.concat((error, value) =&gt; &#123; error ? reject(error): resolve(value) &#125;)) &#125;) &#125;&#125;在这里我们可以看到，为了统一处理现在和将来，我们把它们都变成了将来，即所有的操作都成了异步，同步回调也变成了异步回调。JavaScript 异常错误也是如此，在 Promise 创建过程中或查看决议结果过程中出现的异常错误，这个异常错误被捕捉都会变成异步行为。这样做减少了由函数顺序不确定性（竞态条件）带来的诸多问题。保持扁平化从回调模式跨到 Promise，总会不小心保留着原来的风格，比如嵌套。Promise 链式编程最好保持扁平化，不然不就变成另一个回调地狱了？关键是还没有返回或终止 Promise 链。1234567891011121314151617// parallel Promisevar parallel_promise = (x = Date.now()) =&gt; &#123; Promise.resolve().then(() =&gt; &#123; new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; let interval = Date.now() - x; resolve(`parallel-inner:在$&#123;interval&#125;毫秒后完成`) &#125;, 3000) &#125;).then(res =&gt; &#123; console.log(res) &#125;) &#125;).then(res =&gt; &#123; let interval = Date.now() - x; console.log(`parallel-outer:在$&#123;interval&#125;毫秒后完成; res: $&#123;res&#125;`) &#125;)&#125;parallel_promise(undefined)从上面的执行结果可以看出，parallel-outer 并非在 parallel-inner 后执行。这是没有正确将 Promise 相连接的结果。实际上，这里就是两个独立竞争的 Promise（同时在执行异步任务而不是一个接着一个）。同时我们也会注意到外层 then(...) 注册回调中 res 为 undefined，因为对于没有任何显式的决议，这个值就是 undefined。123456789101112131415161718// serial Promisevar serial_promise = (x = Date.now()) =&gt; &#123; Promise.resolve().then(() =&gt; &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; let interval = Date.now() - x; resolve(`serial-1:在$&#123;interval&#125;毫秒后完成`) &#125;, 3000) &#125;).then(res =&gt; &#123; console.log(res) return res &#125;) &#125;).then(res =&gt; &#123; let interval = Date.now() - x; console.log(`serial-2:在$&#123;interval&#125;毫秒后完成; res: $&#123;res&#125;`) &#125;)&#125;serial_promise(undefined)所以说，一个好的经验法则是总是返回或终止 Promise 链，并且一旦得到一个新的 Promise，返回它。小结用 Promise 来表达异步和管理并发无疑是种进步，它在程序的顺序性和可信任性上提供了自己的解决方案。它不是回调的替代品，只是帮着异步任务管理回调的可信任的中间机制。相对于直接粗暴的回调，Promise 并不会带来性能上的提升，但是它会让我们的程序更加健壮，也使得代码更加简洁，更加符合我们有序的思维方式。当然，Promise 也有自己的局限性。在并发 Promise.race(...) 上，我们只要第一个决议即可。当出现第一个决议的 Promise 时，其它的 Promise 就没有必要进行下去了。然而，我们没把法终止。在错误处理上，Promise 链中错误总是由下一个 Promise 捕获。如果错误发生在最后一个 Promise 呢？还有，对于嵌套的 Promise，内部 Promise 已经进行了错误处理，但是外部 Promise 却捕获不到，这样真的好么？Promise 恢复了可信任性，但我们还想让异步流程的表达风格更贴近同步的形式，链式调用不说不好，只是我们带着同步操作的惯性。还好，ES6、ES7已经给出了方案。]]></content>
      <categories>
        <category>很难么</category>
      </categories>
      <tags>
        <tag>异步</tag>
        <tag>Promise</tag>
        <tag>then</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端笔试之手写代码]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AF%95%E4%B9%8B%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[扁平化嵌套数组/flat实现描述：将嵌套多层的数组展开平铺成只有一层的数组。12let array = [1, [1, 2, 3], [1, [2, &#123;&#125;]] ]handle(array) // [1, 1, 2, 3, 1, 2, &#123;&#125;]方法一：12const handle = array =&gt; JSON.parse(`[$&#123;JSON.stringify(array).replace(/\[|]/g,'')&#125;]`)handle(array) // [ 1, 1, 2, 3, 1, 2, &#123;&#125; ]知识点：JSON.parse()/JSON.stringify()、String.prototype.replace()方法二：12const handle = array =&gt; array.reduce((accumulator, currentValue) =&gt; accumulator.concat(Array.isArray(currentValue) ? handle(currentValue): currentValue), [])handle(array) // [ 1, 1, 2, 3, 1, 2, &#123;&#125; ]知识点：Array.prototype.reduce()、Array.prototype.concat()方法三：1234567const handle = array =&gt; &#123; while(array.some(item =&gt; Array.isArray(item))) &#123; array = [].concat(...array) &#125; return array&#125;handle(array) // [ 1, 1, 2, 3, 1, 2, &#123;&#125; ]知识点：while、Array.prototype.some()、剩余参数其它方法：……数组去重描述：将数组中重复的元素过滤掉。12let array = [1, 2, 1, '3', '3', 0 , 1]handle(array) // [1, 2, '3', 0]方法一：12const handle = array =&gt; [...new Set(array)]handle(array) // [ 1, 2, '3', 0 ]知识点：Set方法二：12345const handle = array =&gt; array.reduce((accumulator, currentValue) =&gt; &#123; !accumulator.includes(currentValue) &amp;&amp; accumulator.push(currentValue) return accumulator&#125;, [])handle(array) // [ 1, 2, '3', 0 ]知识点：Array.prototype.includes()方法三：12345const handle = array =&gt; &#123; let map = new Map() return array.filter(item =&gt; map.has(item) ? false : map.set(item))&#125;handle(array) // [ 1, 2, '3', 0 ]知识点：Map、Array.prototype.filter()其它方法：……模拟bind实现123456Function.prototype.bind = function () &#123; let self = this, args = Array.from(arguments), context = args.shift(); return function () &#123; return self.apply(context, args.concat(...arguments)) &#125;;&#125;;知识点：apply、call、bind模拟Call实现1234567Function.prototype.Call = function()&#123; let args = Array.from(arguments), context = args.shift(); context = Object(context); context.fn = this; let result = context.fn(...args); return (delete context.fn) &amp;&amp; result;&#125;;模拟New实现123456const handle = function() &#123; let fn = Array.prototype.shift.call(arguments) let obj = Object.create(fn.prototype) let o = fn.apply(obj, arguments) return typeof o === 'object' ? o : obj;&#125;知识点：Object.create()格式化数字123const num = 123456789;const handle = num =&gt; String(num).replace(/\B(?=(\d&#123;3&#125;)+(?!\d))/g, ',')handle(num) // 123,456,789知识点：正则表达式、String.prototype.replace()回文判断123456789const num = 123456654321;const str = 'abababababab';const handle = params =&gt; &#123; let str_1 = String(params).replace(/[^0-9A-Za-z]/g, '').toLowerCase(); let str_2 = str_1.split('').reverse().join(); return str_1 === str_2 ? true : false&#125;handle(num) // truehandle(str) // false知识点：String.prototype.split()、Array.prototype.join()函数节流定时器1234567891011const handle = (fn, interval) =&gt; &#123; let timeId = null; return function() &#123; if (!timeId) &#123; timeId = setTimeout(() =&gt; &#123; fn.apply(this, arguments) timeId = null &#125;, interval) &#125; &#125;&#125;知识点：window.setTimeout时间戳12345678910const handle = (fn, interval) =&gt; &#123; let lastTime = 0 return function () &#123; let now = Date.now(); if (now - lastTime &gt; interval) &#123; fn.apply(this, arguments) lastTime = now &#125; &#125;&#125;函数防抖123456789const handle = (fn, delay) =&gt; &#123; let timeId; return function() &#123; if (timeId) clearTimeout(timeId) timeId = setTimeout(() =&gt; &#123; fn.apply(this, arguments) &#125;, delay) &#125;&#125;函数节流、函数防抖区别：函数节流和函数防抖较容易混淆，可以这么比喻，对于函数节流，门外有人频繁敲门，但是门卫按固定时间来决定是否开门。对于函数防抖，门外有人频繁敲门，门卫按最后一次敲门来决定是否开门。知识点：window.clearTimeout深拷贝12345678910111213const handle = function deepClone(params) &#123; if (Array.isArray(params)) &#123; return params.reduce((accumulator, currentValue) =&gt; &#123; (typeof currentValue === 'object') ? accumulator.push(deepClone(currentValue)) : accumulator.push(currentValue); return accumulator; &#125;, []) &#125; else &#123; return Reflect.ownKeys(params).reduce((accumulator, currentValue) =&gt; &#123; (typeof params[currentValue] === 'object') ? accumulator[currentValue] = deepClone(params[currentValue]) : accumulator[currentValue] = params[currentValue]; return accumulator; &#125;, &#123;&#125;) &#125;&#125;发布订阅模式123456789101112131415161718192021222324252627282930class Pubsub &#123; constructor() &#123; this.handles = &#123;&#125; &#125; subscribe(type, handle) &#123; if (!this.handles[type]) &#123; this.handles[type] = [] &#125; this.handles[type].push(handle) &#125; unsubscribe(type, handle) &#123; let pos = this.handles[type].indexOf(handle) if (!handle) &#123; this.handles.length = 0 &#125; else &#123; ~pos &amp;&amp; this.handles[type].splice(pos, 1) &#125; &#125; publish() &#123; let type = Array.prototype.shift.call(arguments) this.handles[type].forEach(handle =&gt; &#123; handle.apply(this, arguments) &#125;) &#125;&#125;const pub = new Pubsub()pub.subscribe('a', function() &#123;console.log('a', ...arguments)&#125;)pub.publish('a', 1, 2, 3)// a 1 2 3偏函数1234const partial = (fn, ...presetArgs) =&gt; (...laterArgs) =&gt; fn(...presetArgs, ...laterArgs)柯里化12345678910111213const curry = (fn, arity = fn.length, nextCurried) =&gt; (nextCurried = prevArgs =&gt; nextArg =&gt; &#123; var args = prevArgs.concat( [nextArg] ); if (args.length &gt;= arity) &#123; return fn( ...args ); &#125; else &#123; return nextCurried( args ); &#125; &#125; )( [] );函数组合123456789var compose = (...fns) =&gt; result =&gt; &#123; var list = fns.slice(); while (list.length &gt; 0) &#123; result = list.pop()( result ); &#125; return result; &#125;;简易模块依赖管理器1234567891011121314const moduleManage = (() =&gt; &#123; let modules = &#123;&#125;; const define = (name, deps, module) =&gt; &#123; deps = deps.map(item =&gt; modules[item]) modules[name] = module(...deps); &#125;; const exports = (name) =&gt; &#123; return modules[name]; &#125; return &#123; define, exports, &#125;&#125;)();Promise化123456789101112131415161718192021222324252627282930313233var promise_wrap = fn =&gt; function()&#123; return new Promise((resolve, reject) =&gt; &#123; fn(...[(error, value) =&gt; error ? reject(error): resolve(value), ...arguments]) &#125;)&#125;// 示例：var callback_async = (callback, x = Date.now()) =&gt; &#123; try &#123; console.log('callback_async:初始时间戳', x) // do something now // throw 'callback-outer: error' setTimeout(() =&gt; &#123; try &#123; // do something in the future // throw 'callback-inner: error' let interval = Date.now() - x callback &amp;&amp; callback(null, `callback_async:在$&#123;interval&#125;毫秒后异步完成`) &#125; catch (error) &#123; console.log(&#123;callback&#125;) callback(error) &#125; &#125;, 1000) &#125; catch (error) &#123; callback(error) &#125;&#125;promise_wrap(callback_async)(1)对象可迭代123456789101112Object.prototype.Iteration = function()&#123; let keys = Object.keys(this), index = 0; return&#123; [Symbol.iterator]()&#123;return this&#125;, next: () =&gt; &#123; let current = index++; return current &lt; keys.length? &#123;value: [keys[current], this[keys[current]]], done: false&#125;: &#123;value: undefined, done: true&#125;; &#125; &#125;&#125;生成器自执行器123456789101112131415161718192021222324const generator_wrap = function (generator) &#123; const args = [...arguments].slice(1); const gen = generator.apply(this, args); return new Promise((resolve, reject) =&gt; &#123; const handleNext = function handleNext(yield)&#123; let next; try &#123; next = gen.next(yield); &#125; catch (error) &#123; reject(error) &#125; if (next.done) &#123; resolve(next.value) &#125; else &#123; return Promise.resolve(next.value).then(yield =&gt; &#123; handleNext(yield); &#125;, error =&gt; &#123; gen.throw(error); &#125;) &#125; &#125;; handleNext(); &#125;)&#125;;]]></content>
      <categories>
        <category>写着玩</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异步的JavaScript(回调篇)]]></title>
    <url>%2F%E5%BC%82%E6%AD%A5%E7%9A%84JavaScript%2F</url>
    <content type="text"><![CDATA[唯一比不知道代码为什么崩溃更可怕的事情是，不知道为什么一开始它是工作的！在 ECMA 规范的最近几次版本里不断有新成员加入，尤其在处理异步的问题上，更是不断推陈出新。然而，我们在享受便利的同时，也应该了解异步到底是怎么一回事。现在与将来JavaScript 是单线程的，一次只能专注于一件事。如果浏览器只靠 JavaScript 引擎线程来完成所有工作，先不说能不能搞定，即使可以，那也会花费很长时间。幸好在浏览器里 JavaScript 引擎并不孤单，还有 GUI 渲染线程、事件触发线程、定时触发器线程、异步http请求线程等其它线程。这些线程之间的协作才有了我们看到的浏览器界面效果（远不止这些）。(盗了一张图)一个程序在执行过程中可能会有等待用户输入、从数据库或文件系统中请求数据、通过网络发送并等待响应，或是以固定时间间隔执行重复任务（比如动画）等情况。（这些情况，当下是无法得出结果的，但是一旦有了结果，我们知道需要去做些什么。）JavaScript 引擎不是一个人在战斗，它把以上的任务交给其它线程，并计划好任务完成后要做的事，JavaScript 引擎又可以继续做自己的事了。从这里可以看出，一个程序的运行包括两部分，现在运行和将来运行。而现在运行和将来运行的关系正是异步编程的核心。123let params = &#123;type:'asynchronous'&#125;let response = ajax(params,'http://someURL.com'); // 异步请求if (!response) throw '无数据！';以上代码肯定会抛错的，异步请求任务交出去之后，程序会继续运行下去。由于ajax(…) 是异步操作，即使立刻返回结果，当下的 response 也不会被赋值。一个是现在，一个是将来，两者本就不属于一个时空的。事件循环现在和将来是相对的，等将来的时刻到了，将来也就成为了现在。JavaScript 引擎运行在宿主环境中，宿主环境提供了一种机制来处理程序中多个块的执行，且执行每个块时调用 JavaScript 引擎，这种机制被称为事件循环。即，JavaScript 引擎本身并没有时间的概念，只是一个按需执行 JavaScript 任意代码片段的环境。“事件”（JavaScript 代码执行）调度总是由包含它的环境进行。点击图片进入或点此进入：一个 JavaScript 运行时包含了一个待处理的消息队列。每一个消息都关联着一个用以处理这个消息的函数。在事件循环期间的某个时刻，运行时从最先进入队列的消息开始处理队列中的消息。为此，这个消息会被移出队列，并作为输入参数调用与之关联的函数。123while (queue.waitForMessage()) &#123; queue.processNextMessage();&#125;一旦有事件需要进行，事件循环就会运行，直到队列清空。事件循环的每一轮称为一个 tick。用户交互，IO 和定时器会向事件队列中加入事件。(又盗了一张图)任务队列任务队列（job queue）建立在事件循环队列之上。（Promise 的异步特性就是基于任务。）最好的理解方式，它是挂在事件循环队列的每个tick之后的一个队列。在事件循环的每个tick中，可能出现的异步动作不会导致一个完整的新事件添加到事件循环队列中，而会在当前 tick 的任务队列末尾添加一个项目（一个任务）。即，由 Call Stack 生成的任务队列会紧随其后运行。1234567891011121314151617181920212223242526272829Promise.resolve().then(function promise1 () &#123; console.log('promise1');&#125;)setTimeout(function setTimeout1 ()&#123; console.log('setTimeout1'); Promise.resolve().then(function promise2 () &#123; console.log('promise2'); &#125;)&#125;, 0)setTimeout(function setTimeout2 ()&#123;console.log('setTimeout2'); Promise.resolve().then(function promise3 () &#123; console.log('promise3'); setTimeout(function setTimeout3 () &#123; console.log('setTimeout3'); &#125;) Promise.resolve().then(function promise4 () &#123; console.log('promise4'); &#125;) &#125;)&#125;, 0)// promise1// setTimeout1// promise2// setTimeout2// promise3// promise4// setTimeout3回调被作为实参传入另一函数，并在该外部函数内被调用，用以来完成某些任务的函数，称为回调函数。回调函数经常被用于继续执行一个异步完成后的操作，它们被称为异步回调。立即执行的称之为同步回调。回调函数是事件循环“回头调用”到程序中的目标，队列处理到这个项目的时候会运行它。回调是 JavaScript 语言中最基础的异步模式。生活中，我们喜欢和有条理的人打交道，因为我们的大脑习惯了这种思维模式。然而回调的使用打破了这种模式，因为代码的嵌套使得我们要在不同块间切换。嵌套越多，逻辑越复杂，我们也就越难理解和处理代码，尤其在表达异步的方式上。(又盗了一张图)除了嵌套的问题，异步回调还存在一些信任问题。回调性质的不确定调用回调方式不确定（没调用，重复调用等）……针对第一点的建议是：永远异步调用回调，即使就在事件循环的下一轮，这样，所有回调都是可预测的异步调用了。在理解这个建议之前，我们首先了解下控制反转，控制反转就是把自己程序一部分的执行控制交个某个第三方。12345let a = 0; // Athirdparty(() =&gt; &#123; console.log('a', a); // B&#125;)a++; // CA 和 C 是现在运行的，B 虽然代码是我们的，但是却受制于第三方，因为我们无法确定它是现在运行还是将来运行的。这里的回调函数可能是同步回调也可能是异步回调。a 是 0 还是 1，都有可能。12345678// 同步回调const thirdparty = cb =&gt; &#123; cb();&#125;// 异步回调const thirdparty = cb =&gt; &#123; setTimeout(() =&gt; cb(), 0);&#125;所以，永远异步调用回调，可预测。12345678910111213141516171819202122function asyncify(fn) &#123; let func = fn; let t = setTimeout(() =&gt; &#123; t = null; if (fn) fn(); &#125;, 0); fn = null; return () =&gt; &#123; if (t) &#123; fn = func.bind(this, ...arguments); &#125; else &#123; func.apply(this, arguments); &#125; &#125;&#125;let a = 0;thirdparty(asyncify(() =&gt; &#123; console.log('a', a);&#125;))a++;// 1]]></content>
      <categories>
        <category>很难么</category>
      </categories>
      <tags>
        <tag>异步</tag>
        <tag>事件循环</tag>
        <tag>任务队列</tag>
        <tag>回调</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于MVC模式简单代码实现]]></title>
    <url>%2F%E5%85%B3%E4%BA%8EMVC%E6%A8%A1%E5%BC%8F%E7%AE%80%E5%8D%95%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[经过之前的咬文嚼字说策略、在JavaScript中尝试组合模式、白话MVC/MVP/MVVM 和 较早之前的进击的观察者模式等文章的铺垫，终于可以把这些理论的东西用于实践了。废话不多说，直奔主题。GoF 并不将 MVC 引述为一种设计模式，而是把它看做是构建一个用户界面的类的集合。按照他们的观点，它实际上是三种经典设计模式的变异组合：观察者模式，策略模式和组合模式。依赖于框架中的 MVC 如何实现，它也可能会使用工厂和模板模式。GoF Book 提到这些模式在使用 MVC 工作时是非常有用的附加功能。功能示意:由一组数据展示三类表格，分别是【stuff，scale】、【stuff，salary】、【stuff，scale，salary】三组视图。另外可以修改指定 stuff 的 scale 或 salary 信息。stuffs 信息：1234567891011121314151617const stuffs = [ &#123; stuff: 'person_1', scale: '甲', salary: '6000' &#125;, &#123; stuff: 'person_2', scale: '乙', salary: '5000' &#125;, &#123; stuff: 'person_3', scale: '丙', salary: '9000' &#125;];常规的写法可以这么来：See the Pen tableOrdinary by 夜曉宸 (@yexiaochen)on CodePen.职责分配既然说了 MVC 有那么多好处，我们就用 MVC 的模式来改造下我们的代码。首先我们先划分下职责。Model 负责对数据的处理并返回目标数据，在这个场景下是筛选 stuff、修改stuff 等职责。View 负责对目标数据的渲染和处理用户的响应，在这个场景下是各个表格的渲染、change 事件的委托等职责。Control 负责协调 Model 和 View，在这个场景下是处理委托、处理数据等职责。此处的 MVC 实现是针对一个 Model 对应多个 View 的代码实现 ，也是为了把观察者模式，策略模式和组合模式模式都用起来。View【stuff，scale】、【stuff，salary】、【stuff，scale，salary】三组视图就是三个 View，每个 View 都可以独立渲染自己的一组视图。结合组合模式，我们我们造些视图的叶对象和分支对象。123456789&lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; const $APP = document.getElementById('app');&lt;/script&gt;叶对象（此处有两类视图）：123456789101112131415161718const leafView_1 = () =&gt; &#123;const renderTable = () =&gt; &#123;...&#125;; return &#123; render: renderTable() &#125;;&#125;const leafView_2 = (Control) =&gt; &#123; const $ONE = document.getElementById('one'); let $SCALE; let $SALARY; const renderSearchTable = params =&gt; &#123;...&#125;; const handleModify = e =&gt; &#123;...&#125;; const bindEvent = () =&gt; &#123;...&#125;; return &#123; render: () =&gt; &#123;...&#125; &#125;;&#125;分支对象：1234567891011121314const branchView = (Control) =&gt; &#123; let $SEARCH, $ALL; const Views = []; const addView = () =&gt; &#123;...&#125;; const render = () =&gt; &#123;...&#125;; const handleSearch = event =&gt; &#123;...&#125;; const bindEvent = () =&gt; &#123;...&#125; const initDOM = () =&gt; &#123;...&#125;; initDOM(); return &#123; render, addView, &#125;;&#125;;ModelModel 主要是将数据处理成目标数据，并提供 View 注册通知接口。1234567891011121314151617181920const Model = () =&gt; &#123; let stuffData = []; let filterData = []; let Views = &#123;&#125;; const ajaxFun = () =&gt; [...]; // 模拟后台获取数据； const setStuffData = () =&gt; &#123;&#125;; const filterStuff = () =&gt; &#123;&#125;; const setFilterStuff = () =&gt; &#123;&#125;; const findStuff = () =&gt; &#123;...&#125;; const modifyStuffData = () =&gt; &#123;...&#125;; const register = () =&gt; &#123;...&#125;; const notify = () =&gt; &#123;...&#125;; return &#123; setStuffData, setFilterStuff, modifyStuffData register, notify, &#125;;&#125;Control鉴于此处有多类视图，Model 和 View 之间，我们采用了发布订阅模式而不是观察者模式。Model 需要收集 View，然后在数据改变时候更新视图。12345678910111213const Control = () =&gt; &#123; const ModelInstance = Model(); const View_1 = () =&gt; &#123;...&#125;; const View_2 = () =&gt; &#123;...&#125;; const init = function () &#123;...&#125;; const filter = () =&gt; &#123;...&#125;; const modifyStuffInfo = () =&gt; &#123;...&#125;; return &#123; init, filter, modifyStuffInfo &#125;;&#125;;完整的 MVC 代码：See the Pen MVC by 夜曉宸 (@yexiaochen)on CodePen.后话就这么简单的一个需求，改成 MVC 模式后就多了 100 多行代码。就如上篇文章所说一样，如果是简单的需求压根没必要这么折腾。不过，改成 MVC 后，它们各自职责也就更加清晰了，对以后的维护也会好些。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>观察者模式</tag>
        <tag>MVC</tag>
        <tag>策略模式</tag>
        <tag>组合模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[白话MVC/MVP/MVVM]]></title>
    <url>%2F%E7%99%BD%E8%AF%9DMVC-MVP-MVVM%2F</url>
    <content type="text"><![CDATA[一切皆为数据（0，1），一切皆可量化不管承不承认，页面的展示都是数据的可视化。HTML 是数据，CSS 是数据，JS也是数据。只是这些数据的组合最终变成了我们想要的效果。最为直观的是，我们在开发者工具 Console 控制台中，输入任何形式的数据并点击 Enter 时，最终会在下方显示出来（前提是输入正确的数据类型和格式）。又或者，我们用某些参数从服务请求一个 JSON 文件，浏览器上就会展示文件内容。数据 =&gt; 视图，就是这么简单直接。MV然而，实际上的情况远远比这复杂。为了更好的视觉享受和用户体验，浏览器上的页面效果越来越炫，交互逻辑也越来越复杂。我们拿到的第一手数据（或来自用户，或来自服务）已经不能直接用来展示了，而是要经过相应的逻辑处理（在这里我们称第一手数据为源数据，经过逻辑处理后的数据称为目标数据）。视图上的数据就是目标数据的映射。而处理后的数据又该如何展示呢？是基于 DOM 做操作，还是基于目标数据重新渲染呢？两者都可，前者是以 jQuery 为代表，后者则是以 Vue 等新框架为主。举个例子🌰，对于某个 DOM 元素的显隐。1234567891011&lt;!-- jQuery --&gt;&lt;div id='jquery'&gt;&lt;/div&gt;$('#jquery').hide;&lt;!-- Vue --&gt;&lt;div id='jquery' v-show=&#123;id[jquery]&#125;&gt;&lt;/div&gt;data: &#123; id: &#123; jquery: fasle &#125;&#125;基于 DOM 操作， 如果我们需要对这个 DOM 随时改变显隐，就需要不断操作 DOM 来更改样式。 如果基于数据操作，我们只需要更改 jQuery 的值即可。我们再回到刚才的话题，对于复杂的交互页面，数据 =&gt; 视图 的关系已经不再像之前那么纯净了。为了应付复杂的场景，数据 和 视图 不再是狭义上的数据和视图。数据包括了数据和数据相关的操作，视图包括了视图和对视图相关的一些操作。MV*模式借用其他领域 MV* 框架模式，这里的 数据 和 视图 对应着 Model 和 View. 简单点的页面，Model - View 完全能够应付过来。但是复杂的场景，Model 和 View 会分担太多的逻辑而显得臃肿，甚至可能包含了不在自己职责范围内的逻辑。此时我们就要借助第三者来协调 Model 和 View 之间的关系。如何合作，其实也早有了相应的解决方案。比如 MVC、MVP、MVVM。因为重点始终在于协调 Model和 View，所以它们统称为 MV*。MVC (Model(模型)-View(视图)-Controller(控制器)), MVP (Model(模型)-View(视图)-Presenter(中介者)) 以及 MVVM (Model(模型)-View(视图)-ViewModel(视图模型))，是种模式也是种抽象的概念。每一种模式在实践中可能存在着不同的变体，但这不妨碍它们属于同一个模式。每一种模式的不同变体都是为了解决不同问题而产生的，所以它们没有什么优劣之分。现在我们就把三种模式拟人化来阐述不同模式的运作方式。由四节电池驱动的J-20模型:MVC公司：飞机模型制造商 =&gt; 生产的飞机模型可以自主塑形。模式：MVC飞机模型 V：由模型数据生产出的模型。职责有：由模型数据自主塑形、将收集用户反馈并转发。工程师 M：负责将客服的需求参数转换成最终的模型数据。职责有：对数据的操作、通知飞机模型更新。工程师 C：协调 M 和 V。负责响应用户、调用工程师M生成目标数据。首先我们要知道，客户提出了想要一个 60cm * 60cm 的飞机模型，这个需求到了制造商那里肯定不是给出个 60cm * 60cm 的小方块，而是根据需求计算处理生产真正的飞机模型（比如什么样的造型设计才能最大减少阻力），工程师M的工作之一就是根据原始数据并结合特定的逻辑规则给出最终的模型数据。现在，用户手里有一飞机模型V，不过这个飞机模型的飞机双翼和用户想象的不一样。于是用户根据飞机模型上提供的方式反馈了问题（比如飞机模型提供了留言功能，用来收集用户反馈）。工程师C收到了反馈后，把工程师M拉过来对数据进行处理并生成新的模型数据，并让工程师M通知到共享相同数据的飞机模型去更新数据自主调整。插一句，说到调整，我们有两种方式。一个是，我们可以针对用户不满意的地方（飞机双翼）进行调整。一个是，我们飞机模型格式化按照最新的数据模型重新初始化一下。前者可以认为就是基于 DOM 操作的方式，后者就是基于数据的处理方式。在 MVC 中，Model 和 View 之间耦合，视图的更新需要 Model 去直接通知。Model 内因为有 View 的引用才能让视图更新。MVP如果 Model 只想做数据相关的操作，把通知 View 的逻辑挪到了 Control 里，这时 Control 摇身一变称为了 Presenter。因为解耦了 Model 和 View，也使得它们的职责划分更加清晰。公司：飞机模型制造商 =&gt; 生产的飞机模型可以自主塑形。模式：MVP飞机模型 V：由模型数据生产出的模型。职责有：由模型数据自主塑形、将收集用户反馈并转发。工程师 M：负责将客服的需求参数转换成最终的模型数据。职责有：对数据的操作。工程师 P：协调 M 和 V。负责响应用户、调用工程师M生成目标数据、更新视图。在 MVP 模式中，工程师M的工作专注于数据，通知的活甩给了工程师P。和 MVC 同样的场景，工程师P接到反馈后，把工程师M拉过来处理了数据，然后又让飞机模型依据已经处理后的数据自主调整。每次数据的变化都要主动去通知视图更新。MVVM如果数据变化能够自主触发视图更新，对 Presenter 来说也会轻松不少。于是 Presenter 再次摇身一变 称为了 ViewModel。公司：飞机模型制造商 =&gt; 生产的飞机模型可以自主塑形。模式：MVVM飞机模型 V：由模型数据生产出的模型。职责有：由模型数据自主塑形、将收集用户反馈并转发。工程师 M：负责将客服的需求参数转换成最终的模型数据。职责有：对数据的操作。工程师 VM：协调 M 和 V。负责响应用户、调用工程师M生成目标数据并更新视图。在 MVVM 中，View 和 Model 的变化似乎不大。为了在数据变化后能够自动更新视图，ViewModel 进行了所谓的数据绑定。ViewModel 将 目标数据 和视图进行了绑定，在最终生成目标数据时，会触发视图的更新。在这里我们可以想象有两份数据，一份是源数据，一份是目标数据。绑定视图的是目标数据，这样，我们直接修改目标数据时会触发视图更新。如果是源数据经处理后赋给目标数据，目标数据也会改变，也会触发试图更新。总之，在 MVVM 中，视图是目标数据的可视化，通过改变视图里的数据也就等于改变了目标数据。和 MVC、MVP 同样的场景，不过科技发达了，工程师VM有个自动化处理程序。用户反馈了问题，工程师VM的这个自动处理程序接到反馈自动处理并将结果发给飞机模型让其自主调整。以下是Vue的MVVM示意图：MVC、MVP和MVVM大致就是如此，根据三种模式以及不同场景，最终演变出了不同的变体。但是，不同的变体是针对不同问题的解决方案，指不定后来还会有 MVA、MVB…, 谁知道呢]]></content>
      <categories>
        <category>这个想法不一定对</category>
      </categories>
      <tags>
        <tag>MVC</tag>
        <tag>MVVM</tag>
        <tag>MVP</tag>
        <tag>MV*</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在JavaScript中尝试组合模式]]></title>
    <url>%2F%E5%9C%A8JavaScript%E4%B8%AD%E5%B0%9D%E8%AF%95%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[组合模式就是用小的子对象来构建更大的对象, 将对象组合成树形结构, 以表示 “部分-整体” 的层次结构. 位于底层最小的对象, 我们在这里称为叶对象, 由叶对象组成的组合对象我们称为分支对象, 位于最顶层的根对象在这里我们也称为分支对象. 不过它们只是结构上呈现出父子关系. 组合模式最大的好处可以一致性地对待分支对象和叶对象, 这也就要求了它们有着相同的接口.在咬文嚼字说策略中, 我们对员工进行考核, 划分了甲乙丙三个等级. 现在, 公司决定结合等级以资鼓励.以下所有代码参见compositeMode.开销的占比现有考核人员:考核项目\考核人等级月薪person_1甲6kperson_2乙9kperson_3乙4kperson_4乙5kperson_5丙6kperson_6丙5kperson_7丙6kperson_8丙4kperson_9甲8k123456789101112const persons = [ &#123;scale:'甲', salary: 6000, company: 'JavaScript'&#125;, &#123;scale:'乙', salary: 9000, company: 'JavaScript'&#125;, &#123;scale:'乙', salary: 4000, company: 'JavaScript'&#125;, &#123;scale:'乙', salary: 5000, company: 'JavaScript'&#125;, &#123;scale:'丙', salary: 6000, company: 'JavaScript'&#125;, &#123;scale:'丙', salary: 5000, company: 'JavaScript'&#125;, &#123;scale:'丙', salary: 6000, company: 'JavaScript'&#125;, &#123;scale:'丙', salary: 4000, company: 'JavaScript'&#125;, &#123;scale:'丙', salary: 9000, company: 'JavaScript'&#125;, &#123;scale:'甲', salary: 6000, company: 'JavaScript'&#125;,]等级与月薪相关, 分别为3倍月薪、2倍月薪、1倍月薪.等级甲乙丙月薪倍率32112345const scaleMap = &#123; '甲': 3, '乙': 2, '丙': 1&#125;到底需要拿出多少钱奖励呢? 甲乙丙三组人分别占比多少呢? 针对这样的需求, 我们尝试着用组合模式计算一下.叶对象与分支对象上面也提到了, 组合模式中有两类对象. 一个是分支对象, 一个是叶对象. 分支对象是叶对象的集合, 保存着叶对象的引用, 可以操作叶对象(比如添加, 执行). 而叶对象只要暴露接口即可.现在我们从简单的开始, 造一个生产叶对象的函数.12345678const leaf = params =&gt; &#123; return &#123; ...params, expense() &#123; return scaleMap[params.scale]*params.salary &#125; &#125;&#125;;分支对象就稍微麻烦些了, 因为需要管理叶对象.1234567891011121314const branch = params =&gt; &#123; return &#123; ...params, members: [], add(item) &#123; this.members.push(item) &#125;, expense() &#123; return this.members.reduce((sum, item) =&gt; &#123; return sum + item.expense() &#125;, 0) &#125; &#125;&#125;;expense() 的方法不论是在分支对象还是叶对象上, 或者说不清楚是分支对象还是叶对象, 我们都可以得到相应的结果. 在分支对象里, 保存着叶对象的引用, 我们可以对叶对象进行任何操作.从JSON数据到树形结构组合模式就是这么简单, 剩下的就是如何 JSON 数据转换成层次分明的结构了.123456789101112131415161718192021222324const convertData = array =&gt; &#123; const branchList = []; const branchObjs = []; array.forEach(item =&gt; &#123; let leafObj = leaf(item); if (!branchList.includes(item.scale))&#123; let params = &#123; scale: item.scale &#125; let branchObj = branch(params) branchObjs.push(branchObj) branchList.push(item.scale) &#125; branchObjs.filter(obj =&gt; obj.scale == item.scale)[0].add(leafObj); &#125;) return branchObjs;&#125;console.log('branchObjs', convertData(persons))const scaleA = convertData(persons)[0];const scaleB = convertData(persons)[1];const scaleC = convertData(persons)[2];console.log('甲', scaleA.expense())console.log('乙', scaleB.expense())console.log('丙', scaleC.expense())最终结果展示如果我们想知道公司的总支出, 也可以把 scaleA, scaleB, scaleC 组合在一起作为公司的一子集.12345const company = branch();company.add(scaleA);company.add(scaleB);company.add(scaleC);company.expense()不难发现, 我们可以随意组装对象而不会影响到其它节点, 任何一个集合或个体都能够单独运行. 我们也可以根据需要去组合更复杂的结构. 但是, 如果通过组合模式创建了太多的对象, 那么这些对象可能会让系统负担不起.小结组合模式对象形式上至少有两种, 分支对象和叶对象.分支对象和叶对象拥有相同的接口, 且对一组叶对象操作具有同步一致性.组合模式是 HAS-A (聚合)关系, 不是 IS-A.]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>组合模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[咬文嚼字说策略]]></title>
    <url>%2F%E5%92%AC%E6%96%87%E5%9A%BC%E5%AD%97%E8%AF%B4%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[设计模式是: 在面向对象软件过程中针对特定问题的简洁而优雅的解决方案. 通过对封装、继承、多态、组合等技术的反复利用, 提炼出可重复使用面向对象的设计技巧.JavaScript 可以模拟实现传统面向对象语言的设计模式. 然而仅仅是生搬硬套, 未免会失去 JavaScript 的灵活性. 不如溯本求源, 看看这些设计模式到底在传达什么, 然后遵循此点.策略模式定义策略模式: 定义一系列的算法, 把它们一个个封装起来, 并且使它们可以相互替换.字面意思, 就是定义封装多种算法, 且各个算法相互独立. 当然, 也不仅仅是算法. 只要定义一些规则, 经处理后输出我们想要的结果就成. 在此我们称单个封装后的算法为一个策略. 一系列封装后的算法称为一组策略.一个基于策略模式的程序至少由两部分组成. 第一部分是一组策略类, 策略类封装了具体的算法, 并负责具体的计算过程. 第二部分是环境类 Context, Context 接受客户的请求, 随后把请求委托给某一个策略类.这是面向传统面向对象语言中的说法. 在面向对象思想中, 通过对组合, 多态等技术的使用来实现一个策略模式. 在 JavaScript 中, 对于一个简单的需求来说, 这么做就有点大材小用了.所以, 上面的那句话, 我们换种说法就是, 策略模式需要至少两部分, 一部分是保存着一组策略. 另一部分则是如何分配这些策略, 即如何把请求委托给某个/些策略. 其实这也是策略模式的目的, 将算法的使用与算法的实现分离.评级快到年底了, 公司打算制定一个标准用来给员工评级发福利.考核项目\等级甲乙丙A100&gt;a&gt;=9090&gt;a&gt;=8080&gt;a&gt;=70B100&gt;b&gt;=9090&gt;b&gt;=8080&gt;b&gt;=70以A、B考核项目来评定甲乙丙等级.现有考核人员:考核项目\考核人person_1person_2person_3A809392B85709012345const persons = [ &#123;A: 80, B: 85&#125;, &#123;A: 93, B: 70&#125;, &#123;A: 92, B: 90&#125;]在策略模式中一部分, 我们提到的分配策略. 要想分配策略, 首先就要知道所有的策略, 只有这样我们才能针对性的委托给某个/些策略. 这, 也是策略模式的一个缺点.常规操作甲乙丙等级对 A、B 的分值要求是不一样的. 所以我们可以这么做:1234567891011121314151617181920function rating(person) &#123; let a = person.A; let b = person.B; if (a &gt;= 90 &amp;&amp; b &gt;= 90) &#123; return '甲'; &#125; else if (a &gt;= 80 &amp;&amp; b &gt;= 80) &#123; return '乙'; &#125; else if (a &gt;= 70 &amp;&amp; b &gt;= 70) &#123; return '丙' &#125; else &#123; console.log('凭啥级, 还不赶紧卷铺走人'); &#125;&#125;persons.forEach(person =&gt; &#123; person.rate = rating(person);&#125;)// &gt; persons// [ &#123; A: 80, B: 85, rate: '乙' &#125;,// &#123; A: 93, B: 70, rate: '丙' &#125;,// &#123; A: 92, B: 90, rate: '甲' &#125; ]策略模式下的评级如果换成策略模式, 第一部分就是保存一组策略. 现在我们以甲乙丙三种定级标准来制定三种策略, 用对象来存贮策略. 考虑到以后可能有 D、E、F 等考核项目的存在, 我们稍微改一下:1234567891011121314151617181920const strategies = &#123; '甲': (person, items) =&gt; &#123; const boolean = items.every(item =&gt; &#123; return person[item] &gt;= 90; &#125;); if (boolean) return '甲'; &#125;, '乙': (person, items) =&gt; &#123; const boolean = items.every(item =&gt; &#123; return person[item] &gt;= 80; &#125;); if (boolean) return '乙'; &#125;, '丙': (person, items) =&gt; &#123; const boolean = items.every(item =&gt; &#123; return person[item] &gt;= 70; &#125;); if (boolean) return '丙'; &#125;&#125;策略就制定好了. 对象的键对应着策略的名称, 对象的值对应着策略的实现. 然而, 我们发现, 任何一个策略都不能单独完成等级的评定. 可是, 我们有说一组策略只能选择其中一个么? 为了达成某个目的, 策略组封装了一组相互独立平等替换的策略. 一个策略不行, 那就组合呗. 这也是策略模式另一部分存在的意义, 即如何分配策略.123456789101112function rating(person, items) &#123; return strategies['甲'](person, items) || strategies['乙'](person, items) || strategies['丙'](person, items)&#125;persons.forEach(person =&gt; &#123; person.rate = rating(person, ['A', 'B'])&#125;)// &gt; persons// [ &#123; A: 80, B: 85, rate: '乙' &#125;,// &#123; A: 93, B: 70, rate: '丙' &#125;,// &#123; A: 92, B: 90, rate: '甲' &#125; ]逻辑的转移所有的设计模式都遵循一条原则. 即 “找出程序中变化的地方, 并将变化封装起来”.将不变的隔离开来, 变化的封装起来. 策略模式中, 策略组对应着程序中不变的地方. 将策略组制定好存贮起来, 然后想着如何去分配使用策略.当然, 如何制定策略和如何分配策略之间的关系十分紧密, 可以说两者相互影响.再次看看制定的策略, “找出程序中变化的地方, 并将变化封装起来”, 我们可以再次改造一下.1234567891011121314151617181920212223242526const strategies = &#123;'甲': 90,'乙': 80,'丙': 70,&#125;function rating(person, items)&#123; const level = value =&gt; &#123; return (person, items) =&gt; &#123; const boolean = items.every(item =&gt; &#123; return person[item] &gt;= strategies[value]; &#125;); if (boolean) return value; &#125; &#125; return level('甲')(person, items) || level('乙')(person, items) || level('丙')(person, items)&#125;persons.forEach(person =&gt; &#123; person.rate = rating(person, ['A', 'B'])&#125;)// &gt; persons// [ &#123; A: 80, B: 85, rate: '乙' &#125;,// &#123; A: 93, B: 70, rate: '丙' &#125;,// &#123; A: 92, B: 90, rate: '甲' &#125; ]在上面的这种做法中, 我们把制定策略的逻辑挪到了分配策略里了. 所以说, 如何制定策略和如何分配策略, 依情况而定.不过回头在看一看这段代码, 是不是和平时用对象映射的做法很相似.当然, 策略模式的用法还有很多, 最常见的是规则校验.小结总结一下:策略模式至少包括两部分, 制定策略和分配策略.策略模式的目的在于, 将策略制定和策略分配隔离开来.策略制定和策略分配关系密切, 相互影响.]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>策略模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初始化空对象数组]]></title>
    <url>%2F%E5%88%9D%E5%A7%8B%E5%8C%96%E7%A9%BA%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[初始化空对象数组在给对象设置属性时, 如果对象不存在很容易报错.有些场景, 在对对象数组处理时, 设置对象属性前判断对象是否存在. 与其这样, 还不如直接初始化为空对象数组.9个考生就来了6个考试时, 每个考生都有自己位置. 考生对照着可以很容易在考场里找到自己的座位. 秉着公平、公正、公开的原则, 考生被稀疏地散布在考场的各个角落. 假设考场 3*3 排列, 考生的信息:123456[&#123;"row":1,"col":1,"name":"Ada"&#125;, &#123;"row":3,"col":3,"name":"Aaron"&#125;, &#123;"row":1,"col":2,"name":"Aditi"&#125;, &#123;"row":3,"col":2,"name":"Aditi"&#125;, &#123;"row":1,"col":3,"name":"Aditi"&#125;, &#123;"row":3,"col":1,"name":"Abbott"&#125;]将考场位置做成一个表格, 对考生位置按排统计, 来标注考生出勤情况.123[&#123;"row":1,"col_1":"Ada","col_2":"Aditi","col_3":"Aditi"&#125;, &#123;&#125;, &#123;"row":3,"col_3":"Aaron","col_2":"Aditi","col_1":"Abbott"&#125;](为嘛没有第二排? 自知考不过, 缺考了呗🙁)开发中, 对原始数据进行处理是一件很平常的事. so, 这个数据的处理应该很简单…吧😅Array(3).fill({}) 试一波如何初始化空对象数组?原始数据是以学生个体的信息存储展示的, 现在则按排为单位对数据进行处理. 理所当然的会想到先初始化三个空对象数组.123let studentRow = Array(3).fill(&#123;&#125;)// &gt; studentRow// [ &#123;&#125;, &#123;&#125;, &#123;&#125; ]动作很快姿势很帅. 不过, 这样真的可以么? 长得倒是像那么一回事, 可实际上完全行不通. Array.prototype.fill() 的用法是, 指定某个值来填充数组.也就是说, {} 在 studentRow 里复制了三次. 如果是简单类型值倒也罢了, 但是换做复杂类型值, 修改每一个 {} , 都会影响其它的 {}. 因为它们都是对同一个对象的引用.1234567891011121314151617let studentRow = Array(3).fill(&#123;&#125;);studentRow[0].name = 'tony';// &gt; studentRow// [ &#123; name: 'tony' &#125;,// &#123; name: 'tony' &#125;,// &#123; name: 'tony' &#125; ]// 等同于let obj = &#123;&#125;;let studentRow = Array(3).fill(obj);// &gt; studentRow// &#123;obj, obj, obj&#125;studentRow[0].name = 'tony';// &gt; studentRow// [ &#123; name: 'tony' &#125;,// &#123; name: 'tony' &#125;,// &#123; name: 'tony' &#125; ]知识点:将一个值赋予变量时, 解析器必须确定这个值是基本类型值还是复杂类型值.当是复杂类型值时, 变量里保存的是该复杂类型值在堆中的一个指针. 复制的是变量的指针, 操作的却是实际的对象.Array(3) 和 map(() =&gt; {}) 结合有问题Array(3).fill({}) 行不通. 那么, Array(3).map(() =&gt; {})?如果说 Array(3).fill({}) 不可行, 是因为三个空对象是对同一个对象的引用. 那么我们就设法返回三个不同的空对象.123let studentRow = Array(3).map(() =&gt; &#123;&#125;);// &gt; studentRow// [ &lt;3 empty items&gt; ]结果很失望, 这个表达式就干了两件事, Array(3) 和 map(() =&gt; {}). 所以问题很好排查.123let arr = Array(3);// &gt; arr// [ &lt;3 empty items&gt; ]对于数组中并不存在的单元, map() 也是束手无策.我说: 肚里要有货🙏肚里没货, 我们就造一些. Array.prototype.fill() 又有出头之日了.123let studentRow = Array(3).fill(undefined);// &gt; studentRow// [ undefined, undefined, undefined ]警告:如若一个数组没有任何单元, 但它的 length 属性中却显示有单元数量, 这样奇特的数据结构会导致一些怪异的行为. 我们将包含至少一个 “空单元” 的数组称之为 “稀疏数组”. undefined 单元非 “空单元”.永远不要创建和使用空单元数组.箭头函数中的 return你以为 Array(3).fill(undefined).map(() =&gt; {}) 就完事了? 图样图森破 👼123let studentRow = Array(3).fill(undefined).map(() =&gt; &#123;&#125;);// &gt; studentRow// [ undefined, undefined, undefined ]哦, 我知道了, 你没有 return 啊额, 这和 return 没有关系. 不信你可以加一个试试😏其实, {} 在这里被视作语法块了, 没有任何意义. 可恨就可恨在, 它和空对象长得一摸一样.既然这样, 那我们就不用字面量定义一个空对象了.1234let studentRow = Array(3).fill(undefined).map(() =&gt; Object.create(null));studentRow[0].name = 'tony';// &gt; studentRow// [ &#123; name: 'tony' &#125;, &#123;&#125;, &#123;&#125; ]这样就达到初始化对象数组的目的了. 可是, Array(3).fill(undefined).map(() =&gt; {}) 为什么行不通, 如何补救?规避问题在某种意义上不等于解决问题.{...} 里面的代码会被解析为一系列语句. {} 也因此不能达到我们预期的结果. 所以, 我们可以用 (...) 将 {} 包装成表达式, 即 ({}).1234let studentRow = Array(3).fill(undefined).map(() =&gt; (&#123;&#125;));studentRow[0].name = 'tony';// &gt; studentRow// [ &#123; name: 'tony' &#125;, &#123;&#125;, &#123;&#125; ]知识点:若函数体的表达式个数多于一个, 或者函数题包含非表达式语句的时候才需要用 {...} 包裹.如果只有一个表达式, 并且省略了 {...} 的话, 则附加一个隐式 return. 若在块体内需要指定返回值, 则需要明确的 return.箭头函数提供了简练的语法, 但不是普通函数的替代品. 箭头函数的主要设计目的是改变 this 的行为. 普通函数内的 this 是动态绑定, this 指向谁取决于调用者. 而箭头函数里的 this 是基于作用域的, 是可预测的.(可参考从游戏角度说作用域).令人绝望的Array.prototype.fill()你以为结束了, 其实才刚刚开始这是真正的开始, 没看错, 是的, 我们之前所做的可能都是无用功.是的, IE 是魔鬼. 费尽了周折, 才发现一切都是徒劳.难道就这么放弃了?‘放弃’能吃么? 能吃就吃了它, 啥? 不能吃?!? 提它作甚!!!Array.prototype.fill() 方便之处就是能够简便填充数组. 此法不行, 另寻他法.Function.prototype.apply() 了解一下Function.prototype.apply() 入参有两个. 第一个参数是 函数方法 的调用者, 第二个参数是 函数方法 的入参(要区分入参和入参的不同). 函数方法 的入参可以是数组也可以是类数组. 我们的目的就是填充数组, 所以我们要在类数组上做文章. 就拿 console.log 做例子🌰. (直接复制我之前的博客内容😌).1234567891011121314151617function log_1(arg) &#123;console.log(arg)&#125;log_1(1);log_1(1,2,3);// 1// 1// 改造下function log_2() &#123; const log = console.log; log.apply(null, arguments)&#125;log_2(1);log_2(1, 2, 3)// 1// 1 2 3这是 Function.prototype.apply() 使用的方法. 如果我们把 log_2 里的 arguments 换成 {length: 3},123456function log_2() &#123; const log = console.log; log.apply(null, &#123;length: 3&#125;)&#125;log_2()// undefined undefined undefined{length: 3} 和 [undefined, undefined, undefined] 在传入 apply(null;...) 后, 在参数的处理上, 最后的结果是一样的.那么, Array(3).fill(undefined).map(() =&gt; ({})) 可改造成,1234let studentRow = Array.apply(null, &#123;length: 3&#125;).map(() =&gt; (&#123;&#125;));studentRow[0].name = 'tony';// &gt; studentRow// [ &#123; name: 'tony' &#125;, &#123;&#125;, &#123;&#125; ]在这里 Array 作为普通函数调用, 以上等同于123let studentRow = Array(undefined, undefined, undefined);// &gt; studentRow// [ undefined, undefined, undefined ]收尾只是初始化一个空对象数组, 结果整出这么多幺蛾子.处理数据其实就那么几行代码. 大致长这模样,12345678function handleData(params) &#123; const studentRow = Array.apply(null, &#123;length: 3&#125;).map(() =&gt; (&#123;&#125;)); params.forEach(item =&gt; &#123; studentRow[item.row-1][`row`] = item.row; studentRow[item.row-1][`col_$&#123;item.col&#125;`] = item.name; &#125;) return studentRow;&#125;]]></content>
      <categories>
        <category>开发三两事</category>
      </categories>
      <tags>
        <tag>空对象数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从游戏角度说作用域]]></title>
    <url>%2F%E4%BB%8E%E6%B8%B8%E6%88%8F%E8%A7%92%E5%BA%A6%E8%AF%B4%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[作用域作用域是 JavaScript 里的一个非常重要和基础的概念. 很多人认为自己理解了作用域, 但是在遇到闭包时却说不出个所以然, 甚至不能识别出来.闭包也是个非常重要, 且经常被误解的概念. 然而闭包就是基于作用域书写代码时所产生的自然结果. 倘若抛开作用域讲闭包, 那都是耍流氓. 闭包可以说在平时的代码里随处可见, 但真正让闭包发挥积极作用的做法是隔离作用域、模块函数等.作用域机制是不能直接查看的, 我们首先模拟一个场景来尽可能的说明作用域这套规则, 然后通过代码片段和开发者工具进行验证.游戏存档想必大家都有玩过游戏的经验. 刚开始的时候, 也就是第一关, 难度比较简单. 到了第二关的时候, 就在第一关的基础上加些难缠的角色, 难度相应地加大了. 关卡越是往后, 难缠的角色也就会越来越多.可在游戏的时候, 由于各种原因, 往往我们不可能一下子通过所有的关卡, 所以游戏提供了存档的功能. 下次再玩的时候可以从存档里续上. 如果不想这样, 完全可以从头玩起.为什么我们能从存档里直接跳到上次的关卡, 很显然, 这里是有记录存储的. 比如第一关有个场景食人花和海王, 第二关又多了个邪恶人等等. 每个关卡都会记录该关卡新增的角色或场景同时也会存储之前关卡的记录. 这样就保证了不同的存档的独立性, 无论在哪个关卡存档, 下次也定会续上之前的地方. 当然了, 我们也可以回到上一个关卡.(海王之雄风&amp;敌人之邪恶)几个知识点结合上面的场景, 我们再回头看看以下几个知识点.标识符: 变量、函数、属性的名字, 或者函数的参数.每个函数都有自己的执行环境. 当执行流进入一个函数时, 函数的环境就会被推入一个环境栈中. 而在函数执行后, 栈将其环境弹出, 把控制权返回之前的执行环境.执行环境定义了变量或函数有权访问的其它数据. 每个执行环境都有一个与之关联的变量对象, 环境中定义的所有变量和函数都保存在这个对象中. 某个执行环境中的所有代码执行完毕后, 该环境被销毁, 保存在其中的所有变量和函数定义也随之销毁.当代码在一个环境中执行时, 会创建变量对象的一个作用域链.作用域链是保证对执行环境有权访问的所有变量和函数的有序访问. 作用域的前端始终都是当前执行的代码所在的变量对象. 如果这个环境是函数, 则将其活动对象作为变量对象. 活动对象在最开始只包含一个变量, 即 arguments 对象. 作用域链中的下一个变量对象来自包含(外部)环境. 全局执行环境的变量对象始终都是作用域链的最后一个对象.当某个环境中为了读取或写入而引入一个标识符时, 必须通过搜索来确定该标识符来确定该标识符实际代表什么. 搜索过程从作用域链的前端开始, 向上逐级查询与给定名字匹配的标识符. 如果在局部环境中找到了该标识符, 搜索过程停止, 变量就绪. 如果在局部环境中没有找到该变量名, 则继续沿作用域链向上搜索. 搜索过程将一直追溯到全局环境的变量对象. 如果在全局环境中也没有找到这个标识符, 则意味着该变量尚未声明.作用域链本质上时一个指向变量对象的指针列表, 它只引用但实际不包含变量对象.如果我们把以上的几个知识点串起来, 这就是所谓的作用域链规则了. 上图解释一波.(arguments 应该加到变量对象里的, 图中没体现, 疏忽)现在我们从最后两行说起,12var outer = outerFn(10);var inner = outer(10);执行 outer = outerFn(10) 后, outer 拥有了返回函数的引用. outer(10) 在执行的时候它会创建 属于它自己 的作用域链, 这里包含函数所处外部环境的变量对象.在读取 initial 变量时, 在 Inner 变量对象中没有检索到, 它会沿着作用域链向上搜索, 在 outer 变量对象里找到了该标识符, 搜索过程停止, 变量就绪.函数在定义的时候就已经决定了之后执行时, 作用域里将包含什么. 这也解释了, 即使我们把定义在函数内部的函数扔在外边执行也能访问到函数内部的变量. 这和内部函数在哪执行没有半毛钱关系.为什么强调 属于它自己 的呢?12345678910111213function outer() &#123; var num = 0; return function inner() &#123; return num++; &#125;&#125;let innerFn_1 = outer();let a_1 = innerFn_1()let innerFn_2 = outer();let a_2 = innerFn_2();let a_1_1 = innerFn_1();let a_2_2 = innerFn_2();innerFn_1 和 innerFn_2 都属于自己的作用域链, 而 a_1 和 a_2 则分别在 innerFn_1 和 innerFn_2 上创建了属于自己的作用域链. 所以它们函数里的 num 是属于不同作用域链里的变量. 但对于 a_1 和 a_1_1 来说它们都是基于 innerFn_1, 拥有同一 outer 变量对象, num 自然也是同一个, 所以会累加. 同理 a_2 和 a_2_2.如果理解了这个, 那么面试常考的一题就小菜一碟了.12345for(var i = 1; i &lt;= 5; i++) &#123; setTimeout(function timer() &#123; console.log(i); &#125;, i*1000)&#125;重点是执行的时候才会创建变量对象的一个作用域链.闭包是什么?如果理解了以上的概念, 就会觉得闭包是作用域埋的一个彩蛋, 用的好就是惊喜, 用的不好就成惊吓了.当函数可以记住并访问所在的作用域, 即使函数是在当前作用域之外执行, 这时就产生了闭包. 这就和之前提到的游戏存档差不多.好了, 扔几个闭包出来巩固一下.12345678910function outer_1() &#123; var a = 'hello world'; function inner() &#123; console.log(a) &#125; outer_2(inner)&#125;function outer_2(fn) &#123; fn()&#125;这里也有闭包.12345678var a = new array(99999999);function b() &#123; console.log(b)&#125;b()body.addEventListener('click', function() &#123; console.log('hello world')&#125;)还有开头所说的可以结合开发者工具直观地看一下, 一张动态图解释一切.内存泄漏闭包之所以能成为闭包, 是因为它记录了函数所在的作用域. 现主流的自动垃圾收集机制正因为闭包的这个特点而不能释放内存. 闭包的滥用会导致导致内存能分配的空间变少, 最终崩溃.正常来说, 函数在执行的过程中, 局部变量会被分配相应的内存空间, 以便存储它们的值, 直至函数执行结束. 此时局部变量占有的空间会被释放以供将来使用.常说的回收机制之一, 标记清除, 它的工作原理是, 当变量进入执行环境时, 储存在内存中的所有变量都会被加上标记(至于什么标记我们不关心), 然后找到 环境中的变量 以及 被环境中引用的变量, 把它们之前加的标记给去掉. 而剩下的被标记的变量将被视为 准备 删除的变量. 最后, 垃圾收集器找出不再继续使用的变量, 释放其占用的内存. 所以, 一旦数据不再被需要, 应解除引用, 将其值设置为null.12outer = null;inner = null;内部函数的执行环境会保存着外部环境活动对象的引用, 内部函数被扔出去后, 就意味着外部环境不能被销毁了.this执行环境里记录的不只是这些, 它也记录了函数调用栈、函数调用方式等. this 和作用域有关系, 但不是你们想象的那种关系. 每个函数在被调用时都会自动取得两个特殊变量: this 和 arguments. 内部函数在搜索这两个变量时, 只会搜索到其活动对象为止(即当前变量对象). 因此永远不可能直接访问到外部函数中的这两个变量. 除非我们把外部作用域中的 this 对象保存在一个闭包能够访问到的变量里.123456789// 很常见是不是😂let obj = &#123; a: function() &#123; var self = this; return function() &#123; console.log(self) &#125; &#125;&#125;函数内部的 this 在函数执行时才正式被赋予相应的值, 所以说函数的调用位置很关键. 可以这么说, 谁 直接 调用了这个函数, this 就指向了谁. 如果不是对象在直接调用这个函数, 我们可统统认为是 undefined, 非严格模式浏览器环境下就是 window. 如果真想知道为什么, 可以直接看规范(神烦).1234567891011121314151617181920'use strict'function a() &#123; console.log(this)&#125;var b = &#123; a: function() &#123; console.log(this); &#125;, b: function() &#123; return a; &#125;&#125;let b_a = b.a;a(); //1. undefined;b_a(); //2. undefined;b.a(); //3. &#123;a: f, b: f&#125;;b.b()(); //4. undefined;(true &amp;&amp; b.a)() //5. undefined;new a(); //6. &#123;&#125;b.call(b); //7. &#123;a: f, b: f&#125;;从 1~6, 我们看看哪个对象直接调用了该函数. 第 1 个没找到调用对象, 就是个普通函数调用. 第 2 个经过 b_a = b.a 赋值操作后, 返回的就是那个普通函数, 就是一普通的函数调用. 第 3 个很直接, 就是 b 这个对象了. 第 4 个是个闭包, 首先 this 只在当前活动对象里找 this 对象, 不知道是哪个对象, 但肯定不会是 b. 第 5 个和第 2 个是一个道理. 第 6 个吧, 貌似不算是函数调用了吧, 不过我们知道, this 是指向新创建的空对象. 第 7个就更直接了, 人家都指名道姓就差喊出来了.this 绑定对象的几条准则貌似在我这里就只剩一条了😌.]]></content>
      <categories>
        <category>很难么</category>
      </categories>
      <tags>
        <tag>闭包</tag>
        <tag>作用域</tag>
        <tag>this</tag>
        <tag>内存泄漏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Object原型方法]]></title>
    <url>%2FObject%E5%8E%9F%E5%9E%8B%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[ObjectObject 构造函数用来包装成对象.概述Object 构造函数为给定值创建一个对象包装器. 如果给定值是 null 或 undefined, 将会创建并返回一个空对象. 否则, 将返回一个与给定值对应类型的对象.当以非构造函数形式被调用时, Object 等同于 new Object().原型方法Object.prototype.hasOwnProperty()描述 : 判断自身属性中是否有指定的属性.语法 :target.prototype.hasOwnProperty(prop)target : 目标对象.prop : 要检测的属性.123456789101112function Person(name) &#123; this.name = name&#125;Person.prototype.age = 18let person = new Person('yexiaochen')let boolean_1 = person.hasOwnProperty('name')let boolean_2 = person.hasOwnProperty('age')// &gt; boolean_1// true// &gt; boolean_2// falseObject.prototype.isPrototypeOf()描述 : 判断一个对象是否在另一个对象的原型链上.语法 :prototypeObject.isPrototypeOf(obj)obj : 提供原型链的对象.prototypeObject : 待检测的对象.123456789101112function Person() &#123;&#125;function Man()&#123;&#125;Man.prototype = Object.create(Person.prototype)let man = new Man()let boolean_1 = Person.prototype.isPrototypeOf(man)let boolean_2 = Man.prototype.isPrototypeOf(man)// &gt; boolean_1// true// &gt; boolean_2// trueObject.prototype.propertyIsEnumerable()描述 : 判断对象的指定属性是否可枚举. 原型链上继承来的属性除外. 如果对象没有指定的属性，则此方法返回false语法 :target.propertyIsEnumerable(prop)target : 目标对象.sources : 待检测的属性.123456789101112function Person(name) &#123; this.name = name&#125;Person.prototype.age = 18let person = new Person('yexiaochen')let boolean_1 = person.propertyIsEnumerable('name')let boolean_2 = person.propertyIsEnumerable('age')// &gt; boolean_1// true// &gt; boolean_2// falseObject.prototype.toString()描述 : 一个表示该对象的字符串语法 :target.toString()target : 目标对象.1234567891011function Person() &#123;&#125;let person = new Person()let str_1 = person.toString();let str_2 = Object.prototype.toString.call(person)let str_3 = Object.prototype.toString.call(Person)// &gt; str_1// '[object Object]'// &gt; str_2// '[object Object]'// &gt; str_3// '[object Function]'Object.prototype.valueOf()描述 : 对象转换为原始值. 如果对象没有原始值, 返回对象本身.语法 :target.valueOf()target : 目标对象.123456789101112131415161718192021222324let str = new String('hello world')let num = new Number(0)let boolean = new Boolean(true)let arr = [1,2,3]let func = function a()&#123;&#125;let obj = &#123;a: 'hello'&#125;str.valueOf()num.valueOf()boolean.valueOf()arr.valueOf()func.valueOf()obj.valueOf()// &gt; str.valueOf()// 'hello world'// &gt; num.valueOf()// 0// &gt; boolean.valueOf()// true// &gt; arr.valueOf()// [ 1, 2, 3 ]// &gt; func.valueOf()// [Function: a]// &gt; obj.valueOf()// &#123; a: 'hello' &#125;]]></content>
      <categories>
        <category>API总结</category>
      </categories>
      <tags>
        <tag>Object</tag>
        <tag>对象原型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对象属性的属性]]></title>
    <url>%2F%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E7%9A%84%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[引子vue 的大行其道, 使得 Object.defineProperty 被更多人所认识. vue 利用 Object.defineProperty 提供的特性实现了数据绑定. 我们也可以据此动手实现一个简单的数据绑定(可参照进击的观察者模式).难道 Object.defineProperty 能做的只有这些么? 很显然不是.属性描述符The Property Descriptor type is used to explain the manipulation and reification of Object property attributes.属性描述符到底是什么? 说白了就是对象属性的属性解释与具化, 就是对象属性本身具有哪些属性.平时我们创建一个对象并为对象添加属性时, 可以这样12let obj = new Object()obj.a = 'hello world'有了对象字面量后, 想要达到同样的效果就更加省事了. 现在也都提倡使用字面量来创建对象.123let obj = &#123; a: 'hello world'&#125;所以说程序员都是懒人嘛, 怎么简单怎么来. 通过 Object.defineProperty 为对象添加属性的方式也就淡出人们的视野.同样是为对象添加属性, 它们有什么区别呢?程序员身体可以懒, 但脑子要勤快, 要始终保持一颗好奇心.其实不论是通过赋值, 还是通过字面量, 还是通过 Object.defineProperty, 最终还是殊途同归.讲真, 平时的开发中, 使用对象字面量创建对象并添加属性时,压根就不会考虑到对象属性非个人意愿的改变了. 在我们看来, 对象就是存储着键值、键值映射用的. 我们可以任意添加, 删除, 更改对象属性, 我们认为这是理所当然的. 现实也的确如此, 你有对它为所欲为的权利.添加属性的差异可是为什么呢?🧐😠你哪来的那么多为什么? 你为什么为什么呢!!!😠如果你稍微对 Object.defineProperty 有点了解, 应该知道通过这种方式定义的繁琐. 你也应该知道对象属性的操作也是有限制的. 想要放开权限, 我们需要这样做1234567let obj = &#123;&#125;Object.defineProperty(obj, 'a', &#123; value: 'hello world', configurable: true, enumerable: true, writable: true&#125;)对象字面量添加属性只是默认都为 true. 所以我们才可以为所欲为. 不相信么? 我们可以通过 Object.getOwnPropertyDescriptor 验证一下12345678let obj = &#123;&#125;obj.a = 'hello world'let property = Object.getOwnPropertyDescriptor(obj, 'a')// &gt; property// &#123; value: 'hello world',// writable: true,// enumerable: true,// configurable: true &#125;通过 Object.getOwnPropertyDescriptor 添加的属性, 可以自由灵活地设置属性描述符. 如果我不想配置的话, 它也有自己的默认值. 需要注意的是, 这里的默认值和对象字面量添加属性与赋值属性不同, 默认值为 false.12345678910let obj = &#123;&#125;Object.defineProperty(obj, 'a', &#123; value: 'hello world'&#125;)let property = Object.getOwnPropertyDescriptor(obj, 'a')// &gt; property// &#123; value: 'hello world',// writable: false,// enumerable: false,// configurable: false &#125;属性描述符等位数据描述符和访问描述符. 以上说的都是数据描述符.传闻中的Vue优化方案道理我都懂, 那你这句话是啥个意思?压根就不会考虑到对象属性非个人意愿的改变了.在 Vue 的 data 选项中，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 中的访问描述符 get/set 访问描述符重新定义一遍. 再结合观察者模式, 每次属性变化时都会收到通知, 从而达到数据绑定的效果. 显然并不是所有的属性都需要被转换监听.对于展示型的数据, 就没有必要也不会出现数据内部属性的变化, 所以没必要做以上的处理. Object.freeze (用法可见Object构造函数)处理后的对象, 就可以使得对象属性添加、修改等操作失效. 这样不去转换也不用去监听, 性能自然也就提高了.属性描述符键值枯燥的描述开始…数据描述符和访问描述符同事具有的键值configurable : 若为 false, 不能删除该属性, 不能切换属性描述符(数据描述符切到访问描述符,或访问描述符切到数据描述符), 不能更改该属性的属性(对于数据描述符来说, value 属性除外, Writable 属性从 true 置为 false 除外). 说白了就是属性描述符的开关, 管理着该属性的属性.123456789101112131415161718192021222324252627282930313233let obj = &#123;&#125;Object.defineProperty(obj, 'a', &#123; value: 'hello world', configurable: false, enumerable: true, writable: true&#125;)Object.defineProperty(obj, 'a', &#123; value: 'hi world',&#125;)let property_1 = Object.getOwnPropertyDescriptor(obj, 'a')Object.defineProperty(obj, 'a', &#123; value: 'hi world', writable: false&#125;)let property_2 = Object.getOwnPropertyDescriptor(obj, 'a')// &gt; property_1// &#123; value: 'hi world',// writable: true,// enumerable: true,// configurable: false &#125;// &gt; property_2// &#123; value: 'hi world',// writable: false,// enumerable: true,// configurable: false &#125;Object.defineProperty(obj, 'a', &#123; value: 'hi world', configurable: false, enumerable: false&#125;)// TypeErrorenumerable : 若为 true, 则在 for…in 枚举中可被枚举到.1234567891011let obj = &#123; a: 'hello world', b: 'hi world'&#125;Object.defineProperty(obj, 'c', &#123; value: 'hey world', enumerable: false&#125;)let propertyArray = Object.keys(obj)// &gt; propertyArray// [ 'a', 'b' ]仅数据描述符具有的键值value : 对象的该属性对应的值. 可以为任何有效的 JavaScript 值.writable : 若为false, 更改 value 将会失败.12345678910111213141516171819202122let obj = &#123;&#125;Object.defineProperty(obj, 'a', &#123; value: 'hello world', writable: false, configurable: true&#125;)obj.a = 'hi world'let property_1 = Object.getOwnPropertyDescriptor(obj, 'a')Object.defineProperty(obj, 'a', &#123; value: 'hey world'&#125;)let property_2 = Object.getOwnPropertyDescriptor(obj, 'a')// &gt; property_1// &#123; value: 'hello world',// writable: false,// enumerable: false,// configurable: true &#125;// &gt; property_2// &#123; value: 'hey world',// writable: false,// enumerable: false,// configurable: true &#125;从运行结果可以看出, 通过赋值更改属性值时, 会更改无效.但是通过 Object.defineProperty 更改时, 将会成功更改属性值. 对此, 规范有提到, 当可配置不可写时更改属性值,会有 Writable 置为 true, =&gt; 设置 value =&gt; Writable 置为 false.Step 8.b allows any field of Desc to be different from the corresponding field of current if current’s [[Configurable]] field is true. This even permits changing the [[Value]] of a property whose [[Writable]] attribute is false. This is allowed because a true [[Configurable]] attribute would permit an equivalent sequence of calls where [[Writable]] is first set to true, a new [[Value]] is set, and then [[Writable]] is set to false.通过赋值和 Object.defineProperty 方式修改 value, 可以看出它们内部操作还是存在着差异.仅访问描述符具有的键值get : 访问该属性时, 该方法都会被执行.set : 修改该属性时, 该方法都会被执行.vue 就是利用了访问描述符的这些特性, 实现了数据绑定.12345678910111213141516171819202122let obj = &#123;&#125;let valObject.defineProperty(obj, 'a', &#123; set(value) &#123; val = value console.log('set =&gt; value', val) &#125;, get() &#123; console.log('get =&gt; value', val) return val &#125;, configurable: true, enumerable: true&#125;)// &gt; obj// &#123; a: [Getter/Setter] &#125;// &gt; obj.a = 'hello world'// set =&gt; value hello world// 'hello world'// &gt; obj.a// get =&gt; value hello world// 'hello world']]></content>
      <categories>
        <category>API总结</category>
      </categories>
      <tags>
        <tag>属性描述符</tag>
        <tag>defineProperty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Object构造函数]]></title>
    <url>%2FObject%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[ObjectObject 构造函数用来包装成对象.概述Object 构造函数为给定值创建一个对象包装器. 如果给定值是 null 或 *undefined, 将会创建并返回一个空对象. 否则, 将返回一个与给定值对应类型的对象.当以非构造函数形式被调用时, Object 等同于 new Object().构造函数方法Object.keys()描述 :获取给定对象自身可枚举属性(字符串)组成的数组.Object.keys(target)target : 目标对象.12345678910111213141516171819let obj = &#123; a: 'hello'&#125;Object.defineProperty(obj, 'b', &#123;value: 'world'&#125;)let property_1 = Object.getOwnPropertyDescriptor(obj, 'a')let property_2 = Object.getOwnPropertyDescriptor(obj, 'b')let propertyArray = Object.keys(obj);// &gt; property_1// &#123; value: 'hello',// writable: true,// enumerable: true,// configurable: true &#125;// &gt; property_2// &#123; value: 'world',// writable: false,// enumerable: false,// configurable: false &#125;// &gt; propertyArray// [ 'a' ]Object.values()描述 :获取给定对象自身可枚举属性值组成的数组.Object.values(target)target : 目标对象.12345678910111213141516171819202122let obj = &#123; a: 'hello', b: () =&gt; &#123; console.log('hello') &#125;&#125;Object.defineProperty(obj, 'c', &#123;value: 'world'&#125;)let property_1 = Object.getOwnPropertyDescriptor(obj, 'a')let property_2 = Object.getOwnPropertyDescriptor(obj, 'c')let valuesArray = Object.values(obj);// &gt; property_1// &#123; value: 'hello',// writable: true,// enumerable: true,// configurable: true &#125;// &gt; property_2// &#123; value: 'world',// writable: false,// enumerable: false,// configurable: false &#125;// &gt; valuesArray// [ 'hello', [Function: b] ]Object.entries()描述 :由给定对象自身可枚举属性的键值对数组组成的数组. 属性的顺序与通过 for...in 循环对象的属性值所给出的顺序相同.语法 :Object.entries(target)target : 目标对象.1234567891011let obj_1 = &#123; a: 'hello', b: 'word'&#125;let obj_2 = Object.entries(obj_1)// &gt; obj_2// [ [ 'a', 'hello' ], [ 'b', 'word' ] ]let map = new Map(obj_2)// &gt; map// Map &#123; 'a' =&gt; 'hello', 'b' =&gt; 'word' &#125;Object.create()描述 :创建一个新对象, 并将内部属性 [[Prototype]] 指向源对象.语法 :Object.create(sources[, Properties])sources : 提供原型的源对象.Properties : 为新对象添加属性, 规则如同 Object.defineProperties(obj, Prototype).1234567let obj_1 = &#123; a: 'hello', b: 'word'&#125;let obj_2 = Object.create(obj_1, &#123;name: &#123;value: 'obj_2'&#125;&#125;)&gt;obj_2// &#123;name: 'obj_2', _proto_: &#123;a: 'hello', b: 'word'&#125;&#125;Object.assign()描述 :将源目标(一个或多个)对象中的所有可枚举属性值复制到目标对象中. 如果目标对象和源对象中存在相同的属性(键), 后者的属性将覆盖前者的属性. 最终返回目标对象.语法 :Object.assign(target, ..sources)target : 目标对象.sources : 源对象.1234567891011121314151617181920212223let obj_1 = &#123; a: 'hello', b: 'word'&#125;let copy = Object.assign(&#123;&#125;, obj)// &gt; copy// &#123; a: 'hello', b: 'word' &#125;// &gt; obj_1// &#123; a: 'hello', b: 'word' &#125;// &gt; copy === obj_1// falselet obj_2 = &#123; a: 'hi', b: 'world'&#125;let obj_3 = &#123; a: 'hello', b: 'world'&#125;Object.assign(obj_2, obj_3)// &gt; obj_2// &#123; a: 'hello', b: 'world' &#125;Object.defineProperty()描述 :为对象定义一个新属性或修改现有属性.语法 :Object.defineProperty(target, prop, descriptor)target : 要在其上定义或修改属性的目标对象.prop : 要定义或修改的属性属性名称.descriptor : 将被定义或修改的属性描述符.123456789101112131415let obj = &#123;&#125;Object.defineProperty(obj, 'a', &#123; value: 'hello world', configurable: false, enumerable: true, writable: true&#125;)let property = Object.getOwnPropertyDescriptor(obj, 'a')// &gt; obj// &#123; a: 'hello world' &#125;// &gt; property// &#123; value: 'hello world',// writable: true,// enumerable: true,// configurable: false &#125;Object.defineProperties()描述 :为对象定义一个新属性或修改现有属性.语法 :Object.defineProperties(target, propsDescriptor)target : 要在其上定义或修改属性的目标对象.propsDescriptor : 将被定义或修改的属性描述符对象.1234567891011121314151617181920212223242526272829let obj = &#123;&#125;Object.defineProperties(obj, &#123; 'a': &#123; value: 'hello world', configurable: false, enumerable: true, writable: true &#125;, 'b': &#123; value: 'hi world', configurable: false, enumerable: true, writable: true &#125;&#125;)let property_a = Object.getOwnPropertyDescriptor(obj, 'a')let property_b = Object.getOwnPropertyDescriptor(obj, 'b')// &gt; obj// &#123; a: 'hello world', b: 'hi world' &#125;// &gt; property_a// &#123; value: 'hello world',// writable: true,// enumerable: true,// configurable: false &#125;// &gt; property_b// &#123; value: 'hi world',// writable: true,// enumerable: true,// configurable: false &#125;Object.getOwnPropertyDescriptor()描述 :获取指定对象上某个自有属性对应的属性描述符.(自有属性即直接赋予该对象的属性, 非原型链继上查找到的属性)语法 :Object.getOwnPropertyDescriptor(target, prop)target : 目标对象.prop : 目标对象的属性名称.123456789101112131415161718192021let obj_1 = &#123; a: 'hello', b: &#123; c: 'world' &#125;, get c() &#123; return 'c' &#125;&#125;let obj_2 = Object.getOwnPropertyDescriptor(obj_1, 'a')let obj_3 = Object.getOwnPropertyDescriptor(obj_1, 'c')// &gt; obj_2// &#123; value: 'hello',// writable: true,// enumerable: true,// configurable: true &#125;// &gt; obj_3// &#123; get: [Function: get c],// set: undefined,// enumerable: true,// configurable: true &#125;Object.getOwnPropertyNames()描述 :获取指定对象的所有自有属性的属性名(包括不可枚举属性但不包括 Symbol 值作为名称的属性)组成的数组.语法 :Object.getOwnPropertyNames(target)target : 目标对象.prop : 目标对象的属性名称.123456789101112let obj_1 = &#123; a: 'hello', b: &#123; c: 'world' &#125;, get c() &#123; return 'c' &#125;&#125;let arr = Object.getOwnPropertyNames(obj_1)// &gt; arr// [ 'a', 'b', 'c' ]Object.getOwnPropertySymbols()描述 :获取给定对象所有的 Symbol 属性的数组.语法 :Object.getOwnPropertyNames(target)target : 目标对象.123456let obj = &#123;&#125;let a = Symbol('a')obj[a] = 'hello'var arr = Object.getOwnPropertySymbols(obj)// &gt; arr// [ Symbol(a) ]Object.preventExtensions()描述 :使得对象变得不可扩展. 即设置对象内部 [[Extensible]] 值为 false.Object.preventExtensions(target)target : 目标对象.12345678910111213141516171819202122232425let obj_1 = &#123; a: 'hello', b: &#123; c: 'world' &#125;&#125;let property_1 = Object.getOwnPropertyDescriptor(obj_1, 'a')let boolean_1 = Object.isExtensible(obj_1)Object.preventExtensions(obj_1)let property_2 = Object.getOwnPropertyDescriptor(obj_1, 'a')let boolean_2 = Object.isExtensible(obj_1)// &gt; property_1// &#123; value: 'hello',// writable: true,// enumerable: true,// configurable: true &#125;// &gt; property_2// &#123; value: 'hello',// writable: true,// enumerable: true,// configurable: true &#125;// &gt; boolean_1// true// &gt; boolean_2// falseObject.seal()描述 :使得对象变得不可扩展. 即设置对象内部 [[Extensible]] 值为 false. 对象属性的 [[Configurable]] 为 false.Object.seal(target)target : 目标对象.12345678910111213141516171819202122232425let obj_1 = &#123; a: 'hello', b: &#123; c: 'world' &#125;&#125;let property_1 = Object.getOwnPropertyDescriptor(obj_1, 'a')let boolean_1 = Object.isExtensible(obj_1)Object.seal(obj_1)let property_2 = Object.getOwnPropertyDescriptor(obj_1, 'a')let boolean_2 = Object.isExtensible(obj_1)// &gt; property_1// &#123; value: 'hello',// writable: true,// enumerable: true,// configurable: true &#125;// &gt; property_2// &#123; value: 'hello',// writable: true,// enumerable: true,// configurable: false &#125;// &gt; boolean_1// true// &gt; boolean_2// falseObject.freeze()描述 :冻结一个对象, 将不能向该对象添加新的属性, 不能修改、删除已有属性, 以及不能修改已有属性的可枚举性、可配置性、可写性. 如果属性是对象, 除非被冻结, 否则也是可以修改的. 数组作为对象, 被冻结后, 元素不可被修改. [[Extensible]] 内部属性为 false. 对象属性的 [[Configurable]] 为 false. 若是对象属性描述符为数据描述符, 则对象属性的 [[Writable]] 为 false.语法 :Object.freeze(target)target : 目标对象.1234567891011121314151617181920212223242526272829let obj_1 = &#123; a: 'hello', b: &#123; c: 'world' &#125;&#125;let property_1 = Object.getOwnPropertyDescriptor(obj_1, 'a')let boolean_1 = Object.isExtensible(obj_1)Object.freeze(obj_1)let property_2 = Object.getOwnPropertyDescriptor(obj_1, 'a')let boolean_2 = Objct.isExtensible(obj_1)obj_1.a = 'hi'obj_1.b.c = '世界'// &gt; obj_1// &#123; a: 'hello', b: &#123; c: '世界' &#125; &#125;// &gt; property_1// &#123; value: 'hello',// writable: true,// enumerable: true,// configurable: true &#125;// &gt; property_2// &#123; value: 'hello',// writable: false,// enumerable: true,// configurable: false &#125;// &gt; boolean_2// true// &gt; boolean_2// falseObject.isExtensible()描述 :判断一个对象是否可扩展的. 即是否可添加新的属性. 新对象 [[Extensible]] 默认为 true . Object.preventExtensions(target), Object.seal(target) 或 Object.freeze(target) 可将目标对象内部属性 [[Extensible]] 置为 false.语法 :Object.isExtensible(target)target : 目标对象.12345678let obj = &#123;&#125;let boolean_1 = Object.isExtensible(obj)Object.freeze(obj)let boolean_2 = Object.isExtensible(obj)// &gt; boolean_1// true// &gt; boolean_2// falseOObject.isSealed()描述 :判断一个对象是否被密封. 若对象的内部属性 [[Extensible]] 为 false, 返回 true. 若对象属性的 [[Configurable]] 为 true, 返回 false. 否则, 返回 false.语法 :Object.isSealed(target)target : 目标对象.123456789101112let obj = &#123;&#125;let boolean_1 = Object.isFrozen(obj)Object.defineProperty(obj, 'a', &#123;configurable: false&#125;)let boolean_2 = Object.isFrozen(obj)Object.preventExtensions(obj)let boolean_3 = Object.isFrozen(obj)// &gt; boolean_1// false// &gt; boolean_2// false// &gt; boolean_3// trueObject.isFrozen()描述 :判断一个对象是否被冻结. 若对象的内部属性 [[Extensible]] 为 false, 返回 true. 若对象属性的 [[Configurable]] 为 true, 返回 false. 若是对象属性描述符为数据描述符, 对象属性的 [[Writable]] 为 true, 返回 false. 否则, 返回 false.语法 :Object.isFrozen(target)target : 目标对象.12345678910111213141516171819202122232425let obj = &#123;&#125;let boolean_1 = Object.isFrozen(obj)Object.freeze(obj)let boolean_2 = Object.isFrozen(obj)// &gt; boolean_1// true// &gt; boolean_2// falselet obj = &#123;&#125;let boolean_1 = Object.isFrozen(obj)Object.defineProperty(obj, 'a', &#123;writable: false&#125;)let boolean_2 = Object.isFrozen(obj)Object.defineProperty(obj, 'a', &#123;configurable: false&#125;)let boolean_3 = Object.isFrozen(obj)Object.preventExtensions(obj)let boolean_4 = Object.isFrozen(obj)// &gt; boolean_1// false// &gt; boolean_2// false// &gt; boolean_3// false// &gt; boolean_4// trueObject.setPrototypeOf()描述 :使得对象变得不可扩展. 即设置对象内部 [[Extensible]] 值为 false. 对象属性的 [[Configurable]] 为 false.Object.setPrototypeOf(target, prototype)target : 目标对象.prototype : 原型对象(对象或 null).123456let obj_1 = &#123;a: 1&#125;let obj_2 = &#123;b: 2&#125;Object.setPrototypeOf(obj_2, obj_1)let proto_1 = Object.getPrototypeOf(obj_2)// &gt; proto_1// &#123; a: 1 &#125;Object.getPrototypeOf()描述 :获取给定对象的原型(内部 [[Prototype]] 属性的值). 若没有即成属性, 则返回 null.语法 :Object.getOwnPropertyNames(target)target : 目标对象.12345678910111213function Person() &#123;&#125;let person = new Person()let a = Object.getPrototypeOf(person)// &gt; a// Person &#123;&#125;let obj = &#123;&#125;let obj_1 = Object.create(obj)let obj_2 = Object.getPrototypeOf(obj_1)// &gt; obj_2// &#123;&#125;// &gt; obj_2 === obj// trueObject.is()描述 :判断两个值是否相等. 规则和抽象相等、严格相等不一样.语法 :Object.is(target1, target2)target : 需要比较的两个值.1234567Object.is(undefined, undefined) // trueObject.is(null, null) // trueObject.is(true, true) // trueObject.is(false, false) // trueObject.is(+0, +0) // trueObject.is(NaN, NaN) // true *Object.is(-0, -0) //true]]></content>
      <categories>
        <category>API总结</category>
      </categories>
      <tags>
        <tag>构造函数</tag>
        <tag>Object</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记不住的继承方式]]></title>
    <url>%2F%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[记不住的继承方式都说程序员是这个世界上最懒的人, 能躺着绝不坐着, 全干着复制黏贴的活.‘什么, 你说这套逻辑之前写过?!?! 速速把代码呈上来!!!’.最懒的人往往信奉着‘拿来主义’. 若只是简单的复制黏贴, 就会显得没有逼格.在 JavaScript 中, 重复用到的逻辑我们会用函数包装起来, 在合适且需要的情况下, 调用该函数即可. 而 apply, call, new 等方法也拓宽了函数的使用场景.除了这种借来的, 我们还有继承来的. 这就是常说的原型继承. 当对象本身没有要查询的属性或方法时, 它会沿着原型链查找, 找到了就会拿来使用. 这种’无’中生有的事, 不妨了解一下.预备知识默认情况下, 所有的原型对象都会自动获得一个 constructor (构造函数)属性, 这个属性是一个指向 prototype 属性所在函数的指针. 构造函数的原型 prototype 上 constructor 的初始值是构造函数本身. 即,1Function.prototype.constructor === Function // true由构造函数构造出来的实例本身没有 constructor 属性, 不过可以通过原型链继承这个属性.1234567// 以下person的constructor属性继承自Person.prototypefunction Person() &#123;&#125;Person.prototype.constructor === Person // truelet person = new Person();person.constructor === Person // trueperson.hasOwnProperty('constructor') === false // trueperson_1.constructor === Person.prototype.constructor // true简单数据类型和复杂数据类型赋值传参的区别.JavaScript 中变量不可能成为只想另一个变量的引用. 引用指向的是值. 复杂数据类型的引用指向的都是同一个值.它们相互之间没有引用/指向关系. 一旦值发生变化, 指向该值的多个引用将共享这个变化.new, apply, call 的函数调用模式.三者的共同点都是都是指定调用函数的 this 值. 这使得同一个函数可以在不同的语境下正确执行. new 更为复杂一些. 可大致模拟为,12345function new(constructor, arguments) &#123; let instance = Object.create(constructor.prototype) // 姑且称之为 new 的特性一 constructor.apply(instance, arguments) // 姑且称之为 new 的特性二 return instance&#125;很明显, new 的操作中包涵了 apply, call 要做的事. 在此大胆猜测一下, 在实现继承的过程中, 一旦同时出现 new 和 apply 或 call, 就会有重复交集的可能, 这时就需要想想是否有可以改进的地方.不着痕迹的拿来主义‘各单位请注意, 下面到我表演地时候了’‘上道具!’12345function Animal(name) &#123; this.name = name&#125;Animal.prototype.species = 'animal'function Leo() &#123;&#125; // 我是头小狮子想要无中生有, 那是不可能的😏, 所以我们准备了模板 Animal. Animal 有的东西, Leo 也想拥有.而且 Animal 能用地东西也同样适用于 Leo.所以, 我们期待 Leo 最终长成这个样子.1234function Leo(name) &#123; this.name = name&#125;Leo.prototype.species = 'animal'‘就长这副熊样!? 这和简单的复制黏贴有什么区别!? 这和咸鱼又有什么区别!？ 说好的逼格呢！？’观察一下 Leo, Leo 构造函数内部逻辑和 Animal 构造函数的内部逻辑如出一辙. 既然都是一样的, 为什么不能借来用用呢? 改造一下,12345678function Animal(name) &#123; this.name = name&#125;Animal.prototype.species = 'animal'function Leo(name) &#123; Animal.call(this, name)&#125;这种在构造函数内部借函数而不借助原型继承的方式被称之为 借用构造函数式继承.把属性和方法放在构造函数内部的定义, 使得每个构造出来的实例都有自己的属性和方法. 而对一些需要实例间共享的属性或方法却是没辙.当然了, 我们本来就没打算止步于此. 构造函数内部可以靠借, 那原型上呢? 如何让 Leo 的原型上能和 Animal 的原型保持一致呢?‘这不是废话么? 我除了会借, 我还会继承啊, 原型继承啊!!!’关于原型链, 我们已经知道是怎么一回事了(不知道的可参考从Function入手原型链).原型继承就是通过原型链实现了对象本身没有的属性访问和方法调用. 利用这个特性, 我们可以在原型上做些手脚.思路一: 可以使得 Leo 的 prototype 直接指向 Animal 的 prototype.123456789function Animal(name) &#123; this.name = name&#125;Animal.prototype.species = 'animal'function Leo(name) &#123; Animal.call(this, name)&#125;Leo.prototype = Animal.prototype这里有一点需要注意的, Leo.prototype = Animal.prototype 这种写法就等于完全覆写了 Leo 的原型, Leo.prototype.constructor 将和 Animal.prototype.constructor 保持一致, 这会使得一些等式显得诡异.不信, 请看:1Leo.prototype.constructor === Animal.prototype.constructor === Animal针对这种情况, 我们往往会做一些修正:123// 接上例代码省略Leo.prototype = Animal.prototypeLeo.prototype.constructor = Leo即使修正好了, 可是还有个大问题.那就是, 如果想给 Leo 原型添加属性或方法, 将会影响到 Animal, 进而会影响到所有 Animal 的实例. 毕竟它们的原型之间已经画了等号.1234567// 接上例代码省略let Dog = new Animal('dog')Dog.sayName // undefinedLeo.prototype.sayName = function() &#123; console.log(this.name)&#125;Dog.sayName() // dog‘我只想偷个懒, 没想过要捣乱啊😲!!!’为了消除这种影响, 我们需要一个中间纽带过渡. 还好我们知道 new 可以用来修改原型链.思路二: Leo 的 prototype 指向 Animal 的实例.12345678910function Animal(name) &#123; this.name = name&#125;Animal.prototype.species = 'animal'function Leo(name) &#123; Animal.call(this, name)&#125;Leo.prototype = new Animal()Leo.prototype.contructor = Leo这种在构造函数内部借函数同时又借助原型继承的方式被称之为 组合继承. Leo 换个角度其实长这样:12345678function Leo(name) &#123; this.name = name&#125;Leo.prototype = &#123; constructor: Leo, name: undefined, __proto__: Animal.prototype&#125;在这种继承模式中, Leo 的实例可以有自己的属性和方法, 实例之间又可以通过 prototype 来共享属性和方法却不会影响 Animal, 还可以通过 _proto_ 追溯到 Animal.prototype.一切都很完美👏. 不过还记得文章开始时所说的么在实现继承的过程中, 一旦同时出现 new 和 apply 或 call, 就会有重复交集的可能, 这时就需要想想是否有可以改进的地方.Animal 被调用了两次, 第一次是 Leo 构造函数内部作为一个普通函数被调用, 第二次是被作为构造函数构造一个实例充当 Leo 的原型.Animal 内部定义的属性和方法同时出现在 Leo 的原型和 Leo 的实例上. 实例上有的东西就不会再到原型上查找. 反之, 实例上没有的东西才会到原型上查找. 显然, 有多余的存在.‘这不是最优解, 我要最好的! 下一个!’思路三: 既然有重复, 那就去其一呗. 既然 new 比 call 和 apply 厉害, 那就留着 new 吧.12345678function Animal(name) &#123; this.name = name&#125;Animal.prototype.species = 'animal'function Leo(name) &#123;&#125;Leo.prototype = new Animal()Leo.prototype.contructor = Leo这种在构造函数内部不借函数只借助原型继承的方式被称之为 原型链继承.经过这么一折腾, 发现不好的地方有增无减. 实例没了自己的属性和方法了, 连 Animal 构造函数内部定义的属性方法都可以在实例间共享了(思路二也存在这个问题), 而且参数也不给传了.‘我要的不多, 能轻点折腾不, 心脏不好’回到 思路二, 那就删了 new 吧.思路四: 接上 思路二, 删了 new, 那只能在原型上做调整了.我们从一开始就只是希望 Leo 的 prototype 指向 Animal 的 prototype, 不多不少且不会出现 思路一 的坏影响.既然不能直接在两者之间画等号, 就造一个过渡纽带呗. 能够关联起原型链的不只有 new, Object.create() 也是可以的.创建一个 _proto_ 指向 Animal.prototype 的对象充当 Leo 的原型不就解决问题了么.12345678910function Animal(name) &#123; this.name = name&#125;Animal.prototype.species = 'animal'function Leo(name) &#123; Animal.call(this, name)&#125;Leo.prototype = Object.create(Animal.prototype)Leo.prototype.contructor = Leo这种在构造函数内部借函数同时又间接借助原型继承的方式被称之为 寄生组合式继承.这种模式完美解决了 思路二 的弊端. 算是较为理想的继承模式吧.‘确认过眼神, 你才我想要的!’以上还是只是构造函数间的继承, 还有基于已存在对象的继承, 譬如, 原型式继承 和 寄生式继承等.讲真, 说了辣么多, 我还真没记住 借用构造函数式继承, 组合继承, 原型链继承, 寄生组合式继承, 原型式继承, 寄生式继承等.‘你没记住这么多模式, 那你都记住什么了’答曰: 要想很好得继承, 一靠朋友, 二靠拼爹.‘这孩子是不是傻? 这都什么年代了? 再说了, 就没人告诉你你家里有矿???’思路五: ES6 引入了 Class（类）这个概念，通过 class 关键字，可以定义类, Class 实质上是 JavaScript 现有的基于原型的继承的语法糖. Class 可以通过extends关键字实现继承. 我们可以对 思路四 来个华丽变身.123456789101112class Animal &#123; constructor(name) &#123; this.name = name &#125;&#125;Animal.prototype.species = 'animal'class Leo extends Animal &#123; constructor(name) &#123; super(name) &#125;&#125;经过这么一处理后行为上和 思路四 基本没什么区别, constructor(){} 充当了之前的构造函数, super() 作为函数调用扮演着 Animal.call(this, name) 的角色(还可以表示父类). 最重要的是 Leo 的 _proto_ 也指向了 Animal.‘矿多基因好, 啧啧啧, 我都快要喜欢上我自己了😏’]]></content>
      <categories>
        <category>很难么</category>
      </categories>
      <tags>
        <tag>JavaScript继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[让Python漫步在浏览器上]]></title>
    <url>%2F%E8%AE%A9Python%E6%BC%AB%E6%AD%A5%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8A%2F</url>
    <content type="text"><![CDATA[随着人工智能技术的普及，越来越多的前端程序员开始关注相关技术。Python 作为人工智能领域最常用的语言，与前端程序员日常使用的语言 JavaScript 同属脚本语言，且在两者发展过程中，社区也多有相互借鉴之处，因此有很多相似。一个熟悉 JavaScript 语言的前端程序员，通过掌握了他们之间的不同之处，可以快速上手 Python.如何快速上手? 对于一个前端程序员来说, 如果能够在熟悉的浏览器环境下学习, 最好不过了. 所以, 那就手撸一个 Pathon 在线编程. 而本文的重点则是本地文件的操作, 以下所有代码可见在线demo.File APIFileReader将 File 和 Blob 类型的文件或数据异步读入内存.InstanceOfFileReader PropertiesinstanceOfFileReader.error(只读) : 在读取时的出现的错误.instanceOfFileReader.readyState(只读) : 提供读取操作时的状态.Value(readyState)State(FileReader)Description0EMPTY未加载任何数据1LOADING加载数据中2DONE已完成数据读取instanceOfFileReader.result(只读) : 读取的结果, 要么是 String, 要么是 ArrayBuffer, 这取决于读取的方法, 且仅在 load 事件触发后可用.InstanceOfFileReader MethodsinstanceOfFileReader.abort() : 终止读取操作.instanceOfFileReader.readAsArrayBuffer() : 以 ArrayBuffer 类型为输出结果进行读取.instanceOfFileReader.readAsDataURL() : 以 Data URLs 类型为输出结果进行读取.instanceOfFileReader.readAsText() : 以 String 类型为输出结果进行读取.InstanceOfFileReader Eventsonloadstart/loadstart : 在读取操作开始时触发.onprogress/progress : 在读取过程中触发以汇报当前读取进度.onload/load : 在读取操作成功完成时触发.onabort/abort : 因调用 abort() 而终止读取时触发.onerror/error : 在读取时遇到错误时触发.onloadend/loadend : 在读取操作完成时触发(无论成功或失败).12&lt;!-- html --&gt;&lt;input type='file' onchange='openFile(event)'&gt;123456789101112131415161718192021222324252627282930313233343536373839404142// jsconst stateNames = &#123; [FileReader.EMPTY] : 'EMPTY', [FileReader.LOADING] : 'LOADING', [FileReader.DONE] : 'DONE'&#125;;let openFile = function(event) &#123; let input = event.target; let reader = new FileReader(); // 打开注解即可查看隐藏属性 // reader.onloadstart = function() &#123; // reader.abort(); // &#125;; reader.onprogress = function(e) &#123; console.log('Event: ', e.type) &#125;; reader.onload = function(e) &#123; console.log('Event: ', e.type) &#125;; reader.onloadend = function(e) &#123; console.log('Event: ', e.type) console.log(reader.error.message); &#125;; reader.onabort = function(e) &#123; console.log('Event: ', e.type) &#125; reader.onerror = function(e) &#123; console.log('Event: ', e.type) console.log(reader.error.message); &#125; reader.onload = function()&#123; let dataURL = reader.result; console.log('ReadyState: ' + stateNames[reader.readyState]); console.log('Result: ', dataURL) &#125;; console.log('ReadyState: ' + stateNames[reader.readyState]); // 打开注解即可查看隐藏属性 // reader.readAsDataURL(input.files[0]); // reader.readAsArrayBuffer(input.files[0]) reader.readAsText(input.files[0]) console.log('ReadyState: ' + stateNames[reader.readyState]);&#125;;Blob原始数据的不可变对象. File 就是衍生于 Blob.当 Blob 作为构造函数时, new Blob(blobParts, blobPropertyBag) 接受两个参数 :=&gt; blobParts : ArrayBuffer, ArrayBufferView, Blob, 或 String 对象类型之一.=&gt; blobPropertyBag({type, endings}) : type=&gt; MIME类型. endings(transparent|native) =&gt; 用于指定包含行结束符 \n 的字符串如何被写入.InstanceOfBlob PropertiesinstanceOfBlob.size(只读) : 所包含数据的大小(以字节为单位).instanceOfBlob.type(只读) : 所包含数据的MIME类型, 如果类型未知，则该值为空字符串.InstanceOfBlob MethodsinstanceOfBlob.slice([start, [end, [contentType]]]) : 创建基于原 Blob 对象指定字节范围内的数据的新 Blob 对象, 并赋予新 Blob 对象指定类型. 异于 Array.slice() 和 String.slice()12345678// jslet blob = new Blob( new String('hello world'), &#123;type: 'plain/text',endings: 'native'&#125;);let reader_1 = new FileReader();reader_1.onload = function() &#123; let result = reader_1.result; console.log('result: ', result, 'type: ', blob.type, 'size: ', blob.size)&#125;reader_1.readAsText(blob);FileFile 是 Blob 的一种特殊类型, 所以适用 Blob 的场景也同样适用于 File.File 对象可以是来自用户在一个 &lt;input&gt; 元素上选择文件后返回的 FileList 对象, 也可以来自拖放操作生成的 DataTransfer 对象, 还可以是来自在一个 HTMLCanvasElement 上执行 mozGetAsFile() 方法后返回结果.当 File 作为构造函数时, 较类似于 Blob.new File(fileParts[, name[, filePropertyBag]]) 接受两个参数 :=&gt; fileParts : ArrayBuffer, ArrayBufferView, Blob, 或 String 对象类型之一.=&gt; name : 文件名称或文件路径.=&gt; blobPropertyBag({type, endings}) : type=&gt; MIME类型. endings(transparent|native) =&gt; 用于指定包含行结束符 \n 的字符串如何被写入.InstanceOfFile PropertiesinstanceOfFile.lastModified(只读) : 当前文件最后修改时间, 自 1970年1月1日0:00 以来的毫秒数.instanceOfFile.lastModifiedDate(只读) : 当前文件最后修改时间.instanceOfFile.name(只读) : 当前文件的名称.instanceOfFile.webkitRelativePath(只读) : 当前文件的路径.instanceOfFile.size(只读) : 当前文件的大小(以字节为单位).instanceOfFile.type(只读) : 当前文件的MIME类型.InstanceOfFile Methods继承使用 Blob 的方法.FileReaderSync以同步的方式读取 File 或 Blob 对象中的内容, 仅在 workers 里可用, 因为在主线程里进行同步 I/O 操作可能会阻塞用户界面. 有着和 FileReader 相同的读取方法.URL提供了将 Blob 生成 url 的方法, 可使本地内容生成 url 传给接受 url 的 API.URL MethodsURL.createObjectURL() : 为指定的 File 或 Blob 或 MediaSource 对象创建一个新的 url.Lifetime of blob URLsURL.revokeObjectURL() : 释放之前生成的 url.123&lt;!-- html --&gt;&lt;input type='file' accept='image/*' onchange='uploadPicture(event)'&gt;&lt;div id='picture'&gt;&lt;/div&gt;12345678910111213141516171819202122232425262728293031323334// jslet picture = document.getElementById('picture');let uploadPicture = function(event) &#123;let target = event.target;let file = target.files[0];// URLlet img = document.createElement('img');let url = URL.createObjectURL(file);img.width = 300;img.src = url;img.onload = function() &#123; URL.revokeObjectURL(url);&#125;;picture.appendChild(img);// Auto downloadlet downLink = document.createElement('a');let downUrl = URL.createObjectURL(file, &#123; type: 'image/*' &#125;);downLink.download = `picture.png`;downLink.href = downUrl;downLink.click();URL.revokeObjectURL(downUrl);// FileReaderlet reader_3 = new FileReader();reader_3.onload = function() &#123; let result = reader_3.result; let img = document.createElement('img'); img.width = 300; img.src = result; picture.appendChild(img);&#125;reader_3.readAsDataURL(file);&#125;]]></content>
      <categories>
        <category>API总结</category>
      </categories>
      <tags>
        <tag>File API</tag>
        <tag>FileReader</tag>
        <tag>Blob</tag>
        <tag>URL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Function原型方法]]></title>
    <url>%2FFunction%E5%8E%9F%E5%9E%8B%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[FunctionFunction 作为构造函数用来创建一个新的 Function 对象.概述详见从Function入手原型链. Function 用来创建函数对象, 而 Function 本身也是函数, 所以有一个让很多人困扰的地方.1Object.getPrototypeOf(Function) === Function.prototype // true原型方法Function.prototype.toString()描述 :返回一个表示当前函数源代码的字符串.语法 :function.toString()在内置函数或由 Function.prototype.bind 返回的函数上调用该方法, 则有:1234567891011String.toString()// "function String() &#123; [native code] &#125;"Number.toString()// "function Number() &#123; [native code] &#125;"String.bind(null).toString()// "function () &#123; [native code] &#125;"Number.bind(null).toString()// "function () &#123; [native code] &#125;"普通函数调用该方法, 则有:123456(function() &#123;&#125;).toString()// "function() &#123;&#125;"function man(params) &#123;console.log(params)&#125;man.toString()// "function man(params) &#123;console.log(params)&#125;"非 Function 对象调用该方法, 会抛出 TypeError.12Function.prototype.toString.call(&#123;&#125;)// TypeError: Function.prototype.toString requires that 'this' be a FunctionFunction.prototype.apply()描述 :为调用的函数指定 this 值, 即 this 的执行上下文, 并以数组的形式传入参数.语法 :function.apply(thisArg, argArray)thisArg : 用于改变函数体内部 this 指向的 context. 当 argArray 为 undefined 或 null 时, thisArg 将替换成全局对象. 为基本类型值时, 将会被包装成相应的对象. 否则将不会做任何改变.argArray : 数组或类数组对象. argArray 里的元素将逐个放入参数列表中. 若检测 argArray 不是对象, 将会抛出 TypeError 错误.123456789101112131415161718192021222324252627282930313233343536373839const man = &#123; age: 18, sex: 'man', saySex() &#123; console.log(`I am a $&#123;this.sex&#125;`) &#125;&#125;const women = &#123; age: 16, sex: 'women'&#125;man.saySex.apply(women)// I am a women------------------------------function log_1(arg) &#123; console.log(arg)&#125;log_1(1);log_1(1,2,3);// 1// 1function log_2() &#123; const log = console.log; log.apply(null, arguments)&#125;log_2(1);log_2(1, 2, 3)// 1// 1 2 3------------------------------let a = ['h','e','l','l','o'];let b = ['w','o','r','l','d'];let push = Array.prototype.push;push.apply(a, b);console.log(a);// [ 'h', 'e', 'l', 'l', 'o', 'w', 'o', 'r', 'l', 'd' ]Function.prototype.call()描述 :为调用的函数指定 this 值, 即 this 的执行上下文, 并以列表的形式传入参数.语法 :function.call(thisArg[ , arg1 [ , arg2, …, argN]])thisArg : 用于改变函数体内部 this 指向的 context. 当 argArray 为 undefined 或 null 时, thisArg 将替换成全局对象. 为基本类型值时, 将会被包装成相应的对象. 否则将不会做任何改变.argN : 入参将从左到右的顺序加入到参数列表中.123456789101112131415161718function Person(name, age) &#123; this.name = name; this.age = age;&#125;function Man(name, age) &#123; Person.call(this, name, age); this.sex = 'man';&#125;const Adam = new Man('Adam', 18);console.log(Adam)// Man &#123; name: 'Adam', age: 18, sex: 'man' &#125;------------------------------let a = ['h','e','l','l','o'];let push = Array.prototype.push;push.call(a, 'w','o','r','l','d');console.log(a);// [ 'h', 'e', 'l', 'l', 'o', 'w', 'o', 'r', 'l', 'd' ]Function.prototype.bind()描述 :创建一个新的绑定函数, 为函数指定 this 值, 即 this 的执行上下文, 并以列表的形式传入参数.语法 :function.bind(thisArg[ , arg1 [ , arg2, …, argN]])thisArg : 调用绑定函数时作为this参数传递给目标函数的值.argN : 当目标函数被调用时，预先添加到绑定函数的参数列表中的参数.1234567891011121314151617for(var i = 0; i &lt;= 3; i++) &#123; setTimeout((function(i) &#123; console.log('i', i) &#125;).bind(null, i), 1000)&#125;// 0// 1// 2// 3------------------------------// 类数组转数组let argArray = Array.prototype.slice.call(arguments);// 或let slice = Array.prototype.slice;let boundSlice = Function.prototype.call.bind(slice);boundSlice(arguments);]]></content>
      <categories>
        <category>API总结</category>
      </categories>
      <tags>
        <tag>Function</tag>
        <tag>Function原型</tag>
        <tag>apply</tag>
        <tag>call</tag>
        <tag>bind</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从Function入手原型链]]></title>
    <url>%2F%E4%BB%8EFunction%E5%85%A5%E6%89%8B%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[FunctionFunction 是函数? 是构造函数? 还是函数对象? 在翻阅 ECMA 规范时, 这几个名词也是无缝切换中, 稍不留神就可能跑偏了.都应该知道, 构造函数是用来打造具有相同属性和行为事物的模具.在作为构造函数之前, 它首先是个函数, 函数是可以被调用的(这也是区别于其它对象的因素). 它是由一系列语句组成, 并最终返回一个值. 每一个函数被创建的时候, 都有一个 prototype 属性.普通函数能够变成构造函数, 那都是 new 将函数的 prototype 和生成的实例关联起来了. 换句话说, 每个普通函数都有称为构建函数的潜质.12345678910111213141516// 常见的构造函数模式function Man(name) &#123; this.name = name; this.sex = 'man';&#125;Man.prototype.sayHi = function() &#123; console.log('hello', this.name)&#125;let man_1 = new Man('夜曉宸');// 我是普通函数function man(name) &#123; console.log('hello', name)&#125;// 只要经过 new 调教后, 我也可以被称为构造函数了let man_2 = new man('夜曉宸');Function和内置函数都说函数是 JavaScript 里的头等对象, 这话一点不假. 在 为强制类型转换正名 里已经提到过, JavaScript 里的数据类型除了基本数据类型, 就是复杂数据类型. 而这些复杂数据类型都和 Function 有着密切关系.Function构造函数函数的身影在 JavaScript 中随处可见, 有造字符串类型的 String 函数, 有造数值类型的 Number 函数, 除了这些内置函数, 还有上面我自己写的 Man 和 man 函数. JavaScript 的作者在写 JavaScript 语言的时候, 可能知道有且需要 String, Number 这样的函数处理写数据, 于是有了内置函数这么一说. 那么内置函数满足不了我们的需求呢, 如何去创建一个函数呢? 其实, 在没有这些内置函数之前, 就有了这么一个东西. 那就是为创建函数而生的函数 —— Function. 等会儿, 有点绕😵, 创建函数的函数? 那岂不是把自己也给创建了🤔? 是的, 没错, 就是这么一个奇葩的存在.The Function constructor is the %Function% intrinsic object and the initial value of the Functionproperty of the global object. When Functionis called as a function rather than as a constructor, it creates and initializes a new Function object. Thus the function call Function(…)is equivalent to the object creation expression new Function(…)with the same arguments.所以说, 包括这些内置函数, 它们都是由 Function 构建函数造出来的. 如何去验证函数是不是函数造出来的呢?new操作符All ordinary objects have an internal slot called [[Prototype]]. The value of this internal slot is either null or an object and is used for implementing inheritance.每个普通对象都有一个 [[Prototype]], 这个属性就是用来实现原型继承用的.上面👆也提到了, 在用构造函数造 new 出实例对象时, 实例对象内部的 [[Prototype]] 会关联到构造函数的 prototype 所指向的对象. new 主要做以下两件事:将实例对象的 [[Prototype]] 关联到构造函数的 prototype 上.将 this 绑定到新创建的实例对象上, 并调用构造函数(就是将函数体里的语句执行一遍).类似于:1234567function New(func) &#123; const obj = &#123;&#125;; // _proto_ 和 [[Prototype]] 不是同一个东西, 后者是内部使用的. ojb._proto_ = func.prototype; func.call(obj); return obj;&#125;Object.getPrototypeOf() 是用来检测指定对象内部 [[Prototype]] 属性的值.对于上面👆的 Man 和 man_1 关系, 试一波.1Object.getPrototypeOf(man_1) === Man.prototype // true;Function和函数回头再看看 String, Number, Boolean, Array, Object, Function, RegExp, Date, Error, Symbol 这些内置函数和 Function 构造函数的关系(注意包含了 Function 自身). 这里是把这些内置函数作为由 Function 构造出来的实例对象对待的. (函数也是对象的一子类型)1234567891011121314151617181920212223Object.getPrototypeOf(String) === Function.prototype // trueObject.getPrototypeOf(Number) === Function.prototype // trueObject.getPrototypeOf(Boolean) === Function.prototype // trueObject.getPrototypeOf(Array) === Function.prototype // trueObject.getPrototypeOf(Object) === Function.prototype // trueObject.getPrototypeOf(Function) === Function.prototype // trueObject.getPrototypeOf(RegExp) === Function.prototype // trueObject.getPrototypeOf(Date) === Function.prototype // trueObject.getPrototypeOf(Error) === Function.prototype // trueObject.getPrototypeOf(Symbol) === Function.prototype // trueObject.getPrototypeOf(Man) === Function.prototype // true 👀👆🌰Object.getPrototypeOf(man_1) === Function.prototype // false 👀👆🌰在之前的 为强制类型转换正名 已经知道了, JavaScript 里的对象类型基本上也就是那么多. 以上函数的原型链, 最终会指向 Function.prototype (仅为目前, 后面还有 Object.prototype 和 null ). 这也是解释了为什么任何一个普通函数都可以调用 call , apply 等 Functon.prototype 上的方法.Function和原型所有的函数的原型链里都将会出现 Functon.prototype, 由构造函数 new 出来的实例对象的 [[Prototype]] 会关联到构造函数 prototype 上.1234let num = new Number(0);Object.getPrototypeOf(num) === Number.prototype // trueObject.getPrototypeOf(Man) === Function.prototype // true 👀👆🌰到目前为止, 任何函数或对象都可以追溯到 Functon.prototype 和 构造函数的 prototype 上. 那么接下来, 又如何沿着原型链再往后找呢?The Function prototype object is the intrinsic object %FunctionPrototype%. The Function prototype object is itself a built-in function object.这句话告诉我们, Function 的原型是一个函数对象. 可我们也知道, 所有的函数都应该来自于 Function. 由此可推导, Function.prototype 内部属性 [[Prototype]] 应指向 Function.prototype. 实际上并不是这样. 同样情况的还有 Array.1Object.getPrototypeOf(Function.prototype) === Function.prototype // falseECMA 规范也给出了解释, 不知是不是解释这个的.It does not have a [[Construct]] internal method so it is not a constructor.NOTE The Function prototype object is specified to be a function object to ensure compatibility with ECMAScript code that was created prior to the ECMAScript 2015 specification.以上推导可忽略. 所以呢,The value of the [[Prototype]] internal slot of the Function prototype object is the intrinsic object %ObjectPrototype%.1Object.getPrototypeOf(Function.prototype) === Object.prototype // true其它的构造函数也是一样.1234567891011121314151617181920212223242526// true String.prototype is an ordinary object.Object.getPrototypeOf(String.prototype) === Object.prototype// true String.prototype is an ordinary object.Object.getPrototypeOf(Number.prototype) === Object.prototype// true String.prototype is an ordinary object.Object.getPrototypeOf(Boolean.prototype) === Object.prototype// true String.prototype is an Array exotic objects.Object.getPrototypeOf(Array.prototype) === Object.prototype// true String.prototype is an ordinary object.Object.getPrototypeOf(Function.prototype) === Object.prototype// true String.prototype is a built-in function object.Object.getPrototypeOf(RegExp.prototype) === Object.prototype// true String.prototype is an ordinary object.Object.getPrototypeOf(Date.prototype) === Object.prototype// true String.prototype is an ordinary object.Object.getPrototypeOf(Error.prototype) === Object.prototype// true String.prototype is an ordinary object.Object.getPrototypeOf(Symbol.prototype) === Object.prototype所有的函数或对象的原型链都会追溯到 Object.prototype 上, 难道这里就是终点么? 不是的, 还有个 null . 所以, 最终,1Object.getPrototypeOf(Object.prototype) === null // true总结一波:Function 是构造函数的地方, 构造函数是函数, 内建函数也是函数.被构造出来的实例对象内部属性 [[Prototype]] 会关联到构造函数的 prototype 所指向的对象.prototype chain 的走向为:instance =&gt; constructor.prototype =&gt; Object.prototype =&gt; null. (构造函数造出的实例对象走向)function =&gt; Function.prototype =&gt; Object.prototype =&gt; null.(函数走向)…上图说明一切.]]></content>
      <categories>
        <category>很难么</category>
      </categories>
      <tags>
        <tag>构造函数</tag>
        <tag>Function</tag>
        <tag>函数</tag>
        <tag>new操作符</tag>
        <tag>原型链</tag>
        <tag>prototype</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为强制类型转换正名]]></title>
    <url>%2F%E4%B8%BA%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%AD%A3%E5%90%8D%2F</url>
    <content type="text"><![CDATA[强制类型转换引子强制类型转换是JavaScript开发人员最头疼的问题之一, 它常被诟病为语言设计上的一个缺陷, 太危险, 应该束之高阁.作为开发人员, 往往会遇到或写过涉及到类型转换的代码, 只是我们从来没有意识到. 因为我们基本碰运气.猜猜看😏:作为基本类型值, 为什么我们可以使用相关的属性或方法? eg: &#39;hello&#39;.charAt(0) (内置类型和内建函数的关系)a &amp;&amp; (b || c) 这波操作我们知道, 那么 if (a &amp;&amp; (b || c)), 这里又做了哪些操作? (||和&amp;&amp;)if (a == 1 &amp;&amp; a== 2) { dosomething }, dosomething竟然执行了, 什么鬼? (ToPrimitive)[] == ![] =&gt; true ?; false == [] =&gt; true ?; &quot;0&quot; == false =&gt; true ?(抽象相等)if (~indexOf(&#39;a&#39;)), 这波操作熟悉不? (+/-/!/~)在String, Number, Boolean类型之间比较时, 进行的强制类型转换又遵循了哪些规则? (抽象操作)下面就要学会用实力碰运气.类型内置类型JavaScript 有七种内置类型. 空值: null, 未定义: undefined, 布尔值: boolean, 数字: number, 字符串: string, 对象: object, 符号: symbol. 除 对象:object, 为复杂数据类型, 其它均为基本数据类型.内建函数常用的内建函数: String(), Number(), Boolean(), Array(), Object(), Function(), RegExp(), Date(), Error(), Symbol().内置类型和内建函数的关系为了便于操作基本类型值, JavaScript提供了封装对象(内建函数), 它们具有各自的基本类型相应的特殊行为. 当读取一个基本类型值的时候, JavaScript引擎会自动对该值进行封装(创建一个相应类型的对象包装它)从而能够调用一些方法和属性操作数据. 这就解释了问题 1.类型检测typeof =&gt; 基本类型的检测均有同名的与之对应. null 除外(不同的对象在底层都表示为二进制, 在JavaScript中二进制前三位都为 0 会被判断为 Object 类型, null 的二进制表示为0, 前三位自然为0, 所以执行 typeof 时会返回 &#39;object&#39;.), null是假值, 也是唯一一个typeof检测会返回 &#39;object&#39; 的基本数据类型值.1234typeof null // "object"let a = null;(!a &amp;&amp; typeof a === 'object') // true复杂数据类型typeof检测返回 &#39;object&#39;, function(函数)除外. 函数因内部属性 [[Call]] 使其可被调用, 其实属于可调用对象.1typeof function()&#123;&#125; // "function"Object.prototype.toString =&gt; 通过typeof检测返回&#39;object&#39;的对象中还可以细分为好多种, 从内建函数就可以知道.它们都包含一个内部属性[[Class]], 一般通过Object.prototype.toString(…)来查看.1234567891011const str = new String('hello');const num = new Number(123);const arr = new Array(1, 2, 3);console.log(Object.prototype.toString.call(str))console.log(Object.prototype.toString.call(num))console.log(Object.prototype.toString.call(arr))// [object String]// [object Number]// [object Array]抽象操作在数据类型转换时, 处理不同的数据转换都有对应的抽象操作(仅供内部使用的操作), 在这里用到的包括 ToPrimitive, ToString, ToNumber, ToBoolean. 这些抽象操作定义了一些转换规则, 不论是显式强制类型转换, 还是隐式强制类型转换, 无一例外都遵循了这些规则(显式和隐式的命名叫法来自《你不知道的JavaScript》). 这里就解释了问题 5和问题 6.ToPrimitive该抽象操作是将传入的参数转换为非对象的数据. 当传入的参数为 Object 时, 它会调用内部方法[[DefaultValue]] 遵循一定规则返回非复杂数据类型, 规则详见DefaultValue. 故 ToString, ToNumber, ToBoolean在处理Object时, 会先经过ToPrimitive处理返回基本类型值.[[DefaultValue]](hint)语法:[[DefaultValue]]的规则会依赖于传入的参数hint, ToString传入的 hint 值为 String, ToNumber传入的 hint 值为 Number.[[DefaultValue]](String) =&gt; 若 toString 可调用, 且 toString(Obj) 为基本类型值, 则返回该基本类型值. 否则, 若 valueOf 可调用, 且 valueOf(Obj) 为基本类型值, 则返回该基本类型值. 若以上处理还未得到基本类型值, 则抛出 TypeError.[[DefaultValue]](Number) =&gt; 该规则正好和上规则调用 toString, valueOf 的顺序相反. 若 valueOf 可调用, 且 valueOf(Obj) 为基本类型值, 则返回该基本类型值. 否则, 若 toString 可调用, 且 toString(Obj) 为基本类型值, 则返回该基本类型值. 若以上处理还未得到基本类型值, 则抛出 TypeError.[[DefaultValue]]() =&gt; 未传参时, 按照 hint值为 Number 处理. Date 对象除外, 按照hint值为 String 处理.现在我们就用以上的知识点来解释问题 3是什么鬼.12345678910let i = 1;Number.prototype.valueOf = () =&gt; &#123; return i++&#125;;let a = new Number("0"); // 字符串强制转换为数字类型是不执行Toprimitive抽象操作的.console.log('a_1:', a);if(a == 1 &amp;&amp; a == 2) &#123; console.log('a==1 &amp; a==2', 'i:', i);&#125;// a==1 &amp; a==2 i: 3我们改写了内建函数 Number 原型上的 valueOf 方法, 并使得一个字符串转换成 Number 对象, 第一次 Object 类型和 Number 类型做比较时, Object 类型将进行 ToPrimitive 处理(抽象相等), 内部调用了 valueOf, 返回 2. 第二次同样的处理方式, 返回 3.ToString该抽象操作负责处理非字符串到字符串的转换.typeresultnull“null”undefined“undefined”booleantrue =&gt; “true”; false =&gt; “false”string不转换numberToString Applied to the Number TypeObject先经ToPrimitive返回基本类型值, 再遵循上述规则ToNumber该抽象操作负责处理非数字到数字的转换.typeresultnull+0undefinedNaNbooleantrue =&gt; 1; false =&gt; 0stringToNumber Applied to the String Typenumber不转换Object先经ToPrimitive返回基本类型值, 再遵循上述规则常见的字符串转换数字:字符串是空的 =&gt; 转换为0.字符串只包含数字 =&gt; 转换为十进制数值.字符串包含有效的浮点格式 =&gt; 转换为对应的浮点数值.字符串中包含有效的十六进制格式 =&gt; 转换为相同大小的十进制整数值.字符串中包含除以上格式之外的符号 =&gt; 转换为 NaN.ToBoolean该抽象操作负责处理非布尔值到布尔值转换.typeresultnullfalseundefinedfalseboolean不转换string“” =&gt; false; 其它 =&gt; truenumber+0, −0, NaN =&gt; false; 其它 =&gt; trueObjecttrue真值 &amp; 假值假值(强制类型转换false的值) =&gt; undefined, null, false, +0, -0, NaN, &quot;&quot;.真值(强制类型转换true的值) =&gt; 除了假值, 都是真值.特殊的存在假值对象 =&gt; documen.all 等. eg: Boolean(window.all) // false隐式强制类型转换+/-/!/~+/- 一元运算符 =&gt; 运算符会将操作数进行ToNumber处理.! =&gt; 会将操作数进行ToBoolean处理.~ =&gt; (~x)相当于 -(x + 1) eg: ~(-1) ==&gt; 0; ~(0) ==&gt; 1; 在if (…)中作类型转换时, 只有-1时, 才为假值.+加号运算符 =&gt; 若操作数有String类型, 则都进行ToString处理, 字符串拼接. 否则进行ToNumber处理, 数字加法.条件判断if (...), for(;;;), while(...), do...while(...)中的条件判断表达式.? : 中的条件判断表达式.|| 和 &amp;&amp; 中的中的条件判断表达式.以上遵循ToBoolean规则.||和&amp;&amp;返回值是两个操作数的中的一个(且仅一个). 首先对第一个操作数条件判断, 若为非布尔值则进行ToBoolean强制类型转换.再条件判断.|| =&gt; 条件判断为true, 则返回第一个操作数; 否则, 返回第二个操作数. 相当于 a ? a : b;&amp;&amp; =&gt; 条件判断为true, 则返回第二个操作数; 否则, 返回第一个操作数, 相当于 a ? b : a;结合条件判断, 解释下问题 21234567let a = true;let b = undefined;let c = 'hello';if (a &amp;&amp; (b || c)) &#123; dosomething()&#125;a &amp;&amp; (b || c) 返回 'hello', if语句中经Toboolean处理强制类型转换为true.抽象相等这里的知识点是用来解释 问题 4 的, 也是考验人品的地方. 这下我们要靠实力拼运气.同类型的比较.1234+ 0 == -0 // truenull == null // trueundefined == undefined // trueNaN == NaN // false, 唯一一个非自反的值null 和 undefined 的比较.12null == undefined // trueundefined == null // trueNumber 类型和 String 类型的比较. =&gt; String 类型要强制类型转换为 Number 类型, 即 ToNumber(String).(参见ToNumber)Boolean 类型和其它类型的比较. =&gt; Boolean 类型要强制类型转换为 Number 类型, 即 ToNumber(Boolean).(参见ToNumber)Object 类型和 String 类型或 Number 类型. =&gt; Object 类型要强制转换为基本类型值, 即 ToPrimitive(Object).(参见ToPrimitive)其它情况, false.回头看看问题 4中的等式. [] == ![], false == [], &quot;0&quot; == false.[] == ![] =&gt; ! 操作符会对操作数进行ToBoolean处理, [] 是真值, !true 则为 false. 再遵循第 4 点, Boolean 类型经过 ToNumber 转换为 Number类型, 则为数值 0. 再遵循第 5 点, 对 [] 进行 ToPrimitive 操作, 先后调用 valueOf(), toString()直到返回基本类型, 直到返回 &quot;&quot;. (先[].valueOf() =&gt; [], 非基本类型值; 再[].toString() =&gt; “”, 基本类型值, 返回该基本类型值.). 再遵循第 3 点, 对 &quot;&quot; 进行 ToNumber处理, 则为数值 0. 到此, 0 == 0, 再遵循第 1 点(其实没写全😌, 详见The Abstract Equality Comparison Algorithm), return true, 完美!😏.false == [] =&gt; 同理 [] == ![].&quot;0&quot; == false =&gt; 同理 [] == ![].123[] == ![] // truefalse == [] // true"0" == false // true运气是留给有准备的人, 所以呢, 我要准备买彩票了.😏]]></content>
      <categories>
        <category>很难么</category>
      </categories>
      <tags>
        <tag>强制类型转换</tag>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String原型方法]]></title>
    <url>%2FString%E5%8E%9F%E5%9E%8B%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[StringString全局对象是一个用于字符串或一个字符序列的构造函数.概述除 Object 以外的所有类型都是不可变的(值本身无法被改变). JavaScript 中字符串是不可变的「JavaScript 中对字符串的操作一定返回了一个新字符串, 原始字符串并没有被改变」.字符串字面量(通过单引号或双引号定义)和直接调用 String 方法(没有通过 new 生成字符串对象实例)的字符串都是基本字符串. JavaScript 会自动将基本字符串转换为字符串对象, 只有将基本字符串转化为字符串对象之后才可以使用字符串对象的方法.123456789101112131415let a = 'Hello, World';let b = String('Hello, World');let c = new String('Hello, World');console.log('a', a);console.log('b', b);console.log('c', c);// a Hello, World// b Hello, World/* c String =&#123; 0: "H", 1: "e",2: "l", 3: "l", 4: "o", 5: ",", 6: " ", 7: "W", 8: "o", 9: r", 10: "l", 11: "d", length: 12 &#125; */// 可以看到String构造出来的是一个类数组, 这样就可以通过.或[]来取值.当基本字符串需要调用一个字符串对象才有的方法或者查询值的时候(基本字符串是没有这些方法的「原始值」)，JavaScript 会自动将基本字符串转化为字符串对象并且调用相应的方法或者执行查询「JavaScript会自动将字符串字面值转换为一个临时字符串对象，调用该方法，然后废弃掉那个临时的字符串对象」.原型方法(部分)String.prototype.charAt()描述 :从一个字符串中返回指定索引位置的字符.语法 :str.charAt(index)index(可选) : 介于 0 ~ (str.length - 1) 的整数. 若无, 默认值为 0. 超过指定范围数值, 则返回空字符串.12345678910var anyString = "Hello World";console.log("The character at index 0 is '" + anyString.charAt() + "'");console.log("The character at index 1 is '" + anyString.charAt(1) + "'");console.log("The character at index 2 is '" + anyString.charAt(2) + "'");console.log("The character at index 11 is '" + anyString.charAt(11) + "'");// The character at index 0 is 'H'// The character at index 1 is 'e'// The character at index 2 is 'l'// The character at index 11 is ''String.prototype.concat()描述 :将原字符串与多个字符串拼接成新的字符串.语法 :str.concat(string[, string1, ..., stringN])stringN : 要拼接的字符串.1234let 你好世界 = 'Hello'.concat(' World');console.log('你好世界 = ', 你好世界);// 你好世界 = Hello WorldString.prototype.trim()描述 :将字符串的两端空白字符删除.语法 :str.trim()123456let str_1_length = ' Hello World ! '.length;let str_1 = ' Hello World ! '.trim();console.log('str_1_length', str_1_length, 'str_1', str_1, str_1.length);// str_1_length 24 str_1 Hello World ! 13String.prototype.replace()描述 :在字符串中匹配并替换指定字符串.语法 :str.replace(regexp|string, newString|function)regexp : 一个 RegExp 对象或者其字面量.string : 待匹配的字符串, 仅仅是第一个匹配会被替换.newString : 用于取代的字符串.function : 每次匹配都要调用的函数.12345678910111213141516171819let str_1 = '521521521521'.replace('521', '我爱你');let str_2 = '521521521521'.replace(/521/g, '我爱你');let str_3 = '521521521521'.replace(/(521)/g, function(a, b, c, d)&#123; console.log('arguments', arguments); if (c === 0) return a; return '我爱你';&#125;);console.log('str_1', str_1);console.log('str_2', str_2);console.log('str_3', str_3);// arguments &#123; '0': '521', '1': '521', '2': 0, '3': '521521521521' &#125;// arguments &#123; '0': '521', '1': '521', '2': 3, '3': '521521521521' &#125;// arguments &#123; '0': '521', '1': '521', '2': 6, '3': '521521521521' &#125;// arguments &#123; '0': '521', '1': '521', '2': 9, '3': '521521521521' &#125;// str_1 我爱你521521521// str_2 我爱你我爱你我爱你我爱你// str_3 521我爱你我爱你我爱你String.prototype.split()描述 :在字符串中指定分隔符, 并在分隔符处分割字符串.语法 :str.split([separator[, limit]])separator : 字符串或正则表达式. 若省略, 则返回的数组包含一个由整个字符串组成的元素.limit : 限定返回的分割片段数量.123456789101112131415161718192021let str_1 = 'Hello World'.split();let str_2 = 'Hello World'.split('');let str_3 = 'Hello World'.split(' ');let str_4 = 'Hello World, Hello World, Hello World'.split(',', 2);let str_5 = 'He5llo 2Worl1d'.split(/\d/);let str_6 = 'He5llo 2Worl2d'.split(/(\d)/);console.log('str_1',str_1);console.log('str_2',str_2);console.log('str_3',str_3);console.log('str_4',str_4);console.log('str_5',str_5);console.log('str_5',str_6);// str_1 [ 'Hello World' ]// str_2 [ 'H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd' ]// str_3 [ 'Hello', 'World' ]// str_4 [ 'Hello World', ' Hello World' ]// str_5 [ 'He', 'llo ', 'Worl', 'd' ]// str_5 [ 'He', '5', 'llo ', '2', 'Worl', '2', 'd' ]String.prototype.slice()描述 :提取字符串的一部分.语法 :str.slice(begin[, end])begin(可选) : 起始索引, 默认值为0. 如果是负数, 则开始索引会被自动计算成为 str.length + start.end : 终止索引, 默认值 str.length. 不包括end位置. 如果是负数时, 规则如上.1234567891011let str_1 = '0123456789'.slice();let str_2 = '0123456789'.slice(-1);let str_3 = '0123456789'.slice(1, -1);console.log('str_1', str_1);console.log('str_2', str_2);console.log('str_3', str_3);// str_1 0123456789// str_2 9// str_3 12345678String.prototype.substring()描述 :提取字符串的一部分.语法 :str.substring(begin[, end])begin : 起始索引.end : 终止索引.1234567891011let str_1 = '0123456789'.substring();let str_2 = '0123456789'.substring(0, 7);let str_3 = '0123456789'.substring(7, 0);console.log('str_1', str_1);console.log('str_2', str_2);console.log('str_3', str_3);// str_1 0123456789// str_2 0123456// str_3 0123456String.prototype.substr()描述 :提取字符串的一部分.语法 :str.substr(start[, length])start(可选) : 起始索引, 默认值为0. 如果是负数, 则开始索引会被自动计算成为 str.length + start.length : 提取的字符数.1234567891011let str_1 = '0123456789'.substr();let str_2 = '0123456789'.substr(-3);let str_3 = '0123456789'.substr(0, 6);console.log('str_1', str_1);console.log('str_2', str_2);console.log('str_3', str_3);// str_1 0123456789// str_2 789// str_3 012345String.prototype.includes()描述 :判断字符串中是否有指定字符串. 依条件返回 true 或 false.语法 :str.includes(string[, position])string : 需要查询的字符串.position : 指定查询起始位置, 默认为 0.1234567let boolean_1 = 'Hello World'.includes('World');let boolean_2 = 'Hello World'.includes('你好世界');console.log('boolean_1 = ', boolean_1);console.log('boolean_2 = ', boolean_2);// boolean_1 = true// boolean_2 = falseString.prototype.startsWith()描述 :判断字符串是否以指定字符串开头. 依条件返回 true 或 false.语法 :str.startsWith(string[, position])string : 需要查询的字符串.position : 指定字符串开头的位置, 默认值为 0.1234567891011let boolean_1 = '123456789'.startsWith(1);let boolean_2 = '123456789'.startsWith(3, 4);let boolean_3 = '123456789'.startsWith(7, 6);console.log('boolean_1', boolean_1);console.log('boolean_2', boolean_2);console.log('boolean_3', boolean_3);// boolean_1 true// boolean_2 false// boolean_3 trueString.prototype.endsWith()描述 :判断字符串是否以指定字符串结尾. 依条件返回 true 或 false.语法 :str.endsWith(string[, position])string : 需要查询的字符串.position : 指定字符串结尾的位置(字符串的长度), 默认值为 str.length.1234567891011let boolean_1 = '123456789'.endsWith(9);let boolean_2 = '123456789'.endsWith(9, 8);let boolean_3 = '123456789'.endsWith(7, 7);console.log('boolean_1', boolean_1);console.log('boolean_2', boolean_2);console.log('boolean_3', boolean_3);// boolean_1 true// boolean_2 false// boolean_3 trueString.prototype.indexOf()描述 :查询指定字符串在字符串中首次出现的索引位置. 若未查询到, 则返回 -1.语法 :str.indexOf(string[, position])string : 需要查询的字符串.position : 首次被找到的元素在数组中的索引位置, 默认值为 0.1234567891011let pos_1 = '0123456789'.indexOf(8);let pos_2 = '0123456789'.indexOf(8, 9);let pos_3 = '0123456789'.indexOf(8, 8);console.log('pos_1', pos_1);console.log('pos_2', pos_2);console.log('pos_3', pos_3);// pos_1 8// pos_2 -1// pos_3 8String.prototype.lastIndexOf()描述 :从字符串的后面向前查找, 查询指定字符串在字符串中首次出现的索引位置. 若未查询到, 则返回 -1.语法 :str.lastIndexOf(string[, position])string : 需要查询的字符串.position : 逆向查找起始索引, 默认值 str.length - 1.1234567891011let pos_1 = '0123456789'.lastIndexOf(9);let pos_2 = '0123456789'.lastIndexOf(9, 9);let pos_3 = '0123456789'.lastIndexOf(9, 8);console.log('pos_1', pos_1);console.log('pos_2', pos_2);console.log('pos_3', pos_3);// pos_1 9// pos_2 9// pos_3 -1String.prototype.match()描述 :字符串检索匹配正则表达式.语法 :str.match(regexp)regexp : 正则表达式对象, 如果传入一个非正则表达式对象, 则会隐式地使用 new RegExp(obj) 将其转换为一个 RegExp. 如果你未提供任何参数, 直接使用 match(), 那么你会得到一个包含空字符串的 Array : [&quot;&quot;].返回值 : 如果字符串匹配到了表达式, 会返回一个数组, 数组的第一项是进行匹配完整的字符串, 之后的项是用圆括号捕获的结果. 如果没有匹配到, 返回null.1234567891011let pos_1 = '0123456789'.match(9);let pos_2 = '0123456789'.match(/8\d+/);let pos_3 = '0123456789'.match(/7\d&#123;1&#125;/);console.log('pos_1', pos_1);console.log('pos_2', pos_2);console.log('pos_3', pos_3);// pos_1 [ '9', index: 9, input: '0123456789' ]// pos_2 [ '89', index: 8, input: '0123456789' ]// pos_3 [ '78', index: 7, input: '0123456789' ]String.prototype.search()描述 :字符串检索匹配正则表达式.语法 :str.search(regexp)regexp : 正则表达式对象, 如果传入一个非正则表达式对象, 则会隐式地使用 new RegExp(obj) 将其转换为一个 RegExp. 如果你未提供任何参数, 直接使用 match(), 那么你会得到一个包含空字符串的 Array : [&quot;&quot;].返回值 : 如果匹配成功, 则 search() 返回正则表达式在字符串中首次匹配项的索引. 否则, 返回 -1.1234567891011let pos_1 = '0123456789'.search(9);let pos_2 = '0123456789'.search(/8\d+/);let pos_3 = '0123456789'.search(/7\d&#123;1&#125;/);console.log('pos_1', pos_1);console.log('pos_2', pos_2);console.log('pos_3', pos_3);// pos_1 9// pos_2 8// pos_3 7String.prototype.toLowerCase()描述 :将字符串转换成小写形式.语法 :str.toLowerCase()12345let str_1 = 'Hello World !'.toLowerCase();console.log('str_1', str_1);// str_1 hello world !String.prototype.toUpperCase()描述 :将字符串转换成大写形式.语法 :str.toUpperCase()12345let str_1 = 'Hello World !'.toUpperCase();console.log('str_1', str_1);// str_1 HELLO WORLD !String.prototype.toString()描述 :将指定对象转换成字符串形式.语法 :str.toString()12345let str_1 = new String('Hello World !');console.log('str_1', str_1, 'str_1.toString()', str_1.toString());// str_1 [String: 'Hello World !'] str_1.toString() Hello World !(不同浏览器展现效果可能不同)String.prototype.valueOf()描述 :返回一个String对象的原始值（primitive value）.语法 :str.valueOf()123456let str = new String('Hello World!');let str_1 = str.valueOf();console.log('str_1', str_1);// str_1 Hello World!String.prototype[@@iterator]()描述 :返回一个String对象的原始值（primitive value）.语法 :str.valueOf()12345678910111213141516171819202122let str = 'Hello World!';let str_1 = str[Symbol.iterator]();console.log('str_1', str_1.next());// str_1 &#123; value: 'H', done: false &#125;for(let item of str) &#123; console.log('item', item);&#125;// item H// item e// item l// item l// item o// item// item W// item o// item r// item l// item d// item !]]></content>
      <categories>
        <category>API总结</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>字符串原型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VS Code使用基础]]></title>
    <url>%2FVS-Code%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[工欲善其事, 必先利其器. 作为一个前端程序猿打造一个好看好用的编辑器, 对于工作效率的提高有很大的帮助.主题字体字体选用的FiraCode, 下载安装然后参见VS Code Instructions相关设置. 其它好看的字体还有Source Code Pro等.颜色主题和文件图标主题颜色主题选用的是One Dark Pro. 编辑器内置了几款颜色主题, 如果没有喜欢的就在扩展主题里找找.文件图标主题配置同颜色主题配置.用户设置Commonly Used控制字段控制内容files.autoSave自动保存editor.tabSize制表符的空格数editor.renderWhitespace空白字符显示方式editor.wordWrap换行方式files.exclude配置排除的文件和文件夹的 glob 模式. 不需要关心的文件或文件夹在此排除.files.associations配置语言的文件关联. eg:&quot;**.jsp&quot;: &quot;javascript&quot;files.trimTrailingWhitespace启用后，将在保存文件时剪裁尾随空格workbench.editor.labelFormat控制编辑器标签的格式window.openFilesInNewWindow控制是否在新窗口中打开文件terminal.integrated.shell.osx终端在 macOS 上使用的 Shell 的路径breadcrumbs.enabled启用/禁用导航路径(面包屑)emmet.includeLanguages在默认不支持 Emmet 的语言中启用 Emmet 缩写功能. eg:&quot;vue-html&quot;: &quot;html&quot;, &quot;javascript&quot;: &quot;javascriptreact&quot;编辑器控制字段控制内容editor.formatOnType控制编辑器在键入一行后是否自动格式化该行editor.minimap.enabled是否显示小地图editor.mouseWheelZoom按住 Ctrl 键并滚动鼠标滚轮时对编辑器字体大小进行缩放editor.parameterHints.enabled在输入时显示含有参数文档和类型信息的小面板files.exclude配置排除的文件和文件夹的 glob 模式. 不需要关心的文件或文件夹在此排除.files.associations配置语言的文件关联. eg:`”.jsp”: “javascript”`*快捷键关键字快捷键删除行cmd + D合并行ctrl + J光标后退ctrl + _光标前进ctrl + shift + _向下面插入行cmd + enter向上面插入行cmd + shift + enter转到文件cmd + P显示所有命令cmd + shift + P文件查找cmd + F全局搜索cmd + shift + F切换行注释cmd + /切换块注释shift + alt + A撤销cmd + Z恢复撤销cmd + shift + Z缩进tab缩进shift + tab移动到行尾cmd + right移动到行首cmd + left向上移动行cmd + up向下移动行cmd + down保持打开状态(workbench.action.keepEditor)cmd + K enter打开集成终端ctrl + `集成终端清屏cmd + K格式化文件shift + alt + F常见操作窗口code命令VS Code快速打开文件夹或文件,可以将其直接拖至VS Code图标上. 或cmd + shift + P打开命令面板, 向Path添加code, 用code命令操作.文件对比工作区可以将其它项目与当前项目置于同一工作区, 在同一个窗口查看编辑.自定义终端在Mac终端改造里, 已经打造好了个性化的终端了. 在VS Code里只需要换个路径即可.在用户设置里用以下配置覆盖.1"terminal.integrated.shell.osx": "/bin/zsh",添加自定义snippetVS Code内置了自定义snippet功能, 用户可以根据自己的需求去添加自己想要的代码段, 灵活且方便, 这样就完全没有必要去安装类似的插件了. 细节可参考[VS Code]跟我一起在Visual Studio Code 添加自定义snippet（代码段），附详细配置.插件Chinese (Simplified) Language Pack for VS Code此中文（简体）语言包为 VS Code 提供本地化界面.Bookmarks在代码中做标记, 可以在不同的标记中快速便捷的切换.Auto Rename Tag修改HTML/XML标签时, 首尾标签会自动同步更改.ESLint一个开源的 JavaScript 代码检查插件, 可以在编写或保存文件时对文件进行检测. 根据规则配置文件对文件进行检测提示, 并可以自动修复部分不符合规则的部分.&quot;eslint.options&quot;: { &quot;configFile&quot;: &quot;**/**/**&quot; } : 本地的配置文件地址路径.eslint.validate: 可被识别的文件类型.eslint.autoFixOnSave: 保存时自动修复.Debugger for Chrome在代码里断点, 就是相对地知道文件在哪里吧, Chrome里打断点还是挺好用地. Debugger for Chrome 配置可参见官网例子.插件什么的真的不见得能提高多少效率, 讲真, 颜值才是正义, 颜值才是王道🤔.]]></content>
      <categories>
        <category>善事利器</category>
      </categories>
      <tags>
        <tag>编辑器</tag>
        <tag>Visual Studio Code</tag>
        <tag>VS Code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[观察者模式再次进阶]]></title>
    <url>%2F%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E5%86%8D%E6%AC%A1%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[发布/订阅者模式发布/订阅模式概念说起观察者模式, 往往会牵扯到发布/订阅模式. 两者存在着很多的相似之处, 它们都是维护着一个列表, 然后都可以对列表的对象进行增删和通知. 不同的地方可能就在于处理添加和通知的方式上吧.发布/订阅模式使用了一个主题/事件通道, 这个通道介于希望接到通知的对象(订阅者)和激活事件的对象(发布者)之间. 该事件系统允许代码定义应用程序的特定事件, 这些事件可以传达自定义参数, 自定义参数包含订阅者所需的值. 其目的是避免订阅者和发布者之间产生依赖关系. ———《设计模式: 可复用面向对象软件基础》戏说发布/订阅模式模式以下所有代码参见publish/subscribe.既然和观察者模式类似, 那么在从观察者模式说起提到的小故事, 就可以接着往下续了.subject1带着那么一拨人回去复命, 经过一段时间的磨合实践, 效果也是很明显. 附近的公司听到风声后, 也纷纷组织派遣员工前来学习. 人多了, 需求也变多了, 这么多人肯定不能再呆在一起学习了. 原来只是一个公司的人呆在一间屋子里学习, 得到命令后大家开始各司其职. 现在, 各个公司的学习内容不同, 它们理应独立开来. 因为各个公司动作可以不同步, 但公司内部一定要同步起来. 为了区别对待, 每个公司都有能和别人区分的令牌, 有了令牌同一个公司的人就可以进入与令牌相对应的房间了(当然一个人也可以有很多令牌, 商业间谍吧😂).1234567// 我是Pubsub, 我负责管理这拨人.class Pubsub &#123; constructor() &#123; // 维护事件列表, 这里将以对象的形式出现, key: value, key: 令牌, value: 同一公司员工列表. this. handles = &#123;&#125; &#125;&#125;现在, 不同公司的人前来学习的时候, 需要告诉Pubsub他们公司的令牌号, 进而引领到令牌对应的房间.12345678910class Pubsub &#123; // 省略 // 注册事件. 如果是公司第一次派人过来, 那就新开一间. subscribe(type, handle) &#123; if (!this.handles[type]) &#123; this.handles[type] = [] &#125; this.handles[type].push(handle) &#125;&#125;如果某个房间的某个人, 或整个房间的人都不打算来了, 也需要Pubsub将其注销.12345678910111213class Pubsub &#123; // 省略 // 注销事件. 公司个人或整体注销. unsubscribe(type, handle) &#123; let pos = this.handles[type].indexOf(handle) if (!handle) &#123; // 不传handle, 则默认注销所有和type事件相关的事件处理函数. this.handles.length = 0 &#125; else &#123; ~pos &amp;&amp; this.handles[type].splice(pos, 1) &#125; &#125;&#125;不同的团体做出了区分, 算是万事具备. 想要哪个房间里的人动起来, 有了令牌号, 只要对着吼一嗓子即可.123456789101112class Pubsub &#123; // 省略 // 通知事件 publish() &#123; // 执行所有和type事件相关的处理函数. let type = Array.prototype.shift.call(arguments) this.handles[type].forEach(handle =&gt; &#123; // 箭头函数不绑定Arguments对象 handle.apply(this, arguments) &#125;) &#125;&#125;让我们看看效果如何.12345678910111213141516171819202122232425let handle1 = (...rest) =&gt; &#123;document.write('handle1', JSON.stringify(rest), '&lt;br/&gt;')&#125;let handle2 = (...rest) =&gt; &#123;document.write('handle2', JSON.stringify(rest))&#125;let ps = new Pubsub()ps.subscribe('notify-1', handle1)ps.subscribe('notify-1', handle2)ps.subscribe('notify-2', handle2)ps.unsubscribe('notify-1', handle2)ps.publish('notify-1', 'hahaha', 'heiheihei', [], &#123;&#125;)ps.publish('notify-2', 'hehehehehe')// 结果:handle1["hahaha","heiheihei",[],&#123;&#125;]handle2["hehehehehe"]不难发现, 我们的Pubsub老师只认令牌😅.]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>观察者模式</tag>
        <tag>发布/订阅模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac终端改造]]></title>
    <url>%2FMac%E7%BB%88%E7%AB%AF%E6%94%B9%E9%80%A0%2F</url>
    <content type="text"><![CDATA[平时Mac使用的shell使bash, 它虽然能满足我们的需要, 但是使用起来不是很方便. zsh可配置性强, 用户可以自定义配置, 个性化强.更换shell查看当前使用的shellecho $SHELL1/bin/bash查看系统当前内置的shellcat /etc/shells123456/bin/bash/bin/csh/bin/ksh/bin/sh/bin/tcsh/bin/zsh如果没有发现/bin/zsh, 就需要手动安装Zsh.替换shellchsh -s /bin/zsh12Changing shell for **.Password for **: your password重启echo $SHELL1/bin/zsh替换成功!安装oh-my-zshoh-my-zsh用来管理Zsh配置的.安装sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;.1234567891011121314Looking for an existing zsh config...Using the Oh My Zsh template file and adding it to ~/.zshrc __ ______ / /_ ____ ___ __ __ ____ _____/ /_/ __ \/ __ \ / __ `__ \/ / / / /_ / / ___/ __ \/ /_/ / / / / / / / / / / /_/ / / /_(__ ) / / /\____/_/ /_/ /_/ /_/ /_/\__, / /___/____/_/ /_/ /____/ ....is now installed!Please look over the ~/.zshrc file to select plugins, themes, and options.p.s. Follow us at https://twitter.com/ohmyzsh.p.p.s. Get stickers and t-shirts at https://shop.planetargon.com.更改配置vim ~/.zshrc12345678910111213141516171819202122232425# Set name of the theme to load --- if set to "random", it will# load a random theme each time oh-my-zsh is loaded, in which case,# to know which specific one was loaded, run: echo $RANDOM_THEME# See https://github.com/robbyrussell/oh-my-zsh/wiki/ThemesZSH_THEME="robbyrussell"# Uncomment the following line to disable bi-weekly auto-update checks.# DISABLE_AUTO_UPDATE="true"# Uncomment the following line to enable command auto-correction.ENABLE_CORRECTION="true"# Uncomment the following line to display red dots whilst waiting for completion.COMPLETION_WAITING_DOTS="true"# Which plugins would you like to load?# Standard plugins can be found in ~/.oh-my-zsh/plugins/*# Custom plugins may be added to ~/.oh-my-zsh/custom/plugins/# Example format: plugins=(rails git textmate ruby lighthouse)# Add wisely, as too many plugins slow down shell startup.plugins=(git)source $ZSH/oh-my-zsh.sh以上是部分配置, 需将#删除才能生效. 键入i进入编辑模式, 修改后esc退出编辑模式, 键入:wq保存退出. oh-my-zsh有支持的主题和插件, 可以自由配置.插件推荐zsh-syntax-highlighting安装zsh-syntax-highlightinggit clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting修改配置(zsh-syntax-highlighting)vim ~/.zshrc123plugins=( git zsh-syntax-highlighting)让修改生效(zsh-syntax-highlighting)source ~/.zshrczsh-autosuggestions安装zsh-autosuggestionsgit clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions修改配置(zsh-autosuggestions)vim ~/.zshrc123plugins=( git zsh-autosuggestions zsh-syntax-highlighting)让修改生效(zsh-autosuggestions)source ~/.zshrc好了, 打完收工!]]></content>
      <categories>
        <category>善事利器</category>
      </categories>
      <tags>
        <tag>Mac终端</tag>
        <tag>oh-my-zsh</tag>
        <tag>zsh</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进击的观察者模式]]></title>
    <url>%2F%E8%BF%9B%E5%87%BB%E7%9A%84%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[商品信息改变带来的烦恼Talk is cheap. Show me the code. (译: 屁话少说, 放码过来)以下所有代码参见Design pattern transformation.12345678910111213141516171819202122232425// 商品的信息: 价格 &amp; 折扣const data = &#123; price: 100, discount: 0.8&#125;// 顾客信息: 是否为会员 &amp; 购买数量 &amp; 总消费 &amp; 购买时间戳const customer = &#123; "VIP": true, "quantity": 10, "total": 0,&#125;// 总消费计算方式total = (info) =&gt; &#123; if(!info.VIP) &#123; info.total = data.price * info.quantity; &#125; else &#123; info.total = data.price * data.discount * info.quantity; &#125;&#125;total(customer);console.log('customer', customer);// customer &#123; VIP: true, quantity: 10, total: 800 &#125;从代码中很容易看得出来, 我们就是想实现一个简单的计费功能. 可现实中, 商品的价格可能并不是一成不变的.data.price = 200价格变动后, 我们需要及时地获取总消费, 那么就必须重新调用下 total 计费.123total(customer);console.log('customer', customer);// customer &#123; VIP: true, quantity: 10, total: 1600 &#125;这是一个大数据时代, 任何数据都有价值. 现在, 我们还想要每次购买时的时间点.12345678910 const customer = &#123; "VIP": true, "quantity": 10, "total": 0,+ "timeStamp": 0 &#125; // 获取购买时间 purchaseTime = (info) =&gt; &#123; info.timeStamp = Date.now(); &#125;于是, 我们需要执行的函数就多了一个.1234total(customer)purchaseTime(customer)console.log('customer', customer)// &#123; VIP: true, quantity: 10, total: 1600, timeStamp: 1542293676297 &#125;如果我们的需求还有很多, 而且不知一个customer呢. 那么, 每次价格变化我们需要执行很多步骤, 每次啊, 麻烦得很.1234567891011121314151617181920+ const customer1 = &#123;+ "VIP": false,+ "quantity": 8,+ "total": 0,+ "timeStamp": 0+ &#125; total(customer) purchaseTime(customer) func(customer) ... funcN(customer1) total(customer1) purchaseTime(customer1) func(customer1) ... funcN(customer) ... funcN(customerN)现在我们就对上面的代码进行观察者模式改造.用观察者模式改造从上面的例子中🌰🀄️不难看出, 每次价格变化时, 我们都需要重复调用满足需求的方法. 不妨想想, 如果我们把这些方法存储起来, 等到价格变化时再去统一调用, 岂不是很方便. 那么问题来了, 这和之前所说的观察者模式(从观察者模式说起)有什么区别呢? 在此, 我们试着用观察者模式改造下.首先观察者模式都是一个套路. 先一个类维护一个列表, 对列表有增删和通知更新功能. 另一个类则是提供了更新接口.123456789101112131415161718192021// 观察目标类class Subject &#123; constructor() &#123; this.observerList = [] &#125; addObserver(observer) &#123; this.observerList.push(observer) &#125; notify(params) &#123; this.observerList.forEach(observer =&gt; &#123; observer.update(params) &#125;) &#125;&#125;// 观察者类class Observer &#123; constructor(fn) &#123; this.update = fn &#125;&#125;接着, 把我们想要调用的方法包装一下, 存储起来.12345678// 将要重复使用的包装一下observer1 = new Observer(total)observer2 = new Observer(purchaseTime)// 存起来let subject = new Subject()subject.addObserver(observer1)subject.addObserver(observer2)每次价格改变时, 只需要通知一下即可.1234// 调整商品价格data.price = 100subject.notify(customer)subject.notify(customer1)改造结束. 初看起来, 可能变得繁琐了. 但是, 遇到复杂的情况, 这不失是一个好办法. 接下来, 我们看看结合Objec.defineProperty会有什么惊喜.与Objec.defineProperty结合支付宝的花呗都可以自己还钱了🤣, 我们为什么还要别人管着😏. 大家都知道经过Objec.defineProperty处理的对象, 在设置和获取对象属性的时候, 会自动触发响应set和get方法. 利用这一点, 我们就可以做到生活自理了. 熟悉的配方, 熟悉的味道. 熟悉的套路我们不妨再走一遍.123456789101112131415161718192021// 观察目标类class Dependency &#123; constructor() &#123; this.watcherList = [] &#125; addObserver(observer) &#123; this.watcherList.push(observer) &#125; notify(params) &#123; this.watcherList.forEach(watcher =&gt; &#123; watcher.update(params) &#125;) &#125;&#125;// 观察类class Watcher &#123; constructor(fn) &#123; this.update = fn &#125;&#125;我们此行的目的, 是要在data.price 或data.discount改变时, 程序能够自动触发, 得到我们想要的结果. 换句话说, 通知更新的时机是在设置data.price或data.discount的时候.12345678910111213 Object.keys(data).forEach(key =&gt; &#123; let value = data[key] const dep = new Dependency() Object.defineProperty(data, key, &#123; set(newVal) &#123; value = newVal dep.notify() &#125;, get() &#123; return value &#125; &#125;)&#125;)对象的每个属性都给了一个依赖实例, 管理自己的依赖. 考虑到customer有很多个, 需要通知到位. 另外, 添加依赖和管理依赖, 前者是因, 后者是果. 在管理之前我们需要想好怎么添加依赖. 回头看一看.123456789101112 // 总消费计算方式 total = (info) =&gt; &#123; if(!info.VIP) &#123; info.total = data.price * info.quantity; &#125; else &#123; info.total = data.price * data.discount * info.quantity; &#125; &#125; // 获取购买时间purchaseTime = (info) =&gt; &#123; info.timeStamp = Date.now();&#125;我们发现, total 函数依赖于data.price或data.discount的. 如果我们在获取属性时去添加依赖倒是一个好时机.1234567891011121314151617181920212223242526272829303132333435 class Dependency &#123; // 省略 &#125;+ Dependency.targey = null;class Watcher &#123; constructor(fn, key) &#123; this.update = fn+ this.key = key+ this.value = this.getter() &#125;+ getter() &#123;+ Dependency.targey = this;+ // 触发下面的get()+ this.value = data[this.key];+ Dependency.targey = null;+ &#125;&#125;Object.keys(data).forEach(key =&gt; &#123; let value = data[key] const dep = new Dependency() Object.defineProperty(data, key, &#123; set(newVal) &#123; value = newVal dep.notify() &#125;, get() &#123;+ if (Dependency.targey) &#123;+ dep.addObserver(Dependency.targey)+ &#125; return value &#125; &#125;)&#125;)然而 purchaseTime 方法里并没有data.price或data.discount可以设置. 所以这个方法行不通. 那么, 干脆紧接着依赖实例去添加依赖吧. 同时考虑到多个customer, 我们封装下.1234567891011121314151617181920212223// 与defineProperty结合function defineReactive(data, watcherList, funcList) &#123; Object.keys(data).forEach(key =&gt; &#123; let value = data[key] const dep = new Dependency() funcList.forEach(func =&gt; &#123; dep.addObserver(new Watcher(func)) &#125;) Object.defineProperty(data, key, &#123; set(newVal) &#123; value = newVal watcherList.forEach(watcher =&gt; &#123; dep.notify(watcher) &#125;) &#125;, get() &#123; return value &#125; &#125;) &#125;)&#125;defineReactive(data, [customer, customer1], [total, purchaseTime])大功告成, 价格变动时, 我们就会自动获取到想要的结果了. 我都能自理了, 你花呗为嘛还不能自己还钱呢😒]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>观察者模式</tag>
        <tag>Object.defineProperty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从观察者模式说起]]></title>
    <url>%2F%E4%BB%8E%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E8%AF%B4%E8%B5%B7%2F</url>
    <content type="text"><![CDATA[观察者模式观察者模式的定义Observer(观察者)是一种设计模式, 其中, 一个对象(称为 subject) 维持一系列依赖于它的观察者对象, 将有关状态的任何变更自动通知给观察者.当一个目标(subject)需要告诉观察者发生了什么有趣的事情, 它会向观察者广播一个通知. 当我们不再希望某个特定的观察者获得其注册目标(subject)发出的改变通知时, 该目标可以将它从观察者列表中删除.“一个或多个观察者对目标的状态感兴趣, 它们通过将自己依附在目标对象上以便注册所感兴趣的内容. 目标状态发生改变并且观察者可能对这些改变感兴趣, 就会发送一个通知消息, 调用每个观察者的更新方法. 当观察者不再对目标状态感兴趣时, 它们可以简单地将自己从中分离.” ———《设计模式: 可复用面向对象软件基础》观察者模式的理解从观察者模式的定义中可以对观察者模式有个大体的了解. 观察者模式中有两类, 一类被称为目标(Subject), 一类被称为观察者(Observer). Subject的工作是维护一系列的Observer, 可以对它们进行添加、删除和通知的操作. Observer的工作则是为Subject状态发生变化需要获得通知的对象提供更新接口.戏说观察者模式先不管观察者模式是什么, 我们可以试着想想如何从观察者模式的定义去实现这些功能. 下面我们从一个小故事说起.从前有个人. 凭着天资聪颖再加上闯荡江湖多年, 无论从事什么行业都能称为行业翘楚, 算是有名气的人物.1class Subject &#123;&#125; // 我是有个人. Subject是江湖送我的绰号.有一天, 有一个初创公司慕名前来拜访, 探讨如何在现在这个激烈的竞争环境下赢得一席之地.1class Observer &#123;&#125; // 我是一家初创公司, Observer是我公司的名字.两人见面直奔主题.‘你可以派些人来, 我给他们做培训. ’, Subject如此说道. Observer点头同意.‘可是我如何才能让他们服从并执行呢?’, Subject问到. ‘我们可以向你提供统一的对接方式’, Observer回答到.‘行, 谁要有兴趣谁就过来吧’12345678/* update是我们的对接方式, fn是我们的职能.只需要走update这个流程, 我们会各司其职.下面这是个我们的模子, 每个走出去的人都大体这样.*/class Observer &#123; constructor(fn) &#123; this.update = fn &#125;&#125;为了后续的开展, 夜曉宸也做了准备. 为随后要来的人腾出了空间, 并想好了如何接待每个人.12345678class Subject &#123; constructor() &#123; this.observesList = []; // 这里是为参与者腾出的空间. &#125; addObserver(observer) &#123; this.observerList.push(observer); // 招待每一个参与者, 就是引导参与者进入腾出的空间. &#125;&#125;不日, Observer派人带着各自本职职务过来了.123const observer1 = new Observer(() =&gt; &#123;document.write(`$&#123;order&#125;: 我是财务, 我要开始算绩效发工资了&lt;br/&gt;`));const observer2 = new Observer(() =&gt; &#123;document.write(`$&#123;order&#125;: 我是后勤客服, 有什么事情需要帮助的?&lt;br/&gt;`));const observer3 = new Observer(() =&gt; &#123;document.write(`$&#123;order&#125;: 我是人事, 我要招人了&lt;br/&gt;`));既然人来了, 那就接待.1234const subject = new Subject(); // 事务繁忙, 派了一个影分身.subject.addObserver(observer1); // 引导observer1进入房间.subject.addObserver(observer2); // 引导observer2进入房间.subject.addObserver(observer3); // // 引导observer3进入房间.‘既然来到了这个房间, 就要明确一点, 那就是你们得听我指令, 到时我会使用你们公司统一的对接方式’1234567class Subject &#123; // 省略 notify(context) &#123; // 由公司提供的统一对接方式，向在场的每一个Observer传达并让其执行. this.observerList.forEach(observer =&gt; observer.update(context)); &#125;&#125;‘如果你们不想呆下去了, 可以和我说, 我可以引导你们出去’12345678class Subject &#123; // 省略 removeObserver(observer) &#123; // 对于不再感兴趣的Observer，可以将其剔除，其不会再收到任何来自Subject的通知. let pos = this.observerList.indexOf(observer); this.observerList.splice(pos, 1); &#125;&#125;‘现在, 要下达指令了!’12// 省略subject.notify('描述下各自的职能');‘好了, 这些就是我们培训的内容, 就是这么简单’‘就这么简单?!?, 既然这样, 就送我出去吧, 我不想再呆下去了 ’, observer2说到.12// 省略subject.removeObserver(observer2);到此故事告一段落了, Observer模式在线Demo.再看观察者模式我们从几段对话中, 稀里糊涂的完成了本文开头观察者模式所定义的那样. 有负责管理一系列依赖的对象, 有提供更新接口的对象. 我们可以看到, 当subject1发出通知时, 每个observe都能去执行. observer们的行为依赖于subject1的. 为什么能够做到这一点, 那是因为observe们的行为作为自身的一部分寄存在了subject1, subject1就可以在需要的时候去自己腾出的小屋子里通知observer们执行.如果subject1 带着这么一波参加过培训的observer们回去交差, 肯定会被笑话. subject1和observer们的这种协作方式, 被称做观察者模式. 这不过是一个模式, 何时存储何种东西, 何时又去执行存储的东西那才是关键. 如果放到上面的小故事里, 那就是何时需要何种人, 何时开始去做事, 这都需要审时度势. 只有这样公司才能在激烈的竞争环境中赢得一席之地. 只有这样, 观察者模式才能发挥它最大的作用.]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>观察者模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Array原型之迭代方法]]></title>
    <url>%2FArray%E5%8E%9F%E5%9E%8B%E4%B9%8B%E8%BF%AD%E4%BB%A3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[ArrayArray对象是用于构造数组的全局对象.概述数组对象是一个有序的数据(原始类型或对象类型)集合, 是一种类列表对象,它的原型提供了数组操作的方法.数组只能用整数作为数组元素的索引,而不是字符串,且从0开始,第一个元素的索引为0.使用非整数并通过[]或.来访问数组或设置数组元素时,所操作的并不是数组列表的元素,而是数组对象属性集合上的变量.数组对象的属性和数组元素列表是分开存储的,并且数组的遍历和修改操作也不能作用于这些命名属性.123456var arr = [];arr['zero'] = 'zero';arr[0] = 0;arr.forEach(item =&gt; console.log(item))// 0原型方法迭代方法Array.prototype.forEach()语法 :array.forEach(callback(currentValue[, index[, array]]){ // do something }[, thisArg])callback : 数组中每个元素都会执行的回调函数.currentValue : 数组中正在被处理的当前元素.index : 数组中正在被处理的当前元素的索引.array : 调用该方法的数组.thisArg : 执行回调函数时this对应的对象. 如果省略了 thisArg 参数, 或者赋值为 null 或 undefined, 则 this 指向全局对象.返回值 :123456789101112let obj = &#123;name: 'obj'&#125;;let arr0 = [3, 2, 1];let arr00 = arr0.forEach(function(currentValue, index, array)&#123; console.log('arr0:', arr0,'currentValue:', currentValue, 'index:', index, 'array:', array, 'thisArg:', this);&#125;, obj);console.log('arr00:', arr00);// arr0: [ 3, 2, 1 ] currentValue: 3 index: 0 array: [ 3, 2, 1 ] thisArg: &#123;name: 'obj' &#125;;// arr0: [ 3, 2, 1 ] currentValue: 2 index: 1 array: [ 3, 2, 1 ] thisArg: &#123;name: 'obj' &#125;;// arr0: [ 3, 2, 1 ] currentValue: 1 index: 2 array: [ 3, 2, 1 ] thisArg: &#123;name: 'obj' &#125;;// arr00: undefined;Array.prototype.map()语法 :array.map(callback(currentValue[, index[, array]]){ // do something }[, thisArg])callback : 数组中每个元素都会执行的回调函数.currentValue : 数组中正在被处理的当前元素.index : 数组中正在被处理的当前元素的索引.array : 调用该方法的数组.thisArg : 执行回调函数时this对应的对象. 如果省略了 thisArg 参数, 或者赋值为 null 或 undefined, 则 this 指向全局对象.返回值 : 由每个数组元素调用callback后的返回值组成的新数组.1234567891011121314let obj = &#123;name: 'obj'&#125;;let arr0 = [3, 2, 1];let arr00 = arr0.map(function(currentValue, index, array)&#123; let newVal = currentValue * 2; console.log('arr0:', arr0, 'currentValue:', currentValue, 'index:', index, 'array:', array, 'newVal:', newVal, 'thisArg:', this); return newVal;&#125;, obj);console.log('arr00:', arr00);// arr0: [ 3, 2, 1 ] currentValue: 3 index: 0 array: [ 3, 2, 1 ] newVal: 6 thisArg: &#123; name: 'obj' &#125;;// arr0: [ 3, 2, 1 ] currentValue: 2 index: 1 array: [ 3, 2, 1 ] newVal: 4 thisArg: &#123; name: 'obj' &#125;;// arr0: [ 3, 2, 1 ] currentValue: 1 index: 2 array: [ 3, 2, 1 ] newVal: 2 thisArg: &#123; name: 'obj' &#125;;// arr00: [ 6, 4, 2 ]Array.prototype.every()语法 :array.every(callback(currentValue[, index[, array]]){ // do something }[, thisArg])callback : 数组中每个元素都会执行的回调函数.currentValue : 数组中正在被处理的当前元素.index : 数组中正在被处理的当前元素的索引.array : 调用该方法的数组.thisArg : 执行回调函数时this对应的对象. 如果省略了 thisArg 参数, 或者赋值为 null 或 undefined, 则 this 指向全局对象.返回值 : 布尔值. 由数组中每个元素调用callback后, 当所有的元素都符合条件(真值)才返回true. 否则, 返回false. 另外, 对于放在空数组上的任何条件, 此方法返回 true.1234567891011121314151617181920212223242526272829303132let obj = &#123; name: 'obj'&#125;let arr0 = [3, 2, 1];let arr00 = arr0.every(function(currentValue, index, array)&#123; let newVal = currentValue * 3; console.log('arr0:', arr0, 'currentValue:', currentValue, 'index:', index, 'array:', array, 'newVal:', newVal, 'thisArg:', this); return newVal &gt; 2;&#125;, obj)console.log('arr00:', arr00);// arr0: [ 3, 2, 1 ] currentValue: 3 index: 0 array: [ 3, 2, 1 ] newVal: 9 thisArg: &#123; name: 'obj' &#125;// arr0: [ 3, 2, 1 ] currentValue: 2 index: 1 array: [ 3, 2, 1 ] newVal: 6 thisArg: &#123; name: 'obj' &#125;// arr0: [ 3, 2, 1 ] currentValue: 1 index: 2 array: [ 3, 2, 1 ] newVal: 3 thisArg: &#123; name: 'obj' &#125;// arr00: true;let obj = &#123; name: 'obj'&#125;let arr0 = [3, 2, 1];let arr00 = arr0.every(function(currentValue, index, array)&#123; let newVal = currentValue * 3; console.log('arr0:', arr0, 'currentValue:', currentValue, 'index:', index, 'array:', array, 'newVal:', newVal, 'thisArg:', this); return newVal &gt; 6;&#125;, obj)console.log('arr00:', arr00);// arr0: [ 3, 2, 1 ] currentValue: 3 index: 0 array: [ 3, 2, 1 ] newVal: 9 thisArg: &#123; name: 'obj' &#125;;// arr0: [ 3, 2, 1 ] currentValue: 2 index: 1 array: [ 3, 2, 1 ] newVal: 6 thisArg: &#123; name: 'obj' &#125;;// arr00: false;Array.prototype.some()语法 :array.some(callback(currentValue[, index[, array]]){ // do something }[, thisArg])callback : 数组中每个元素都会执行的回调函数.currentValue : 数组中正在被处理的当前元素.index : 数组中正在被处理的当前元素的索引.array : 调用该方法的数组.返回值 : 布尔值. 由数组中每个元素调用callback后, 当有元素符合条件(真值)就返回true. 否则, 返回false. 另外, 对于放在空数组上的任何条件, 此方法返回 false.12345678910111213141516171819202122232425262728293031let obj = &#123; name: 'obj'&#125;let arr0 = [3, 2, 1];let arr00 = arr0.some(function(currentValue, index, array)&#123; let newVal = currentValue * 3; console.log('arr0:', arr0, 'currentValue:', currentValue, 'index:', index, 'array:', array, 'newVal:', newVal, 'thisArg:', this); return newVal &gt; 6;&#125;, obj)console.log('arr00:', arr00);// arr0: [ 3, 2, 1 ] currentValue: 3 index: 0 array: [ 3, 2, 1 ] newVal: 9 thisArg: &#123; name: 'obj' &#125;;// arr00: true;let obj = &#123; name: 'obj'&#125;let arr0 = [3, 2, 1];let arr00 = arr0.some(function(currentValue, index, array)&#123; let newVal = currentValue * 3; console.log('arr0:', arr0, 'currentValue:', currentValue, 'index:', index, 'array:', array, 'newVal:', newVal, 'thisArg:', this); return newVal &gt; 9;&#125;, obj)console.log('arr00:', arr00);// arr0: [ 3, 2, 1 ] currentValue: 3 index: 0 array: [ 3, 2, 1 ] newVal: 9 thisArg: &#123; name: 'obj' &#125;;// arr0: [ 3, 2, 1 ] currentValue: 2 index: 1 array: [ 3, 2, 1 ] newVal: 6 thisArg: &#123; name: 'obj' &#125;;// arr0: [ 3, 2, 1 ] currentValue: 1 index: 2 array: [ 3, 2, 1 ] newVal: 3 thisArg: &#123; name: 'obj' &#125;;// arr00: false;Array.prototype.filter()语法 :arr.filter(callback(currentValue[, index[, array]])[, thisArg])callback : 数组中每个元素都会执行的回调函数.currentValue : 数组中正在被处理的当前元素.index : 数组中正在被处理的当前元素的索引.array : 调用该方法的数组.返回值 : 数组中每个元素调用callback后, 由符合条件的数组元素组成的新数组.如果没有符合条件的元素, 则返回空数组.12345678910111213141516let obj = &#123; name: 'obj'&#125;let arr0 = [3, 2, 1];let arr00 = arr0.filter(function(currentValue, index, array)&#123; let boolean = currentValue &gt; 1 ? true : false; console.log('arr0:', arr0, 'currentValue:', currentValue, 'index:', index, 'array:', array, 'thisArg:', this); return boolean;&#125;, obj)console.log('arr00:', arr00);// arr0: [ 3, 2, 1 ] currentValue: 3 index: 0 array: [ 3, 2, 1 ] thisArg: &#123; name: 'obj' &#125;// arr0: [ 3, 2, 1 ] currentValue: 2 index: 1 array: [ 3, 2, 1 ] thisArg: &#123; name: 'obj' &#125;//arr0: [ 3, 2, 1 ] currentValue: 1 index: 2 array: [ 3, 2, 1 ] thisArg: &#123; name: 'obj' &#125;// arr00: [ 3, 2 ];Array.prototype.find()语法 :arr.find(callback(currentValue[, index[, array]])[, thisArg])callback : 数组中每个元素都会执行的回调函数.currentValue : 数组中正在被处理的当前元素.index : 数组中正在被处理的当前元素的索引.array : 调用该方法的数组.返回值 : 数组中每个元素调用callback后, 返回第一个符合条件的元素. 否则返回 undefined.1234567891011121314let obj = &#123; name: 'obj'&#125;let arr0 = [3, 2, 1];let arr00 = arr0.find(function(currentValue, index, array)&#123; let boolean = currentValue &gt; 1 ? true : false; console.log('arr0:', arr0, 'currentValue:', currentValue, 'index:', index, 'array:', array, 'thisArg:', this); return boolean;&#125;, obj)console.log('arr00:', arr00);// arr0: [ 3, 2, 1 ] currentValue: 3 index: 0 array: [ 3, 2, 1 ] thisArg: &#123; name: 'obj' &#125;;// arr00: 3;Array.prototype.findIndex()语法 :arr.findIndex(callback(currentValue[, index[, array]])[, thisArg])callback : 数组中每个元素都会执行的回调函数.currentValue : 数组中正在被处理的当前元素.index : 数组中正在被处理的当前元素的索引.array : 调用该方法的数组.返回值 : 数组中每个元素调用callback后, 返回第一个符合条件的元素索引. 否则返回 -1.1234567891011121314let obj = &#123; name: 'obj'&#125;let arr0 = [3, 2, 1];let arr00 = arr0.findIndex(function(currentValue, index, array)&#123; let boolean = currentValue &gt; 1 ? true : false; console.log('arr0:', arr0, 'currentValue:', currentValue, 'index:', index, 'array:', array, 'thisArg:', this); return boolean;&#125;, obj)console.log('arr00:', arr00);// arr0: [ 3, 2, 1 ] currentValue: 3 index: 0 array: [ 3, 2, 1 ] thisArg: &#123; name: 'obj' &#125;;// arr00: 0;Array.prototype.reduce()语法 :arr.reduce(callback(accumulator[, currentValue[, index[, array]]])[, initialValue])callback : 数组中每个元素都会执行的回调函数.accumulator : 上一个元素调用回调函数后的返回值. 回调函数第一次执行时, 若提供了initialValue,则accumulator取值为initialValue. 若没有提供initialValue, 则accumulator取值为数组中第一个元素.currentValue : 数组中正在被处理的当前元素. 回调函数第一次执行时, 若提供了initialValue, 则currentValue取值为数组中第一个元素. 若没有提供initialValue, 则currentValue取值为数组中第二值.index : 数组中正在被处理的当前元素的索引.array : 调用该方法的数组.返回值 : 数组中每个元素调用callback后, 将上一次回调函数执行结果作为下一次回调函数参数, 并最终返回单个结果值.1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253let arr0 = [3, 2, 1];let arr00 = arr0.reduce(function(accumulator, currentValue, index, array) &#123; console.log('arr0', arr0, 'accumulator:', accumulator, 'currentValue:', currentValue, 'index:', index, 'array:', array); return accumulator + currentValue;&#125;, 0);console.log('arr00:', arr00);// arr0 [ 3, 2, 1 ] accumulator: 0 currentValue: 3 index: 0 array: [ 3, 2, 1 ];// arr0 [ 3, 2, 1 ] accumulator: 3 currentValue: 2 index: 1 array: [ 3, 2, 1 ];// arr0 [ 3, 2, 1 ] accumulator: 5 currentValue: 1 index: 2 array: [ 3, 2, 1 ];// arr00: 6;let arr0 = [3, 2, 1];let arr00 = arr0.reduce(function(accumulator, currentValue, index, array) &#123; console.log('arr0', arr0, 'accumulator:', accumulator, 'currentValue:', currentValue, 'index:', index, 'array:', array); return accumulator + currentValue;&#125;);console.log('arr00:', arr00);// arr0 [ 3, 2, 1 ] accumulator: 3 currentValue: 2 index: 1 array: [ 3, 2, 1 ];// arr0 [ 3, 2, 1 ] accumulator: 5 currentValue: 1 index: 2 array: [ 3, 2, 1 ];// arr00: 6;let arr0 = [1, 2, 3, 44, 5, 3, 2, 53, 1, 2, 3, 5, 44, 53, 55];const reducer = (accumulator, currentValue) =&gt; &#123; console.log('arr0', arr0, 'accumulator', accumulator, 'currentValue', currentValue); if (accumulator.length === 0 || accumulator[accumulator.length - 1] !== currentValue) &#123; accumulator.push(currentValue); &#125; return accumulator;&#125;;let arr00 = arr0.sort((a, b) =&gt; &#123;return a - b&#125;).reduce(reducer, []);console.log('arr00:', arr00);// arr0 [ 1, 1, 2, 2, 2, 3, 3, 3, 5, 5, 44, 44, 53, 53, 55 ] accumulator [] currentValue 1;// arr0 [ 1, 1, 2, 2, 2, 3, 3, 3, 5, 5, 44, 44, 53, 53, 55 ] accumulator [ 1 ] currentValue 1;// arr0 [ 1, 1, 2, 2, 2, 3, 3, 3, 5, 5, 44, 44, 53, 53, 55 ] accumulator [ 1 ] currentValue 2;// arr0 [ 1, 1, 2, 2, 2, 3, 3, 3, 5, 5, 44, 44, 53, 53, 55 ] accumulator [ 1, 2 ] currentValue 2;// arr0 [ 1, 1, 2, 2, 2, 3, 3, 3, 5, 5, 44, 44, 53, 53, 55 ] accumulator [ 1, 2 ] currentValue 2;// arr0 [ 1, 1, 2, 2, 2, 3, 3, 3, 5, 5, 44, 44, 53, 53, 55 ] accumulator [ 1, 2 ] currentValue 3;// arr0 [ 1, 1, 2, 2, 2, 3, 3, 3, 5, 5, 44, 44, 53, 53, 55 ] accumulator [ 1, 2, 3 ] currentValue 3;// arr0 [ 1, 1, 2, 2, 2, 3, 3, 3, 5, 5, 44, 44, 53, 53, 55 ] accumulator [ 1, 2, 3 ] currentValue 3;// arr0 [ 1, 1, 2, 2, 2, 3, 3, 3, 5, 5, 44, 44, 53, 53, 55 ] accumulator [ 1, 2, 3 ] currentValue 5;// arr0 [ 1, 1, 2, 2, 2, 3, 3, 3, 5, 5, 44, 44, 53, 53, 55 ] accumulator [ 1, 2, 3, 5 ] currentValue 5;// arr0 [ 1, 1, 2, 2, 2, 3, 3, 3, 5, 5, 44, 44, 53, 53, 55 ] accumulator [ 1, 2, 3, 5 ] currentValue 44;// arr0 [ 1, 1, 2, 2, 2, 3, 3, 3, 5, 5, 44, 44, 53, 53, 55 ] accumulator [ 1, 2, 3, 5, 44 ] currentValue 44;// arr0 [ 1, 1, 2, 2, 2, 3, 3, 3, 5, 5, 44, 44, 53, 53, 55 ] accumulator [ 1, 2, 3, 5, 44 ] currentValue 53;// arr0 [ 1, 1, 2, 2, 2, 3, 3, 3, 5, 5, 44, 44, 53, 53, 55 ] accumulator [ 1, 2, 3, 5, 44, 53 ] currentValue 53;// arr0 [ 1, 1, 2, 2, 2, 3, 3, 3, 5, 5, 44, 44, 53, 53, 55 ] accumulator [ 1, 2, 3, 5, 44, 53 ] currentValue 55;// arr00: [ 1, 2, 3, 5, 44, 53, 55 ];Array.prototype.reduceRight()语法(从右向左遍历,见reduce) :arr.reduceRight(callback(accumulator[, currentValue[, index[, array]]])[, initialValue])Array.prototype.entries()语法 :arr.entries()返回值 : 一个新的包含数组中每个索引的键/值对的Array Iterator对象.1234567891011121314151617181920212223242526272829303132333435let arr0 = [3, 2, 1];let arr00 = arr0.entries();let arr000 = arr00.next();let arr0000 = arr000.value;console.log('arr00:', arr00);console.log('arr000:', arr000);console.log('arr0000:', arr0000);// arr00;// Array Iterator &#123;&#125;// __proto__: Array Iterator// next: ƒ next()// Symbol(Symbol.toStringTag): "Array Iterator"// arr000;// &#123;value: Array(2), done: false&#125;j;// arr0000;// [0, 3];let arr0 = [3, 2, 1];let arr00 = arr0.entries();for(let item of arr00) &#123; console.log(item);&#125;// [ 0, 3 ];// [ 1, 2 ];// [ 2, 1 ];let arr0 = [3, 2, 1];let arr00 = [...arr0.entries()];console.log('arr00:', arr00);// arr00: [ [ 0, 3 ], [ 1, 2 ], [ 2, 1 ] ]Array.prototype.keys()语法 :arr.keys()返回值 : 一个新的包含数组中每个索引键的Array Iterator对象.123456789101112131415let arr0 = [3, 2, 1];let arr00 = arr0.keys();for(let item of arr00) &#123; console.log(item);&#125;// 0// 1// 2let arr0 = [3, 2, 1];let arr00 = [...arr0.keys()];console.log('arr00:', arr00);// arr00: [ 0, 1, 2 ];Array.prototype.values()语法 :arr.values()返回值 : 一个新的包含数组每个索引对应值的 Array Iterator 对象.1234567891011121314let arr0 = [3, 2, 1];let arr00 = arr0.keys();for(let item of arr00) &#123; console.log(item);&#125;// 0// 1// 2let arr0 = [3, 2, 1];let arr00 = [...arr0.keys()];console.log('arr00:', arr00);// arr00: [ 0, 1, 2 ];Array.prototype[@@iterator]()语法 :arr[Symbol.iterator]()返回值 : 数组的 iterator 方法，默认情况下与 values() 返回值相同.]]></content>
      <categories>
        <category>API总结</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>数组原型</tag>
        <tag>迭代方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Array原型之非变异方法]]></title>
    <url>%2FArray%E5%8E%9F%E5%9E%8B%E4%B9%8B%E9%9D%9E%E5%8F%98%E5%BC%82%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[ArrayArray对象是用于构造数组的全局对象.概述数组对象是一个有序的数据(原始类型或对象类型)集合, 是一种类列表对象,它的原型提供了数组操作的方法.数组只能用整数作为数组元素的索引,而不是字符串,且从0开始,第一个元素的索引为0.使用非整数并通过[]或.来访问数组或设置数组元素时,所操作的并不是数组列表的元素,而是数组对象属性集合上的变量.数组对象的属性和数组元素列表是分开存储的,并且数组的遍历和修改操作也不能作用于这些命名属性.123456var arr = [];arr['zero'] = 'zero';arr[0] = 0;arr.forEach(item =&gt; console.log(item))// 0原型方法非变异方法Array.prototype.slice()描述 :浅拷贝数组指定区域的元素.语法 :arr.slice(begin[, end])begin(可选) : 起始索引, 默认值为0. 如果是负数, 则开始索引会被自动计算成为 this.length + start.end : 终止索引, 默认值 this.length. 不包括end位置. 如果是负数时, 规则如上.返回值 : 返回截取的新数组(浅复制).1234567891011let arr0 = [3, 2, 1];let arr00 = arr0.slice();console.log('arr0:', arr0, 'arr00:', arr00);// arr0: [ 3, 2, 1 ] arr00: [ 3, 2, 1 ]let arr1 = [5, 4, 3, 2, 1];let arr11 = arr1.slice(2, 3);console.log('arr1:', arr1, 'arr11:', arr11);// arr1: [ 5, 4, 3, 2, 1 ] arr11: [ 3 ].Array.prototype.concat()描述 :合并多个值或数组.语法 :array.concat(element0[, element1[, ...[, elementN]]])elementN : 将要连接的值或数组.返回值 : 多个值或数组合并后的新数组.12345678910111213let arr0 = [6, 5, 4];let arr1 = [3, 2, 1];let arr = arr0.concat(arr1);console.log('arr0:', arr0, 'arr1:', arr1, 'arr:', arr);// arr0: [ 6, 5, 4 ] arr1: [ 3, 2, 1 ] arr: [ 6, 5, 4, 3, 2, 1 ]let arr2 = [6, 5, 4];let arr3 = [2, 1];let arr = arr2.concat(3, arr3);console.log('arr2: ', arr2, 'arr3: ', arr3, 'arr', arr);// arr2: [ 6, 5, 4 ] arr3: [ 2, 1 ] arr [ 6, 5, 4, 3, 2, 1 ]Array.prototype.join()描述 :将数组众元素用指定字符连接成字符串.语法 :arr.join(connector)connector : 指定一个字符链接数组中的每个元素, 默认逗号连接.返回值 : 用指定连接符将数组中元素连接起来的字符串.1234567let arr0 = [3, 2, 1];let str1 = arr0.join();let str2 = arr0.join('');let str3 = arr0.join('-');console.log('arr0:', arr0, 'str1:', str1, 'str2:', str2, 'str3:', str3);// arr0: [ 3, 2, 1 ] str1: 3,2,1 str2: 321 str3: 3-2-1;Array.prototype.toString()描述 :用字符串形式表示数组元素.语法 :arr.toString()返回值 : 逗号连接数组元素组成的字符串. 当数组元素为数组时, 自动调用其toString()方法.123456let arr0 = [3, 2, 1];let arr00 = arr0.toString();let arr1 = [[6, [5, 4]], 3, 2, 1].toString();console.log('arr0:', arr0, 'arr00:', arr00, 'arr1:', arr1);// arr0: [ 3, 2, 1 ] arr00: 3,2,1 arr1: 6,5,4,3,2,1;Array.prototype.includes()描述 :判断数组中是否指定值.语法 :arr.includes(searchElement[, fromIndex])searchElement : 需要查询的值.fromIndex : 起始索引, 默认值为0. 如果是负数时, 规则如上.返回值 : 布尔值.123456let arr0 = [3, 2, 1];let a = arr0.includes(3);let b = arr0.includes(3, 1);console.log('arr0', arr0, 'a:', a, 'b:', b);// arr0 [ 3, 2, 1 ] a: true b: false;Array.prototype.indexOf()描述 :查询指定元素在数组中首次出现的索引位置.语法 :arr.indexOf(searchElement[, fromIndex])searchElement : 需要查询的值.fromIndex : 起始索引, 默认值为0. 如果是负数时, 规则如上.返回值 : 首次被找到的元素在数组中的索引位置; 若没有找到则返回 -1.123456let arr0 = [3, 2, 1];let a = arr0.indexOf(1);let b = arr0.indexOf(3, 1);console.log('arr0:', arr0, 'a:', a, 'b:', b);// arr0: [ 3, 2, 1 ] a: 2 b: -1;Array.prototype.lastIndexOf()描述 :从数组的后面向前查找, 查询指定元素在数组中首次出现的索引位置.语法 :arr.lastIndexOf(searchElement[, fromIndex = arr.length - 1])searchElement : 需要查询的值.fromIndex : 逆向查找起始索引, 默认值 this.length - 1.返回值 : 逆向首次被找到的元素在数组中的索引位置.123456let arr0 = [3, 2, 1];let a = arr0.lastIndexOf(1);let b = arr0.lastIndexOf(3, 1);console.log('arr0:', arr0, 'a:', a, 'b:', b);// arr0: [ 3, 2, 1 ] a: 2 b: 0;]]></content>
      <categories>
        <category>API总结</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>数组原型</tag>
        <tag>非变异方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Array原型之变异方法]]></title>
    <url>%2FArray%E5%8E%9F%E5%9E%8B%E4%B9%8B%E5%8F%98%E5%BC%82%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[ArrayArray对象是用于构造数组的全局对象.概述数组对象是一个有序的数据(原始类型或对象类型)集合, 是一种类列表对象,它的原型提供了数组操作的方法.数组只能用整数作为数组元素的索引,而不是字符串,且从0开始,第一个元素的索引为0.使用非整数并通过[]或.来访问数组或设置数组元素时,所操作的并不是数组列表的元素,而是数组对象属性集合上的变量.数组对象的属性和数组元素列表是分开存储的,并且数组的遍历和修改操作也不能作用于这些命名属性.123456var arr = [];arr['zero'] = 'zero';arr[0] = 0;arr.forEach(item =&gt; console.log(item))// 0原型方法变异方法Array.prototype.push()描述 :在数组末尾添加一个或多个元素.语法 :arr.push(element0 ..., elementN)elementN : 将要添加到数组末尾的元素.返回值 : 被改动后的原数组的length值, 且原数组被改变.12345let arr0 = [3, 2, 1];let arr0Len = arr0.push('Array');console.log('arr0:', arr0, 'arr0Len:', arr0Len);// arr0: [3, 2, 1, 'Array'] arr0Len: 4;Array.prototype.unshift()描述 :在数组开头添加一个或多个元素.语法 :arr.unshift(element1, ..., elementN)elementN : 将要添加到数组开头的元素.返回值 : 被改动后的原数组的length值, 且原数组被改变.12345let arr0 = [3, 2, 1];let arr0Len = arr0.unshift('Array');console.log('arr0:', arr0, 'arr0Len:', arr0Len);// arr0: ['Array', 3, 2, 1] arr0Len: 4;Array.prototype.pop()描述 :从数组中删除最后一个元素.语法 :arr.pop()返回值 : 被删除的数组元素(空属组调用, 则返回undefined), 且原数组被改变.12345let arr0 = [3, 2, 1];let ele = arr0.pop();console.log('arr0:', arr0, 'ele:', ele);// arr0: [3, 2] ele: 1;Array.prototype.shift()描述 :从数组中删除第一个元素.语法 :arr.shift()返回值 : 被删除的数组元素(空属组调用, 则返回undefined), 且原数组被改变.12345let arr0 = [3, 2, 1];let ele = arr0.shift();console.log('arr0:', arr0, 'ele:', ele);// arr0: [2, 1] ele: 3;Array.prototype.splice()描述 :从数组中删除指定数量的元素并添加向数组添加元素.语法 :array.splice(start[, deleteCount[, element1[, ...[, elementN]]]])start : 指定修改位置(从0计数).deleteCount 要移除的数组元素个数. 默认值为 this.length - start.elementN : 要添加的数组元素.返回值 : 由被删除的元素组成的数组, 且原数组被改变.1234567891011121314151617181920212223let arr0 = [3, 2, 1];let arr00 = arr0.splice(2, 0, 4, 5, 6);console.log('arr0:', arr0, 'arr00:', arr00);// arr0: [3, 2, 4, 5, 6, 1] arr00: [];let arr1 = [3, 2, 1];let arr11 = arr1.splice(2, 1, 4, 5, 6);console.log('arr1:', arr1, 'arr11:', arr11);// arr1: [3, 2, 4, 5, 6] arr11: [1];let arr3 = [3, 2, 1];let arr33 = arr3.splice(1, 2);console.log('arr3:', arr3, 'arr33:', arr33);// arr3: [3] arr33: [2, 1];let arr4 = [3, 2, 1];let arr44 = arr4.splice(3, 0 , 4, 5, 6);console.log('arr4:', arr4, 'arr44:', arr44);// arr4: [3, 2, 1, 4, 5, 6] arr44: [];Array.prototype.sort()描述 :用原地算法对数组的元素进行排序.语法 :arr.sort([compareFunction])compareFunction : 用来指定按某种顺序进行排列的函数. 如果省略, 元素按照转换为的字符串的各个字符的Unicode位点进行排序. 指明了 compareFunction, 那么数组会按照调用该函数的返回值排序. a 和 b 是两个将要被比较的元素:compareFunction(a, b) 小于 0, 那么 a 会被排列到 b 之前;compareFunction(a, b) 等于 0, a 和 b 的相对位置不变;compareFunction(a, b) 大于 0, b 会被排列到 a 之前;返回值 : 排序后的数组.12345let arr0 = [3, 4, 2, 5, 1];let arr00 = arr0.sort((a, b) =&gt; a-b);console.log('arr0:', arr0, 'arr00:', arr00);// arr0:, [1, 2, 3, 4, 5] arr00: [1, 2, 3, 4, 5];Array.prototype.reverse()描述 :将数组中元素的位置颠倒.语法 :arr.reverse()返回值 : 位置颠倒后的数组.12345let arr0 = [3, 2, 1];let arr00 = arr0.reverse();console.log('arr0:', arr0, 'arr00:', arr00);// arr0: [1, 2, 3] arr00: [1, 2, 3];Array.prototype.copyWithin()描述 :将数组的某一部分浅复制到指定位置.语法 :arr.copyWithin(target[, start[, end]])target : 索引起始为0. 被复制的内容将要替换的位置. 如果是负数, target将从 this.length + target开始计算.start : 起始索引, 默认值为0. 被复制内容的起始位置, 包括start位置的元素. 如果是负数, 则开始索引会被自动计算成为 this.length + start.end : 终止索引, 默认值为this .length, 索引起始为0. 被复制内容的结束位置, 但不包括end位置的元素. 如果是负数. 则终止索引会被自动计算成为 this.length + end.返回值 : 被改动后的原数组. 数组内容变化, 长度不变.1234567891011121314151617let arr0 = [3, 2, 1];let arr00 = arr0.copyWithin(2, 0);console.log('arr0:', arr0, 'arr00:', arr00);//arr0: [3, 2, 3] arr00: [3, 2, 3];let arr1 = [3, 2, 1];let arr11 = arr1.copyWithin(2, 1, 2);console.log('arr1:', arr1, 'arr11:', arr11);// arr1: [3, 2, 2] arr11: [3, 2, 2];let arr2 = [3, 2, 1];let arr22 = arr2.copyWithin(-1, -2, -1);console.log('arr2', arr2, 'arr22', arr22);// arr1: [3, 2, 2] arr11: [3, 2, 2];Array.prototype.fill()描述 :将数组的某一区域的全部元素用指定值替换.语法 :arr.fill(value[, start[, end]])value : 填充数组的参数值.start : 起始索引, 默认值为 0. 如果是负数时, 规则如上.end : 终止索引, 默认值为 this.length. 不包括end位置. 如果是负数时, 规则如上.返回值 : 被改动后的原数组.1234567891011let arr0 = [3, 2, 1];let arr00 = arr0.fill(3);console.log('arr0:', arr0, 'arr00:', arr00);// arr0: [3, 3, 3] arr00: [3, 3, 3];let arr1 = [3, 2, 1];let arr11 = arr1.fill(3, 1);console.log('arr1:', arr1, 'arr11:', arr11);// arr1: [3, 3, 3] arr11: [3, 3, 3]]]></content>
      <categories>
        <category>API总结</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>数组原型</tag>
        <tag>变异方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Array构造函数]]></title>
    <url>%2FArray%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[ArrayArray对象是用于构造数组的全局对象.概述数组对象是一个有序的数据(原始类型或对象类型)集合, 是一种类列表对象,它的原型提供了数组操作的方法.数组只能用整数作为数组元素的索引,而不是字符串,且从0开始,第一个元素的索引为0.使用非整数并通过[]或.来访问数组或设置数组元素时,所操作的并不是数组列表的元素,而是数组对象属性集合上的变量.数组对象的属性和数组元素列表是分开存储的,并且数组的遍历和修改操作也不能作用于这些命名属性.123456var arr = [];arr['zero'] = 'zero';arr[0] = 0;arr.forEach(item =&gt; console.log(item))// 0构造函数属性Array.length构造函数的length属性,该属性为静态属性(详见Function.length),不是数组实例的length属性,其值为1.123console.log(Array.length);// 1Array.prototype构造函数的原型对象,所有的数组实例都会从Array.prototype继承属性和方法.通过扩展Array原型上的属性和方法进而为所有的数组实例增加属性和方法.123456789101112Array.prototype.type = "Array";Array.prototype.first = function() &#123; return this[0];&#125;;var arr = [3, 2, 1];arr.type;// Array;arr.first();// 3;构造函数方法Array.from()描述 :从一个类似数组或可迭代对象中创建一个新的数组实例.语法 :Array.from(arrayLike[, mapFn[, thisArg]])ArrrayLike : 伪数组对象(拥有length属性和若干索引属性) 和 可迭代对象.mapFn : 返回的新数组都会执行的回调函数.thisArg : 执行回调函数时this对应的对象.返回值 : 新的数组实例.123456789101112131415161718Array.from('Array');// ["A", "r", "r", "a", "y"];(function () &#123; return Array.from(arguments);&#125;)(3, 2, 1)// [3, 2, 1];let s = new Set(['array', Array]);Array.from(s);// ["array", function];Array.from([3, 2, 1], x =&gt; x.toString());// ["3", "2", "1"];Array.isArray()描述 :判断待验证的参数是否为Array.语法 :Array.isArray(obj)obj : 待验证参数.返回值 : 若待验证参数为数组时,则为true; 否则false.123456789101112131415161718Array.isArray([]);// true;Array.isArray(&#123;&#125;);// false;Array.isArray(Array.prototype);// true;// Polyfillif (!Array.isArray) &#123; Array.isArray = function(arg) &#123; return Object.prototype.toString.call(arg) === '[object Array]'; &#125;;&#125;;Array.of()描述 :创建一个由传入参数组成的新数组实例, 而不考虑参数的数量或类型.语法 :Array.of(element0[, element1[, ...[, elementN]]])elementN : 任意个参数,将顺序得成为数组的元素.返回值 : 新的数组实例.123456789101112131415161718Array.of(3);// [3];Array.of(3, 2, 1);// [3, 2, 1];Array.of('Array', Array);// ["Array", function];// Polyfillif (!Array.of) &#123; Array.of = function() &#123; return Array.prototype.slice.call(arguments); &#125;;&#125;]]></content>
      <categories>
        <category>API总结</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>构造函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器缓存机制]]></title>
    <url>%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[浏览器缓存强缓存释义: 客户端第一次问服务器要某个资源时，服务器丢还给客户端所请求的这个资源同时，告诉客户端将这个资源保存在本地，并且在未来的某个时点之前如果还需要这个资源，直接从本地获取就行了，不用向服务器请求.这种方式缓存下来的资源称为强缓存.Expires &amp; Cache-Control:max-ageExpires:该字段是http1.0时的规范，值为一个绝对时间的GMT格式的时间字符串，代表缓存资源的过期时间，在这个时点之前，即命中缓存.Cache-Control:该字段是http1.0时的规范，值为一个绝对时间的GMT格式的时间字符串，代表缓存资源的过期时间，在这个时点之前，即命中缓存.参数:no-cache: 如果请求头部包含no-cache指令，表示客户端不接收缓存过的响应.中间缓存服务器必须将请求转发给给源服务器. 浏览器强制刷新(window下ctrl+F5)就是这个原理，所以的请求都设置no-cacheno-store: 暗示请求和响应包含机密信息，不能进行缓存.区分: no-store才是真正的不缓存max-age: 该指令用来标识缓存资源的最大有效期. 如果max-age=0，就会向源服务器发送请求进行缓存资源新鲜度的验证.浏览器普通刷新F5“Cache-Control”:” cache-directive”*作为请求首部时，cache-directive 的可选值有:“Cache-Control”:” cache-directive”*作为响应首部时，cache-directive 的可选值有:在请求头中max-age=0与no-cache的区别？返回的状态来看：no-cache都是200，而max-age可能是304（如果浏览器有缓存）. 请求参数：max-age请求头一般会携带If-Modified-Since或If-None-Match字段进行新鲜度验证，而no-cache不会携带. F5刷新是max-age=0来实现，而强制刷新(Ctrl+F5)是通过no-cache实现. 异同: Expires是HTTP 1.0+的首部，用来指定一个绝对的过期日期，依赖客户端时间设置的准确性,缓存时间是相对服务器上的时间而言的.而max-age是HTTP/1.1的Cache-Control的一个字段，用来指定文档的最大使用时间.协商缓存释义: 客户端第一次问服务器要某个资源时，服务器丢还给客户端所请求的这个资源同时，将该资源的一些信息（文件摘要、或者最后修改时间）也返回给客户端，告诉客户端将这个资源缓存在本地.当客户端下一次需要这个资源时，将请求以及相关信息（文件摘要、或者最后修改时间）一并发送给服务器，由服务器来判断客户端缓存的资源是否需要更新：如不需要更新，就直接告诉客户端获取本地缓存资源；如需要更新，则将最新的资源连同相应的信息一并返回给客户端.Last-Modified &amp; If-Modified-Since &amp; Etag &amp; If-None-MatchLast-Modidied &amp; If-Modified-Since:Last-Modified: 为实体首部字段，值为资源最后更新时间，随服务器response返回.If-Modified-Since: 为请求首部字段，通过比较两个时间来判断资源在两次请求期间是否有过修改，如果没有修改，则命中协商缓存，浏览器从缓存中获取资源；如果有过修改，则服务器返回资源，同时返回新的Last-Modified时间.Etag &amp; If-None-Match:Etag: 为相应头部字段，表示资源内容的唯一标识，随服务器response返回.If-None-Match: 为请求头部字段，服务器通过比较请求头部的If-None-Match与当前资源的ETag是否一致来判断资源是否在两次请求之间有过修改，如果没有修改，则命中协商缓存，浏览器从缓存中获取资源；如果有过修改，则服务器返回资源，同时返回新的ETag.不能缓存的请求HTTP信息头中包含Cache-Control:no-cache，pragma:no-cache（HTTP1.0），或Cache-Control:max-age=0等告诉浏览器不用缓存的请求. Cache-Control: no-cache：这个很容易让人产生误解，使人误以为是响应不被缓存.实际上Cache-Control: no-cache是会被缓存的，只不过每次在向客户端（浏览器）提供响应数据时，缓存都要向服务器评估缓存响应的有效性需要根据Cookie，认证信息等决定输入内容的动态请求是不能被缓存的经过HTTPS安全加密的请求（有人也经过测试发现，ie其实在头部加入Cache-Control：max-age信息，firefox在头部加入Cache-Control:Public之后，能够对HTTPS的资源进行缓存，参考《HTTPS的七个误解》）POST请求无法被缓存HTTP响应头中不包含Last-Modified/Etag，也不包含Cache-Control/Expires的请求无法被缓存浏览器缓存机制示意图]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github+Hexo+Next博客搭建之Hexo,Next及部署]]></title>
    <url>%2FGithub-Hexo-Next%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%B9%8BHexo-Next%E5%8F%8A%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[博客已经搭建好了,自然可以趁热打铁写一些博客搭建的经验.一是方便自己以后查看,免得忘记.二是如果有人想了解博客搭建的过程,也正好有个参考.(如果SEO做的好,就有可能看到这篇文章).本文仅记录怎么去搭建博客,而不会解释每一步原理,有些东西我自己都没有搞的太清楚.毕竟我只是想借助博客这个平台记录平时工作的经验而已,细究相关方面知识并不是我的最终目的现在回头看博客的搭建过程,可以总结归纳以下几点. markdown,git和GitHub,github和coding部署, Hexo和Next了解, SEO等Hexo,Next,部署,SEO该博客的搭建用的是Hexo博客框架,详细的说明官方文档都有提到.在主题的选择上用的是Next,对应的也有相关的官方文档.接下来就搭建过程中遇到的简单介绍一下Hexo中基本指令npm install -g hexo-cli // npm安装Hexo, 非Hexo中命令 hexo init &lt;folder&gt; // 指定文件夹下初始化Hexo,若没有设置folder, Hexo默认在目前的文件夹建立网站 cd &lt;folder&gt; // 进入指定文件夹, 非Hexo中命令 npm install // 安装配置文件packge.json中的依赖, 非Hexo中命令 hexo new [layout] &lt;title&gt; // 新建一篇文章.layout默认default_layout参数,标题有空格,需使用引号括起来 hexo generate // 生成静态文件. -d, --deploy 文件生成后立即部署网站.可简写为 hexo g hexo server // 启动服务器.默认情况下网址为:http://loalhost:4000/. -p, --port 重设端口 hexo deploy // 部署网站. -g, --generate 部署之前预先生成静态文件.可简写为 hexo d hexo clean // 清除缓存文件和已生成的静态文件 Hexo部署地址配置打开站点配置文件_config.yml,找到deploy字段,配置如下deploy: - type: git // 以下是我的git地址 repo: git@github.com:yexiaochen/yexiaochen.github.io.git branch: master - type: git // 以下是我的coding地址 repo: git@git.coding.net:yexiaochen/yexiaochen.coding.me.git branch: master 安装Next主题定位到Hexo站点目录下,执行一下命令即可git clone https://github.com/iissnan/hexo-theme-next themes/next 克隆完成后,打开站点配置文件_config.yml,找到theme字段,并将其值更改为next设置菜单页面Next主题有默认的菜单项,部分菜单项需要自己添加.添加菜单项页面新建标签页面在根目录下新建标签页面hexo new page tags 在新建的页面编辑一下内容123456---title: All tagsdate: 2018-03-24 18:02:30type: &quot;tags&quot;comments: false---在主题配置文件_config.yml内, 找到menu字段,添加如下内容123456789menu:home: / || home# about: /about/ || usertags: /tags/ || tagscategories: /categories/ || tharchives: /archives/ || archive# schedule: /schedule/ || calendar# sitemap: /sitemap.xml || sitemap# commonweal: /404/ || heartbeat在菜单项里添加分类项操作同上添加gitment评论 添加gitalk评论远程仓库新建一个repository,名字随意,待会儿会用到添加OAuth Apps.登陆GitHub,通过Settings =&gt; Developer settings =&gt; OAuth Apps,点击New OAuth App.添加后会生成Client ID和Client Secretgitalk和gitment是差不多的产品, 在我们更换评论系统时, 可以在其基础上修改. 在主题配置文件_config.yml内, 找到gitment字段,添加如下内容.12345678910111213gitment: enable: true mint: true # RECOMMEND, A mint on Gitment, to support count, language and proxy_gateway count: true # Show comments count in post meta area lazy: true # Comments lazy loading with a button cleanly: true # Hide &apos;Powered by ...&apos; on footer, and more language: # Force language, or auto switch by theme github_user: yexiaochen # MUST HAVE, Your Github ID 18507780 github_repo: blog-gitment # MUST HAVE, The repo you use to store Gitment comments client_id: your_client_id # MUST HAVE, Github client id for the Gitment client_secret: your_client_secret # EITHER this or proxy_gateway, Github access secret token for the Gitment proxy_gateway: # Address of api proxy, See: https://github.com/aimingoo/intersect redirect_protocol: # Protocol of redirect_uri with force_redirect_protocol when mint enabled在themes/next/layout/_third-party/comments/gitment.swig文件中, 按照gitalk文档里的配置进行修改.123456789const gitalk = new Gitalk(&#123;clientID: 'GitHub Application Client ID',clientSecret: 'GitHub Application Client Secret',repo: 'GitHub repo',owner: 'GitHub repo owner',admin: ['GitHub repo owner and collaborators, only these guys can initialize github issues'],id: location.pathname, // Ensure uniqueness and length less than 50distractionFreeMode: false // Facebook-like distraction free mode&#125;)注意: gitalk 需要GitHub账号登陆才可以创建初始化.部署coding部署到coding和部署到GitHub类似,也是要添加SSH的.新建的项目名称也是要求按照一定的规范来,细节可参考Coding Pages.在Pages服务的设置可参考下图DNS解析设置购买域名后,要对其进行解析设置.因为国外墙的原因,故博客在部署时也选在了不同的平台上.不同的解析路线对应不同的项目URL博客的搭建到此就结束了,其中还是有许多细节没有提到,时间久了已经忘了大部分了]]></content>
      <categories>
        <category>善事利器</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
        <tag>coding</tag>
        <tag>部署</tag>
        <tag>DNS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github+Hexo+Next博客搭建之git和GitHub]]></title>
    <url>%2FGithub-Hexo-Next%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%B9%8Bgit%E5%92%8C%08GitHub%2F</url>
    <content type="text"><![CDATA[博客已经搭建好了,自然可以趁热打铁写一些博客搭建的经验.一是方便自己以后查看,免得忘记.二是如果有人想了解博客搭建的过程,也正好有个参考.(如果SEO做的好,就有可能看到这篇文章).本文仅记录怎么去搭建博客,而不会解释每一步原理,有些东西我自己都没有搞的太清楚.毕竟我只是想借助博客这个平台记录平时工作的经验而已,细究相关方面知识并不是我的最终目的.现在回头看博客的搭建过程,可以总结归纳以下几点. markdown,git和GitHub,github和coding部署, Hexo和Next了解, SEO等git和GitHub接下来会按一下流程展开,本地git配置 =&gt; 关联远程仓库 =&gt; 初始化仓库.由于博主使用的Mac,执行命令时会和window下cmd有所区别.git配置完成git 的安装后,在使用之前需要配置一些全局参数, 如username和email.因为GitHub每次commit都会记录它们.git config --global user.name &quot;username&quot; git config --global user.email &quot;email&quot; 除了username和email外,还有许多自定义配置,示例:git config --global color.ui true // git输出显示不同颜色 git config --global ignorecase true // git对仓库中的文件大小写敏感 git config --global alias.st status // git提供alias的功能,git status缩写为git st git config --global apply.whitespace nowarn // git忽略空白的变化 查看所有已经做出的配置:git config -l 或 git config --list 添加远程仓库首先在github官网有自己的账号,之后就可以创建仓库了.添加SSH Key由于你的本地Git仓库和github仓库之间的传输是通过SSH加密的,所以需执行以下步骤:本地创建ssh key.$ ssh-keygen -t rsa -C &quot;your_email@youremail.com&quot; 后面的your_email@youremail.com改为你在github上注册的邮箱,之后会要求确认路径和输入密码,我们默认一路回车就行.成功的话会在~/下生成.ssh文件夹,进去打开id_rsa.pub,复制里面的key.ls -al ~/.ssh // 查看是否存在id_rsa.pub,若存在,执行下一步; cd ~/.ssh // 进入.ssh目录 cat id_rsa.pub // 查看复制id_rsa.pub 在GitHub里添加复制的id_rsa.pub. Settings =&gt; SSH and GPG keys =&gt;New SSH key.操作之后,如图示:Title任意填写,Key填入之前复制的id_rsa.pub.点击Add SSH key,添加已经完成.验证是否成功,输入下列命令:ssh -T git@github.com 如果是第一次的会提示是否continue,输入yes就会看到:You’ve successfully authenticated,but GitHub does not provide shell access.这就表示已成功连上github.创建GitHub项目并添加远程仓库登陆github账户后,点击New repository, 会有Create a new repository页面,填写相关信息,点击Create repository,可以根据官网提供的方式添加远程仓库.如下:…or create a new repository on the command lineecho &quot;# something&quot; &gt;&gt; README.md // 生成readme.md git init // 初始化本地仓库 git add README.md // 将文件添加到暂存区 git commit -m &quot;first commit&quot; // 将暂存区文件提交到仓库中 git remote add origin git@github.com:your-repository // 添加你的远程仓库 git push -u origin master // 将本地仓库推送到远程仓库 …or push an existing repository from the command linegit remote add origin git@github.com:your-repository git push -u origin master 以上步骤完成了本地仓库到远程仓库的连接,接下来总结git的一些常用的命令深入了解可参考 git中文git的常用命令状态和工作区域三种状态已提交: 表示数据已经安全得保存在本地数据库中.已修改: 表示修改了文件,但还没保存到数据库中.已暂存: 表示对一个已修改文件的当前版本做了标记,使之包含在下次提交的快照中.三种工作区域Git仓库目录: 是Git用来保存项目的元数据和对象数据库的地方.这是Git中最重要的部分,从其他计算机克隆仓库时,拷贝的就是这里的数据.工作目录: 对项目的某个版本独立提取出来的内容.这些从Git仓库的压缩数据库中提取出来的文件,放在磁盘上供你使用或修改.暂存区: 是一个文件,保存了下次将提交的文件列表信息,一般在Git仓库目录中.有时也被称作’索引’.工作目录下的两种状态已跟踪: 指被纳入了版本控制的文件,在上一次快照中有它们的记录,在工作一段时间后,它们的状态可能处于为修改,已修改或已暂存.未跟踪: 工作目录中除了已跟踪文件以外的所有其它文件都属于未跟踪文件,它们既不存在与上次快照中,也没有放入暂存区.初次克隆某个仓库的时候,工作目录中的所有文件都属于已跟踪文件,并处于未修改状态.Git工作流程基本的 Git 工作流程如下：在工作目录中修改文件.暂存文件,将文件的快照放入暂存区域.提交更新,找到暂存区域的文件,将快照永久性存储到 Git 仓库目录.如果 Git 目录中保存着的特定版本文件,就属于已提交状态. 如果作了修改并已放入暂存区域，就属于已暂存状态.如果自上次取出后,作了修改但还没有放到暂存区域,就是已修改状态.基础操作初始化Git仓库git init 该命令将创建一个名为.git的子目录,这个子目录含有初始化的Git仓库中所有的必须文件添加文件到暂存区git add &lt;file&gt; // 添加单个文件到暂存区 git add . // &apos;.&apos; 表示所有文件、文件夹和子文件夹 添加文件到仓库git commit // 将暂存区的文件提交到仓库中 git commit -m &apos;提交信息&apos; // -m 带提交信息,说明本次提交内容或修改等 git commit -am // -a Git会自动把所有已经跟踪过的文件暂存一并提交,从而跳过git add步骤 查看文件状态git status // 查看哪些文件处于什么状态 git status -s // git status -short 输出简介显示 ?? filename-1 // 新添加未跟踪文件前面有??标记 A filename-2 // 新添加到暂存区文件前有A标记 M filename-3 // 出现在左边的M表示,该文件被修改了并放入了暂存区 M filename-4 // 出现在右边的M表示该文件被修改了但没放入暂存取 MM filename-5 // 同时出现表示在工作区被修改并提交到暂存区由于在工作区中被修改了,所以说暂存区和工作区都有该文件的修改记录 查看文件具体修改git diff // 该命令查看未暂存的文件更新了哪些部分,用于比较工作目录中当前文件和暂存区域快照之间的差异 git diff --cached // 该命令用于查看已暂存的将要添加到下次提交里的内容 (Git 1.6.1 及更高版本还允许使用 git diff --staged，效果是相同的) 查看提交历史git log // 按提交时间列出所有的更新,最新的更新排在最上面 git log -p -(n) // -p 用来显示每次提交的内容差异. -(n) 仅显示最近n次提交 git log --stat // 每次的简略的统计信息 git log --pretty=oneline // 该选项指定使用不同于默认格式的方式展示提交历史. 可用选项包括oneline,short,full,fuller和format(后跟指定格式) git log --shortstat // 只显示--stat中最后的行数修改添加移除统计 git log --name-only // 仅在提交信息后显示已修改的文件清单 git log --name-status // 显示新增、修改、删除的文件清单 git log --graph // 显示ASCLL图形表示的分支合并历史 git relog // 引用日志,记录了HEAD和分支引用所指向的历史,只存在在于本地仓库 撤销操作git reset HEAD &lt;file&gt; // 丢弃已经进入暂存取的修改 git checkout -- &lt;file&gt; // 丢弃工作区中文件的修改 git checkout -- . // 丢弃当前目录下所有工作区中的修改 退回到某个提交版本git reset --hard HEAD^ // 回退到上一个提交 git reset --hard HEAD^^ // 回退到上上一个提交 git reset --hard &lt;commit_id&gt; // 回退到指定id的提交版本 删除操作在文件未添加到暂存取之前,可以直接物理删除想要删除的文件.或通过git checkout -- &lt;file&gt; 来丢弃修改.如果文件已经被提交,则需要git rm删除git rm &lt;file&gt; // 删除被提交的文件 远程仓库查看远程仓库git remote // 查看已配置的远程仓库服务器 git remote -v // 显示需要读写远程仓库使用的Git保存的简写与对应的URL git remote show &lt;remote-name&gt; // 查看某一个远程仓库的更多信息 添加远程仓库git remote add &lt;remote-name&gt; &lt;url&gt; // 添加地址为URL,名为remote-name的引用 从远程仓库中拉取与推送git fetch &lt;remote-name&gt; // 该命令将数据拉取到本地仓库,并不会自动合并或修改当前的工作 git pull &lt;remote-name&gt; // 改命令自动抓取然后合并远程分支到当前分支 git push &lt;remote-name&gt; &lt;branch-name&gt; // 将branch-name分支推送到remote-name服务器上 git push -u &lt;remote-name&gt; &lt;branch-name&gt; // 第一次使用带上-u参数,在将本地的 master 分支推送到远程新的 master 分支的同时,还会把本地的 master 分支和远程的 master 分支关联起来 远程仓库的移除与重命名git remote rm &lt;remote-name&gt; // 移除远程仓库 git remote rename &lt;old-name&gt; &lt;new-name&gt; // 重命名远程仓库 修改本地仓库对应的远程仓库git remote set-url &lt;remote-name&gt; &lt;url&gt; // 当远程的仓库地址发生变化时,需要修改本地仓库对应的远程仓库地址 分支管理git branch // 查看本地分支信息, 输出内容中,标记*,表示当前所在分支 git branch -v // 查看详细的本地分支信息 git branch &lt;branch-name&gt; // 新建一个branch-name分支 git checkout &lt;branch-name&gt; // 新建完branch-name分支后,并通过该命令切到branch-name分支 git checkout master git merge &lt;branch-name&gt; // 切换回master分支,并将branch-name分支的修改合并到master分支 git branch -d &lt;branch-name&gt; // 删除branch-name分支]]></content>
      <categories>
        <category>善事利器</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github+Hexo+Next博客搭建之Markdown]]></title>
    <url>%2FGithub-Hexo-Next%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%B9%8BMarkdown%2F</url>
    <content type="text"><![CDATA[博客已经搭建好了,自然可以趁热打铁写一些博客搭建的经验.一是方便自己以后查看,免得忘记.二是如果有人想了解博客搭建的过程,也正好有个参考.(如果SEO做的好,就有可能看到这篇文章).本文仅记录怎么去搭建博客,而不会解释每一步原理,有些东西我自己都没有搞的太清楚.毕竟我只是想借助博客这个平台记录平时工作的经验而已,细究相关方面知识并不是我的最终目的.现在回头看博客的搭建过程,可以总结归纳以下几点. markdown,git和GitHub, github和coding部署, Hexo和Next了解, SEO等Markdown工欲善其事,必先利其器.作为程序员,平时的编辑语言首选是markdown,markdown的使用其实很简单.之前除了整理一下文档外,平时倒是用的不多,在此整理一下段落和换行一个Markdown段落前后要有一个以上空行,普通段落不该用空行或制表符来缩进.段落内强迫换行可在插入处键入两个以上空格然后回车.标题markdown支持两种标题,类Setext和Atx形式.类Atx形式是在行首插入1到6个#,分别对应1到6级标题,示例:123# 一级标题## 二级标题### 三级标题区块引用Markdown中建立区块引用,需在行首最前面加上&gt;:1&gt; 这是一个区块引用效果展示:这是一个区块引用区块引用可以嵌套,只要根据层次加上不同数量的&gt;:123&gt; 这是顶层的&gt;&gt; 这是二级引用&gt;&gt;&gt; 这是三级引用效果展示:这是顶层的这是二级引用这是三级引用引用区块内可以使用其他Markdown语法,包括标题、列表、代码区块等:1234567&gt; 列表&gt; 1. item1&gt; 2. item2&gt;&gt; 代码区块&gt;&gt; 这是一个代码区块效果展示:列表item1item2代码区块这是一个代码区块列表Markdown支持有序列表和无序列表.列表项目标记通常放在最左边,也可以缩进,最多3个空格,项目标记后面一定要接着至少一个空格或制表符.列表项目可以包含多个段落,每个项目下的段落都必须缩进四个空格或是一个制表符:123456* 这是第一段落(空行)(四个空格一个制表符)这是第二段落或* 这是第一段落(两个空格)(四个空格一个制表符)这是第二段落效果展示:这是第一段落.这是第二段落这是第一段落这是第二段落列表项目内放进引用,引用需缩进四个空格或一个制表符:12* 列表项目内放进引用(四个空格或一个制表符)&gt; 这是引用一效果展示:列表项目内放进引用这是引用一列表项目内放进代码区块,该区块需缩进两次,八个空格或两个制表符:123* 列表项目内放进代码区块(空行)(八个空格或两个制表符)这是一个代码区块效果展示:列表项目内放进代码区块这是一个代码区块 无序列表无序列表使用星号(*)、加号(+)、减号(-)作为列表标记:123* item + item - item* item + item - item* item + item - item效果展示:itemitemitem有序列表有序列表则是数字接着英文句点( 数字 + . ):1231. item2. item3. item效果展示:item1item2item3代码区块Markdown中建立代码区块,需缩进四个空格或一个制表符:123这是一个普通段落:(空行)(八个空格或两个制表符)这是一个代码区块效果展示:这是一个普通段落:这是一个代码区块 分割线Markdown中的分隔线需三个以上的星号(*)、减号(-)、底线(_).也可以在星号或减号或底线中间插入空格,不影响效果.1234****-----_______**** ***** **********效果展示:链接Markdown支持两种形式的链接语法: 行内式和参考式.链接文字都是用[]标记.行内式行内式链接:1这是一个行内式链接[链接文字](链接URL &quot;链接标题&quot;)效果展示:这是一个行内式链接链接文字参考式1234参考式链接:这是一个参考式链接[链接文字][链接辨别标签](空行)[链接辨别标签]: 链接URL &quot;链接标题&quot;效果展示:这是一个参考式链接链接文字链接内容定义形式:方括号(前面可以选择性加上至多三个空格缩进),里面输入链接文字接着一个冒号接着一个以上的空格或制表符接着链接的网址, 可以用尖括号包起来选择性接着title内容,可以是单引号、双引号或括号,可以放到下一行,也可以加一些缩进链接辨别标签不区分大小写.隐式链接标记隐式链接标记可以省略制定链接标记,此时链接标记等同于链接文字:123这是一个隐式链接标记功能[隐式链接][][隐式链接]: 链接URL &quot;隐式链接标题&quot;效果展示:这是一个隐式链接标记功能隐式链接强调Markdown中标记强调字词需使用星号(*)或底线(_),被单个*或_包围的字词会被&lt;em&gt;标签包围,用两个*或_包起来,则会被转成&lt;strong&gt;,示例:123*强调***强调**__强调__效果展示:强调强调强调如果*或_两边都有空白,它们就只会被当成普通的符号.代码Markdown标记一小段行内代码,需用反引号包起来(`),支持语法高亮,包括:Apache, Bash, CoffeeScript, C++, C#, CSS, HTTP, Java, JavaScript, JSON, Markdown, Nginx, Objective-C, Perl, PHP, Properties, Python, Ruby, Shell Session, SQL, HTML, XML等.示例:1这是一个`行内代码标记`效果展示:这是一个行内代码标记图片Markdown中插入图片,有两种样式: 行内式和参考式.行内式1![图片替代文字](图片链接URL &quot;图片描述&quot;)一个感叹号!接着方括号[],里面是图片的替代文字接着括号,里面是图片的URL,最后还可以选择性加上文字描述.参考式12![图片替代文字][图片参考标记][图片参考标记]: 图片链接URL &quot;图片描述&quot;如果需对图片进行宽高,位置调整,可以使用普通的&lt;img&gt;标签自动链接Markdown支持比较短的自动链接形式来处理网址和电子信箱,需用尖括号&lt;&gt;1&lt;网址的URL&gt;表格Markdown中支持表格,:代表对其方式,:和|之间不能有空格,否则对其会有不兼容.示例:123456789(空格)|左侧|中间|右侧||:---:|:---:|:---:||描述一|描述二|描述三|或(空格)左侧|中间|右侧:---:|:---:|:---:描述一|描述二|描述三效果展示:左侧中间右侧描述一描述二描述三小结Markdown的简单应用到这也差不多写完了,当然还有好多的高级技巧可以自行百度或Google.语法本来就很简单,虽不说十分钟包教包会,但是只要尝试着在键盘上敲两下,看看效果,学会它还是挺容易的.]]></content>
      <categories>
        <category>善事利器</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[序言]]></title>
    <url>%2F%E5%BA%8F%E8%A8%80%2F</url>
    <content type="text"><![CDATA[忙活了好多天终于把博客搭建好了.平时上班的比较忙,利用零零散散的时间看了好多关于搭建博客的文章,消化之后,发现博客的搭建并不是想象那样麻烦.以前一直有搭建博客的想法,可是每每在搭建的过程中就放弃了.原因有很多,一部分是因为从没有接触过类似博客搭建的知识,也有部分原因是也没有搭建博客的需求.为什么写做任何事都是有原因的.有搭博客写博客的想法也是一直都是存在的.在大学的那会儿,一直觉得做程序员是一类高大上的人物,所以一直对这个行业心怀憧憬.平时看些技术型文章时,一般都是来自大牛的博客,写的文章或在第三方平台,或在自己搭建的博客上.就在那个时候,心中就有了能够拥有属于自己博客的想法.于是呢,自己也是有过尝试,但是对于毫无基础的菜鸟来说,那是一种折磨.挑战新的事物的确有意思,但是突然接触到好多不懂的概念,也是一种酸爽.不过随着经历和经验的积累,也慢慢发现,学习任何新的事物,都要有个循循渐进的过程,储备的足够了自然会从量变转为质变.当然这也是后来话了.在这个阶段搭建博客想法无非就是觉得新鲜,满足一下小虚荣.结局呢,可想而知,没有足够的动力,是不能完成有些许挑战性的任务的.毕竟动物趋于安逸,生性懒惰,没有压力,哪来的奔波.人,也是动物.毕业之后,就开始步入社会,这时候就要考虑如何谋生了.所幸的是,自己从一开始就选择了前端这个行业.从一个毕业就是失业的专业跳到了一个陌生的领域,除了曾经那一丝丝的憧憬让人有所安慰外,剩下的就是彷徨不安.在自学了一段时间的前端基础后,迫于对自身学习成果的不满和外在压力,硬着头皮投递了各家招聘网站的公司.白天参加面试,晚上还要学习巩固白天面试官提的问题.人的潜力或效率有时候还真是逼出来的.在面试期间的确学到了好多东西,也大概的知道了,这类行业到底需要什么样的人.人知道的越多,也就越知道不知道的太多.那时候自己就迫切希望能够稳定下来夯实一下自己的基础.经过一段时间的东奔西跑,找到了人生的第一份正式的工作.准确的说,是被找上了.不是说我的技术有多厉害,而是这份工作压根不需要什么技术.本来我是想拒绝的,也坦言了自己的状况.毕竟我是抱着学技术的心态出来的.可是经过一轮轮的面试,我也是知道,技术的重要性,再加上人家知道情况后还是要留人,那我也就留着呗.留在公司后,就是用cms搭个网站,申请个微信公众号做微信运营什么的.那时候真的什么都不知道,各种百度啊什么的.不过最终还是让我捣鼓出来了.之后日子也就安逸了,不过每天也是提心吊胆的,生怕哪一天老板又整出什么幺蛾子.时间空出来了,搭建博客的想法也是突然又重现在脑海中.趁着机会可以建站搭博客.所以,回家后又开始忙活起如何建站.可想法是好的,现实却偏偏作对.公司一直筹划着一些活动,微信上的一些活动也要同步得做起来,我又开始了各种网站收集资源.所以,搭博客的想法又泡汤了,而且学的前端基础在这段时间也丢了不少.换了工作后,接触的到了具体实在的项目,积累的相关经验也就多了起来,一些笔记类的应用也用了起来.在开发过程中会遇到许多问题,自己也就更加主动去接受新的知识.可是虽然看到了好的文章,也收藏了起来,但是同样也犯了好多人犯的毛病.收藏夹里的记录一天天增加,却从来没有再次看过.而且,平时看的东西太过零散,无法形成自己的一套知识体系. 动力有了,搭建博客的想法也最终可以落实了.怎么去写个人平时不善言辞,尤其平时做工作汇报时,最是尴尬,忙得要死结果几句话就给总结了.这突然让我想起了学生时代写作文的时候,我是如何凑足字数的.由于自身随心随性,不喜欢约束,只要有个大的目标就行了.个人觉得,约束后的自己不再是自己.有规划更要有自己的想法.我向来不喜欢照搬别人的做法.即使权威,也是不行.模具可以快速生产出许多成品,却无法产出一件精品.写东西也是要看状态的,尤其在写总结性的东西,需要把自己的想法加进去.状态在了,有时候看待问题会更加彻底.至于偏向于技术类型的东西,那就随便了,起码在我看来,那都是套路.无非就是要记录一下问题的解决方案.写什么虽然搭博客的起因更多的来源于总结自己的工作经验.但是这个世界不只有眼前的苟且,还有诗与远方对于洒脱成性的我,看待生活时,总会时不时得冒出自己的想法和感悟.虽说不是写诗,但是凝练文采,沉淀底蕴,未尝不可.小结终于到了小结了,本以为自己言语匮乏.没想到也已经写了这么多.万一哪天灵感来了,估计会写出一部中篇小说.万事开头难,本来想是直接进入主题,写经验总结的.但唯恐坚持不下去,就写了这篇序言,以增加仪式感,希望自己能够坚持下去.]]></content>
      <categories>
        <category>不语</category>
      </categories>
      <tags>
        <tag>序言</tag>
        <tag>博客</tag>
      </tags>
  </entry>
</search>
